/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.p2p = (function() {

    /**
     * Namespace p2p.
     * @exports p2p
     * @namespace
     */
    var p2p = {};

    p2p.VrfProof = (function() {

        /**
         * Properties of a VrfProof.
         * @memberof p2p
         * @interface IVrfProof
         * @property {Uint8Array|null} [gamma] VrfProof gamma
         * @property {Uint8Array|null} [c] VrfProof c
         * @property {Uint8Array|null} [s] VrfProof s
         * @property {Uint8Array|null} [output] VrfProof output
         */

        /**
         * Constructs a new VrfProof.
         * @memberof p2p
         * @classdesc Represents a VrfProof.
         * @implements IVrfProof
         * @constructor
         * @param {p2p.IVrfProof=} [properties] Properties to set
         */
        function VrfProof(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VrfProof gamma.
         * @member {Uint8Array} gamma
         * @memberof p2p.VrfProof
         * @instance
         */
        VrfProof.prototype.gamma = $util.newBuffer([]);

        /**
         * VrfProof c.
         * @member {Uint8Array} c
         * @memberof p2p.VrfProof
         * @instance
         */
        VrfProof.prototype.c = $util.newBuffer([]);

        /**
         * VrfProof s.
         * @member {Uint8Array} s
         * @memberof p2p.VrfProof
         * @instance
         */
        VrfProof.prototype.s = $util.newBuffer([]);

        /**
         * VrfProof output.
         * @member {Uint8Array} output
         * @memberof p2p.VrfProof
         * @instance
         */
        VrfProof.prototype.output = $util.newBuffer([]);

        /**
         * Creates a new VrfProof instance using the specified properties.
         * @function create
         * @memberof p2p.VrfProof
         * @static
         * @param {p2p.IVrfProof=} [properties] Properties to set
         * @returns {p2p.VrfProof} VrfProof instance
         */
        VrfProof.create = function create(properties) {
            return new VrfProof(properties);
        };

        /**
         * Encodes the specified VrfProof message. Does not implicitly {@link p2p.VrfProof.verify|verify} messages.
         * @function encode
         * @memberof p2p.VrfProof
         * @static
         * @param {p2p.IVrfProof} message VrfProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VrfProof.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gamma != null && Object.hasOwnProperty.call(message, "gamma"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.gamma);
            if (message.c != null && Object.hasOwnProperty.call(message, "c"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.c);
            if (message.s != null && Object.hasOwnProperty.call(message, "s"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.s);
            if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.output);
            return writer;
        };

        /**
         * Encodes the specified VrfProof message, length delimited. Does not implicitly {@link p2p.VrfProof.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.VrfProof
         * @static
         * @param {p2p.IVrfProof} message VrfProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VrfProof.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VrfProof message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.VrfProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.VrfProof} VrfProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VrfProof.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.VrfProof();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.gamma = reader.bytes();
                        break;
                    }
                case 2: {
                        message.c = reader.bytes();
                        break;
                    }
                case 3: {
                        message.s = reader.bytes();
                        break;
                    }
                case 4: {
                        message.output = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VrfProof message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.VrfProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.VrfProof} VrfProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VrfProof.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VrfProof message.
         * @function verify
         * @memberof p2p.VrfProof
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VrfProof.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                if (!(message.gamma && typeof message.gamma.length === "number" || $util.isString(message.gamma)))
                    return "gamma: buffer expected";
            if (message.c != null && message.hasOwnProperty("c"))
                if (!(message.c && typeof message.c.length === "number" || $util.isString(message.c)))
                    return "c: buffer expected";
            if (message.s != null && message.hasOwnProperty("s"))
                if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                    return "s: buffer expected";
            if (message.output != null && message.hasOwnProperty("output"))
                if (!(message.output && typeof message.output.length === "number" || $util.isString(message.output)))
                    return "output: buffer expected";
            return null;
        };

        /**
         * Creates a VrfProof message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.VrfProof
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.VrfProof} VrfProof
         */
        VrfProof.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.VrfProof)
                return object;
            var message = new $root.p2p.VrfProof();
            if (object.gamma != null)
                if (typeof object.gamma === "string")
                    $util.base64.decode(object.gamma, message.gamma = $util.newBuffer($util.base64.length(object.gamma)), 0);
                else if (object.gamma.length >= 0)
                    message.gamma = object.gamma;
            if (object.c != null)
                if (typeof object.c === "string")
                    $util.base64.decode(object.c, message.c = $util.newBuffer($util.base64.length(object.c)), 0);
                else if (object.c.length >= 0)
                    message.c = object.c;
            if (object.s != null)
                if (typeof object.s === "string")
                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                else if (object.s.length >= 0)
                    message.s = object.s;
            if (object.output != null)
                if (typeof object.output === "string")
                    $util.base64.decode(object.output, message.output = $util.newBuffer($util.base64.length(object.output)), 0);
                else if (object.output.length >= 0)
                    message.output = object.output;
            return message;
        };

        /**
         * Creates a plain object from a VrfProof message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.VrfProof
         * @static
         * @param {p2p.VrfProof} message VrfProof
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VrfProof.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.gamma = "";
                else {
                    object.gamma = [];
                    if (options.bytes !== Array)
                        object.gamma = $util.newBuffer(object.gamma);
                }
                if (options.bytes === String)
                    object.c = "";
                else {
                    object.c = [];
                    if (options.bytes !== Array)
                        object.c = $util.newBuffer(object.c);
                }
                if (options.bytes === String)
                    object.s = "";
                else {
                    object.s = [];
                    if (options.bytes !== Array)
                        object.s = $util.newBuffer(object.s);
                }
                if (options.bytes === String)
                    object.output = "";
                else {
                    object.output = [];
                    if (options.bytes !== Array)
                        object.output = $util.newBuffer(object.output);
                }
            }
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.bytes === String ? $util.base64.encode(message.gamma, 0, message.gamma.length) : options.bytes === Array ? Array.prototype.slice.call(message.gamma) : message.gamma;
            if (message.c != null && message.hasOwnProperty("c"))
                object.c = options.bytes === String ? $util.base64.encode(message.c, 0, message.c.length) : options.bytes === Array ? Array.prototype.slice.call(message.c) : message.c;
            if (message.s != null && message.hasOwnProperty("s"))
                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
            if (message.output != null && message.hasOwnProperty("output"))
                object.output = options.bytes === String ? $util.base64.encode(message.output, 0, message.output.length) : options.bytes === Array ? Array.prototype.slice.call(message.output) : message.output;
            return object;
        };

        /**
         * Converts this VrfProof to JSON.
         * @function toJSON
         * @memberof p2p.VrfProof
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VrfProof.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VrfProof
         * @function getTypeUrl
         * @memberof p2p.VrfProof
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VrfProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.VrfProof";
        };

        return VrfProof;
    })();

    p2p.VdfProof = (function() {

        /**
         * Properties of a VdfProof.
         * @memberof p2p
         * @interface IVdfProof
         * @property {Uint8Array|null} [y] VdfProof y
         * @property {Uint8Array|null} [pi] VdfProof pi
         * @property {Uint8Array|null} [l] VdfProof l
         * @property {Uint8Array|null} [r] VdfProof r
         * @property {number|Long|null} [iterations] VdfProof iterations
         */

        /**
         * Constructs a new VdfProof.
         * @memberof p2p
         * @classdesc Represents a VdfProof.
         * @implements IVdfProof
         * @constructor
         * @param {p2p.IVdfProof=} [properties] Properties to set
         */
        function VdfProof(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VdfProof y.
         * @member {Uint8Array} y
         * @memberof p2p.VdfProof
         * @instance
         */
        VdfProof.prototype.y = $util.newBuffer([]);

        /**
         * VdfProof pi.
         * @member {Uint8Array} pi
         * @memberof p2p.VdfProof
         * @instance
         */
        VdfProof.prototype.pi = $util.newBuffer([]);

        /**
         * VdfProof l.
         * @member {Uint8Array} l
         * @memberof p2p.VdfProof
         * @instance
         */
        VdfProof.prototype.l = $util.newBuffer([]);

        /**
         * VdfProof r.
         * @member {Uint8Array} r
         * @memberof p2p.VdfProof
         * @instance
         */
        VdfProof.prototype.r = $util.newBuffer([]);

        /**
         * VdfProof iterations.
         * @member {number|Long} iterations
         * @memberof p2p.VdfProof
         * @instance
         */
        VdfProof.prototype.iterations = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new VdfProof instance using the specified properties.
         * @function create
         * @memberof p2p.VdfProof
         * @static
         * @param {p2p.IVdfProof=} [properties] Properties to set
         * @returns {p2p.VdfProof} VdfProof instance
         */
        VdfProof.create = function create(properties) {
            return new VdfProof(properties);
        };

        /**
         * Encodes the specified VdfProof message. Does not implicitly {@link p2p.VdfProof.verify|verify} messages.
         * @function encode
         * @memberof p2p.VdfProof
         * @static
         * @param {p2p.IVdfProof} message VdfProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VdfProof.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.y);
            if (message.pi != null && Object.hasOwnProperty.call(message, "pi"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pi);
            if (message.l != null && Object.hasOwnProperty.call(message, "l"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.l);
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.r);
            if (message.iterations != null && Object.hasOwnProperty.call(message, "iterations"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.iterations);
            return writer;
        };

        /**
         * Encodes the specified VdfProof message, length delimited. Does not implicitly {@link p2p.VdfProof.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.VdfProof
         * @static
         * @param {p2p.IVdfProof} message VdfProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VdfProof.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VdfProof message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.VdfProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.VdfProof} VdfProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VdfProof.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.VdfProof();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.y = reader.bytes();
                        break;
                    }
                case 2: {
                        message.pi = reader.bytes();
                        break;
                    }
                case 3: {
                        message.l = reader.bytes();
                        break;
                    }
                case 4: {
                        message.r = reader.bytes();
                        break;
                    }
                case 5: {
                        message.iterations = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VdfProof message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.VdfProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.VdfProof} VdfProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VdfProof.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VdfProof message.
         * @function verify
         * @memberof p2p.VdfProof
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VdfProof.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!(message.y && typeof message.y.length === "number" || $util.isString(message.y)))
                    return "y: buffer expected";
            if (message.pi != null && message.hasOwnProperty("pi"))
                if (!(message.pi && typeof message.pi.length === "number" || $util.isString(message.pi)))
                    return "pi: buffer expected";
            if (message.l != null && message.hasOwnProperty("l"))
                if (!(message.l && typeof message.l.length === "number" || $util.isString(message.l)))
                    return "l: buffer expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!(message.r && typeof message.r.length === "number" || $util.isString(message.r)))
                    return "r: buffer expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations) && !(message.iterations && $util.isInteger(message.iterations.low) && $util.isInteger(message.iterations.high)))
                    return "iterations: integer|Long expected";
            return null;
        };

        /**
         * Creates a VdfProof message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.VdfProof
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.VdfProof} VdfProof
         */
        VdfProof.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.VdfProof)
                return object;
            var message = new $root.p2p.VdfProof();
            if (object.y != null)
                if (typeof object.y === "string")
                    $util.base64.decode(object.y, message.y = $util.newBuffer($util.base64.length(object.y)), 0);
                else if (object.y.length >= 0)
                    message.y = object.y;
            if (object.pi != null)
                if (typeof object.pi === "string")
                    $util.base64.decode(object.pi, message.pi = $util.newBuffer($util.base64.length(object.pi)), 0);
                else if (object.pi.length >= 0)
                    message.pi = object.pi;
            if (object.l != null)
                if (typeof object.l === "string")
                    $util.base64.decode(object.l, message.l = $util.newBuffer($util.base64.length(object.l)), 0);
                else if (object.l.length >= 0)
                    message.l = object.l;
            if (object.r != null)
                if (typeof object.r === "string")
                    $util.base64.decode(object.r, message.r = $util.newBuffer($util.base64.length(object.r)), 0);
                else if (object.r.length >= 0)
                    message.r = object.r;
            if (object.iterations != null)
                if ($util.Long)
                    (message.iterations = $util.Long.fromValue(object.iterations)).unsigned = true;
                else if (typeof object.iterations === "string")
                    message.iterations = parseInt(object.iterations, 10);
                else if (typeof object.iterations === "number")
                    message.iterations = object.iterations;
                else if (typeof object.iterations === "object")
                    message.iterations = new $util.LongBits(object.iterations.low >>> 0, object.iterations.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a VdfProof message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.VdfProof
         * @static
         * @param {p2p.VdfProof} message VdfProof
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VdfProof.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.y = "";
                else {
                    object.y = [];
                    if (options.bytes !== Array)
                        object.y = $util.newBuffer(object.y);
                }
                if (options.bytes === String)
                    object.pi = "";
                else {
                    object.pi = [];
                    if (options.bytes !== Array)
                        object.pi = $util.newBuffer(object.pi);
                }
                if (options.bytes === String)
                    object.l = "";
                else {
                    object.l = [];
                    if (options.bytes !== Array)
                        object.l = $util.newBuffer(object.l);
                }
                if (options.bytes === String)
                    object.r = "";
                else {
                    object.r = [];
                    if (options.bytes !== Array)
                        object.r = $util.newBuffer(object.r);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.iterations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.iterations = options.longs === String ? "0" : 0;
            }
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.bytes === String ? $util.base64.encode(message.y, 0, message.y.length) : options.bytes === Array ? Array.prototype.slice.call(message.y) : message.y;
            if (message.pi != null && message.hasOwnProperty("pi"))
                object.pi = options.bytes === String ? $util.base64.encode(message.pi, 0, message.pi.length) : options.bytes === Array ? Array.prototype.slice.call(message.pi) : message.pi;
            if (message.l != null && message.hasOwnProperty("l"))
                object.l = options.bytes === String ? $util.base64.encode(message.l, 0, message.l.length) : options.bytes === Array ? Array.prototype.slice.call(message.l) : message.l;
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = options.bytes === String ? $util.base64.encode(message.r, 0, message.r.length) : options.bytes === Array ? Array.prototype.slice.call(message.r) : message.r;
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (typeof message.iterations === "number")
                    object.iterations = options.longs === String ? String(message.iterations) : message.iterations;
                else
                    object.iterations = options.longs === String ? $util.Long.prototype.toString.call(message.iterations) : options.longs === Number ? new $util.LongBits(message.iterations.low >>> 0, message.iterations.high >>> 0).toNumber(true) : message.iterations;
            return object;
        };

        /**
         * Converts this VdfProof to JSON.
         * @function toJSON
         * @memberof p2p.VdfProof
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VdfProof.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VdfProof
         * @function getTypeUrl
         * @memberof p2p.VdfProof
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VdfProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.VdfProof";
        };

        return VdfProof;
    })();

    p2p.Challenge = (function() {

        /**
         * Properties of a Challenge.
         * @memberof p2p
         * @interface IChallenge
         * @property {string|null} [challenge] Challenge challenge
         * @property {string|null} [from] Challenge from
         * @property {string|null} [difficulty] Challenge difficulty
         */

        /**
         * Constructs a new Challenge.
         * @memberof p2p
         * @classdesc Represents a Challenge.
         * @implements IChallenge
         * @constructor
         * @param {p2p.IChallenge=} [properties] Properties to set
         */
        function Challenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Challenge challenge.
         * @member {string} challenge
         * @memberof p2p.Challenge
         * @instance
         */
        Challenge.prototype.challenge = "";

        /**
         * Challenge from.
         * @member {string} from
         * @memberof p2p.Challenge
         * @instance
         */
        Challenge.prototype.from = "";

        /**
         * Challenge difficulty.
         * @member {string} difficulty
         * @memberof p2p.Challenge
         * @instance
         */
        Challenge.prototype.difficulty = "";

        /**
         * Creates a new Challenge instance using the specified properties.
         * @function create
         * @memberof p2p.Challenge
         * @static
         * @param {p2p.IChallenge=} [properties] Properties to set
         * @returns {p2p.Challenge} Challenge instance
         */
        Challenge.create = function create(properties) {
            return new Challenge(properties);
        };

        /**
         * Encodes the specified Challenge message. Does not implicitly {@link p2p.Challenge.verify|verify} messages.
         * @function encode
         * @memberof p2p.Challenge
         * @static
         * @param {p2p.IChallenge} message Challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Challenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.challenge);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.from);
            if (message.difficulty != null && Object.hasOwnProperty.call(message, "difficulty"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.difficulty);
            return writer;
        };

        /**
         * Encodes the specified Challenge message, length delimited. Does not implicitly {@link p2p.Challenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.Challenge
         * @static
         * @param {p2p.IChallenge} message Challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Challenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Challenge message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.Challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.Challenge} Challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Challenge.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.Challenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.challenge = reader.string();
                        break;
                    }
                case 2: {
                        message.from = reader.string();
                        break;
                    }
                case 3: {
                        message.difficulty = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Challenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.Challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.Challenge} Challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Challenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Challenge message.
         * @function verify
         * @memberof p2p.Challenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Challenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                if (!$util.isString(message.challenge))
                    return "challenge: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isString(message.from))
                    return "from: string expected";
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                if (!$util.isString(message.difficulty))
                    return "difficulty: string expected";
            return null;
        };

        /**
         * Creates a Challenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.Challenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.Challenge} Challenge
         */
        Challenge.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.Challenge)
                return object;
            var message = new $root.p2p.Challenge();
            if (object.challenge != null)
                message.challenge = String(object.challenge);
            if (object.from != null)
                message.from = String(object.from);
            if (object.difficulty != null)
                message.difficulty = String(object.difficulty);
            return message;
        };

        /**
         * Creates a plain object from a Challenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.Challenge
         * @static
         * @param {p2p.Challenge} message Challenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Challenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.challenge = "";
                object.from = "";
                object.difficulty = "";
            }
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                object.challenge = message.challenge;
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                object.difficulty = message.difficulty;
            return object;
        };

        /**
         * Converts this Challenge to JSON.
         * @function toJSON
         * @memberof p2p.Challenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Challenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Challenge
         * @function getTypeUrl
         * @memberof p2p.Challenge
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Challenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.Challenge";
        };

        return Challenge;
    })();

    p2p.ChallengeResponse = (function() {

        /**
         * Properties of a ChallengeResponse.
         * @memberof p2p
         * @interface IChallengeResponse
         * @property {string|null} [solution] ChallengeResponse solution
         * @property {string|null} [nonce] ChallengeResponse nonce
         * @property {string|null} [from] ChallengeResponse from
         */

        /**
         * Constructs a new ChallengeResponse.
         * @memberof p2p
         * @classdesc Represents a ChallengeResponse.
         * @implements IChallengeResponse
         * @constructor
         * @param {p2p.IChallengeResponse=} [properties] Properties to set
         */
        function ChallengeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeResponse solution.
         * @member {string} solution
         * @memberof p2p.ChallengeResponse
         * @instance
         */
        ChallengeResponse.prototype.solution = "";

        /**
         * ChallengeResponse nonce.
         * @member {string} nonce
         * @memberof p2p.ChallengeResponse
         * @instance
         */
        ChallengeResponse.prototype.nonce = "";

        /**
         * ChallengeResponse from.
         * @member {string} from
         * @memberof p2p.ChallengeResponse
         * @instance
         */
        ChallengeResponse.prototype.from = "";

        /**
         * Creates a new ChallengeResponse instance using the specified properties.
         * @function create
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {p2p.IChallengeResponse=} [properties] Properties to set
         * @returns {p2p.ChallengeResponse} ChallengeResponse instance
         */
        ChallengeResponse.create = function create(properties) {
            return new ChallengeResponse(properties);
        };

        /**
         * Encodes the specified ChallengeResponse message. Does not implicitly {@link p2p.ChallengeResponse.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {p2p.IChallengeResponse} message ChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.solution != null && Object.hasOwnProperty.call(message, "solution"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.solution);
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nonce);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.from);
            return writer;
        };

        /**
         * Encodes the specified ChallengeResponse message, length delimited. Does not implicitly {@link p2p.ChallengeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {p2p.IChallengeResponse} message ChallengeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChallengeResponse} ChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChallengeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.solution = reader.string();
                        break;
                    }
                case 2: {
                        message.nonce = reader.string();
                        break;
                    }
                case 3: {
                        message.from = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChallengeResponse} ChallengeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeResponse message.
         * @function verify
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.solution != null && message.hasOwnProperty("solution"))
                if (!$util.isString(message.solution))
                    return "solution: string expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isString(message.nonce))
                    return "nonce: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isString(message.from))
                    return "from: string expected";
            return null;
        };

        /**
         * Creates a ChallengeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChallengeResponse} ChallengeResponse
         */
        ChallengeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChallengeResponse)
                return object;
            var message = new $root.p2p.ChallengeResponse();
            if (object.solution != null)
                message.solution = String(object.solution);
            if (object.nonce != null)
                message.nonce = String(object.nonce);
            if (object.from != null)
                message.from = String(object.from);
            return message;
        };

        /**
         * Creates a plain object from a ChallengeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {p2p.ChallengeResponse} message ChallengeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.solution = "";
                object.nonce = "";
                object.from = "";
            }
            if (message.solution != null && message.hasOwnProperty("solution"))
                object.solution = message.solution;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = message.nonce;
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            return object;
        };

        /**
         * Converts this ChallengeResponse to JSON.
         * @function toJSON
         * @memberof p2p.ChallengeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChallengeResponse
         * @function getTypeUrl
         * @memberof p2p.ChallengeResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChallengeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChallengeResponse";
        };

        return ChallengeResponse;
    })();

    p2p.DirectBlockRequest = (function() {

        /**
         * Properties of a DirectBlockRequest.
         * @memberof p2p
         * @interface IDirectBlockRequest
         * @property {string|null} [hash] DirectBlockRequest hash
         */

        /**
         * Constructs a new DirectBlockRequest.
         * @memberof p2p
         * @classdesc Represents a DirectBlockRequest.
         * @implements IDirectBlockRequest
         * @constructor
         * @param {p2p.IDirectBlockRequest=} [properties] Properties to set
         */
        function DirectBlockRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DirectBlockRequest hash.
         * @member {string} hash
         * @memberof p2p.DirectBlockRequest
         * @instance
         */
        DirectBlockRequest.prototype.hash = "";

        /**
         * Creates a new DirectBlockRequest instance using the specified properties.
         * @function create
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {p2p.IDirectBlockRequest=} [properties] Properties to set
         * @returns {p2p.DirectBlockRequest} DirectBlockRequest instance
         */
        DirectBlockRequest.create = function create(properties) {
            return new DirectBlockRequest(properties);
        };

        /**
         * Encodes the specified DirectBlockRequest message. Does not implicitly {@link p2p.DirectBlockRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {p2p.IDirectBlockRequest} message DirectBlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DirectBlockRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            return writer;
        };

        /**
         * Encodes the specified DirectBlockRequest message, length delimited. Does not implicitly {@link p2p.DirectBlockRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {p2p.IDirectBlockRequest} message DirectBlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DirectBlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DirectBlockRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.DirectBlockRequest} DirectBlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DirectBlockRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.DirectBlockRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DirectBlockRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.DirectBlockRequest} DirectBlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DirectBlockRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DirectBlockRequest message.
         * @function verify
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DirectBlockRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };

        /**
         * Creates a DirectBlockRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.DirectBlockRequest} DirectBlockRequest
         */
        DirectBlockRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.DirectBlockRequest)
                return object;
            var message = new $root.p2p.DirectBlockRequest();
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };

        /**
         * Creates a plain object from a DirectBlockRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {p2p.DirectBlockRequest} message DirectBlockRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DirectBlockRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hash = "";
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };

        /**
         * Converts this DirectBlockRequest to JSON.
         * @function toJSON
         * @memberof p2p.DirectBlockRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DirectBlockRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DirectBlockRequest
         * @function getTypeUrl
         * @memberof p2p.DirectBlockRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DirectBlockRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.DirectBlockRequest";
        };

        return DirectBlockRequest;
    })();

    p2p.BlockTransferResponse = (function() {

        /**
         * Properties of a BlockTransferResponse.
         * @memberof p2p
         * @interface IBlockTransferResponse
         * @property {p2p.IBlock|null} [blockData] BlockTransferResponse blockData
         * @property {string|null} [errorReason] BlockTransferResponse errorReason
         */

        /**
         * Constructs a new BlockTransferResponse.
         * @memberof p2p
         * @classdesc Represents a BlockTransferResponse.
         * @implements IBlockTransferResponse
         * @constructor
         * @param {p2p.IBlockTransferResponse=} [properties] Properties to set
         */
        function BlockTransferResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockTransferResponse blockData.
         * @member {p2p.IBlock|null|undefined} blockData
         * @memberof p2p.BlockTransferResponse
         * @instance
         */
        BlockTransferResponse.prototype.blockData = null;

        /**
         * BlockTransferResponse errorReason.
         * @member {string|null|undefined} errorReason
         * @memberof p2p.BlockTransferResponse
         * @instance
         */
        BlockTransferResponse.prototype.errorReason = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * BlockTransferResponse payload.
         * @member {"blockData"|"errorReason"|undefined} payload
         * @memberof p2p.BlockTransferResponse
         * @instance
         */
        Object.defineProperty(BlockTransferResponse.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["blockData", "errorReason"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new BlockTransferResponse instance using the specified properties.
         * @function create
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {p2p.IBlockTransferResponse=} [properties] Properties to set
         * @returns {p2p.BlockTransferResponse} BlockTransferResponse instance
         */
        BlockTransferResponse.create = function create(properties) {
            return new BlockTransferResponse(properties);
        };

        /**
         * Encodes the specified BlockTransferResponse message. Does not implicitly {@link p2p.BlockTransferResponse.verify|verify} messages.
         * @function encode
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {p2p.IBlockTransferResponse} message BlockTransferResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockTransferResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockData != null && Object.hasOwnProperty.call(message, "blockData"))
                $root.p2p.Block.encode(message.blockData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.errorReason != null && Object.hasOwnProperty.call(message, "errorReason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorReason);
            return writer;
        };

        /**
         * Encodes the specified BlockTransferResponse message, length delimited. Does not implicitly {@link p2p.BlockTransferResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {p2p.IBlockTransferResponse} message BlockTransferResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockTransferResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockTransferResponse message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.BlockTransferResponse} BlockTransferResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockTransferResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.BlockTransferResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.blockData = $root.p2p.Block.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.errorReason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockTransferResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.BlockTransferResponse} BlockTransferResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockTransferResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockTransferResponse message.
         * @function verify
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockTransferResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.blockData != null && message.hasOwnProperty("blockData")) {
                properties.payload = 1;
                {
                    var error = $root.p2p.Block.verify(message.blockData);
                    if (error)
                        return "blockData." + error;
                }
            }
            if (message.errorReason != null && message.hasOwnProperty("errorReason")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                if (!$util.isString(message.errorReason))
                    return "errorReason: string expected";
            }
            return null;
        };

        /**
         * Creates a BlockTransferResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.BlockTransferResponse} BlockTransferResponse
         */
        BlockTransferResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.BlockTransferResponse)
                return object;
            var message = new $root.p2p.BlockTransferResponse();
            if (object.blockData != null) {
                if (typeof object.blockData !== "object")
                    throw TypeError(".p2p.BlockTransferResponse.blockData: object expected");
                message.blockData = $root.p2p.Block.fromObject(object.blockData);
            }
            if (object.errorReason != null)
                message.errorReason = String(object.errorReason);
            return message;
        };

        /**
         * Creates a plain object from a BlockTransferResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {p2p.BlockTransferResponse} message BlockTransferResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockTransferResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.blockData != null && message.hasOwnProperty("blockData")) {
                object.blockData = $root.p2p.Block.toObject(message.blockData, options);
                if (options.oneofs)
                    object.payload = "blockData";
            }
            if (message.errorReason != null && message.hasOwnProperty("errorReason")) {
                object.errorReason = message.errorReason;
                if (options.oneofs)
                    object.payload = "errorReason";
            }
            return object;
        };

        /**
         * Converts this BlockTransferResponse to JSON.
         * @function toJSON
         * @memberof p2p.BlockTransferResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockTransferResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BlockTransferResponse
         * @function getTypeUrl
         * @memberof p2p.BlockTransferResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockTransferResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.BlockTransferResponse";
        };

        return BlockTransferResponse;
    })();

    p2p.TransactionInput = (function() {

        /**
         * Properties of a TransactionInput.
         * @memberof p2p
         * @interface ITransactionInput
         * @property {Uint8Array|null} [commitment] TransactionInput commitment
         * @property {number|Long|null} [sourceHeight] TransactionInput sourceHeight
         */

        /**
         * Constructs a new TransactionInput.
         * @memberof p2p
         * @classdesc Represents a TransactionInput.
         * @implements ITransactionInput
         * @constructor
         * @param {p2p.ITransactionInput=} [properties] Properties to set
         */
        function TransactionInput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInput commitment.
         * @member {Uint8Array} commitment
         * @memberof p2p.TransactionInput
         * @instance
         */
        TransactionInput.prototype.commitment = $util.newBuffer([]);

        /**
         * TransactionInput sourceHeight.
         * @member {number|Long} sourceHeight
         * @memberof p2p.TransactionInput
         * @instance
         */
        TransactionInput.prototype.sourceHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionInput instance using the specified properties.
         * @function create
         * @memberof p2p.TransactionInput
         * @static
         * @param {p2p.ITransactionInput=} [properties] Properties to set
         * @returns {p2p.TransactionInput} TransactionInput instance
         */
        TransactionInput.create = function create(properties) {
            return new TransactionInput(properties);
        };

        /**
         * Encodes the specified TransactionInput message. Does not implicitly {@link p2p.TransactionInput.verify|verify} messages.
         * @function encode
         * @memberof p2p.TransactionInput
         * @static
         * @param {p2p.ITransactionInput} message TransactionInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.commitment);
            if (message.sourceHeight != null && Object.hasOwnProperty.call(message, "sourceHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sourceHeight);
            return writer;
        };

        /**
         * Encodes the specified TransactionInput message, length delimited. Does not implicitly {@link p2p.TransactionInput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.TransactionInput
         * @static
         * @param {p2p.ITransactionInput} message TransactionInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInput message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.TransactionInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.TransactionInput} TransactionInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInput.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.TransactionInput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commitment = reader.bytes();
                        break;
                    }
                case 2: {
                        message.sourceHeight = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.TransactionInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.TransactionInput} TransactionInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInput message.
         * @function verify
         * @memberof p2p.TransactionInput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.commitment != null && message.hasOwnProperty("commitment"))
                if (!(message.commitment && typeof message.commitment.length === "number" || $util.isString(message.commitment)))
                    return "commitment: buffer expected";
            if (message.sourceHeight != null && message.hasOwnProperty("sourceHeight"))
                if (!$util.isInteger(message.sourceHeight) && !(message.sourceHeight && $util.isInteger(message.sourceHeight.low) && $util.isInteger(message.sourceHeight.high)))
                    return "sourceHeight: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.TransactionInput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.TransactionInput} TransactionInput
         */
        TransactionInput.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.TransactionInput)
                return object;
            var message = new $root.p2p.TransactionInput();
            if (object.commitment != null)
                if (typeof object.commitment === "string")
                    $util.base64.decode(object.commitment, message.commitment = $util.newBuffer($util.base64.length(object.commitment)), 0);
                else if (object.commitment.length >= 0)
                    message.commitment = object.commitment;
            if (object.sourceHeight != null)
                if ($util.Long)
                    (message.sourceHeight = $util.Long.fromValue(object.sourceHeight)).unsigned = true;
                else if (typeof object.sourceHeight === "string")
                    message.sourceHeight = parseInt(object.sourceHeight, 10);
                else if (typeof object.sourceHeight === "number")
                    message.sourceHeight = object.sourceHeight;
                else if (typeof object.sourceHeight === "object")
                    message.sourceHeight = new $util.LongBits(object.sourceHeight.low >>> 0, object.sourceHeight.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.TransactionInput
         * @static
         * @param {p2p.TransactionInput} message TransactionInput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.commitment = "";
                else {
                    object.commitment = [];
                    if (options.bytes !== Array)
                        object.commitment = $util.newBuffer(object.commitment);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sourceHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sourceHeight = options.longs === String ? "0" : 0;
            }
            if (message.commitment != null && message.hasOwnProperty("commitment"))
                object.commitment = options.bytes === String ? $util.base64.encode(message.commitment, 0, message.commitment.length) : options.bytes === Array ? Array.prototype.slice.call(message.commitment) : message.commitment;
            if (message.sourceHeight != null && message.hasOwnProperty("sourceHeight"))
                if (typeof message.sourceHeight === "number")
                    object.sourceHeight = options.longs === String ? String(message.sourceHeight) : message.sourceHeight;
                else
                    object.sourceHeight = options.longs === String ? $util.Long.prototype.toString.call(message.sourceHeight) : options.longs === Number ? new $util.LongBits(message.sourceHeight.low >>> 0, message.sourceHeight.high >>> 0).toNumber(true) : message.sourceHeight;
            return object;
        };

        /**
         * Converts this TransactionInput to JSON.
         * @function toJSON
         * @memberof p2p.TransactionInput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransactionInput
         * @function getTypeUrl
         * @memberof p2p.TransactionInput
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionInput.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.TransactionInput";
        };

        return TransactionInput;
    })();

    p2p.TransactionOutput = (function() {

        /**
         * Properties of a TransactionOutput.
         * @memberof p2p
         * @interface ITransactionOutput
         * @property {Uint8Array|null} [commitment] TransactionOutput commitment
         * @property {Uint8Array|null} [ephemeralKey] TransactionOutput ephemeralKey
         * @property {Uint8Array|null} [stealthPayload] TransactionOutput stealthPayload
         * @property {Uint8Array|null} [viewTag] TransactionOutput viewTag
         */

        /**
         * Constructs a new TransactionOutput.
         * @memberof p2p
         * @classdesc Represents a TransactionOutput.
         * @implements ITransactionOutput
         * @constructor
         * @param {p2p.ITransactionOutput=} [properties] Properties to set
         */
        function TransactionOutput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionOutput commitment.
         * @member {Uint8Array} commitment
         * @memberof p2p.TransactionOutput
         * @instance
         */
        TransactionOutput.prototype.commitment = $util.newBuffer([]);

        /**
         * TransactionOutput ephemeralKey.
         * @member {Uint8Array|null|undefined} ephemeralKey
         * @memberof p2p.TransactionOutput
         * @instance
         */
        TransactionOutput.prototype.ephemeralKey = null;

        /**
         * TransactionOutput stealthPayload.
         * @member {Uint8Array|null|undefined} stealthPayload
         * @memberof p2p.TransactionOutput
         * @instance
         */
        TransactionOutput.prototype.stealthPayload = null;

        /**
         * TransactionOutput viewTag.
         * @member {Uint8Array|null|undefined} viewTag
         * @memberof p2p.TransactionOutput
         * @instance
         */
        TransactionOutput.prototype.viewTag = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TransactionOutput _ephemeralKey.
         * @member {"ephemeralKey"|undefined} _ephemeralKey
         * @memberof p2p.TransactionOutput
         * @instance
         */
        Object.defineProperty(TransactionOutput.prototype, "_ephemeralKey", {
            get: $util.oneOfGetter($oneOfFields = ["ephemeralKey"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * TransactionOutput _stealthPayload.
         * @member {"stealthPayload"|undefined} _stealthPayload
         * @memberof p2p.TransactionOutput
         * @instance
         */
        Object.defineProperty(TransactionOutput.prototype, "_stealthPayload", {
            get: $util.oneOfGetter($oneOfFields = ["stealthPayload"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * TransactionOutput _viewTag.
         * @member {"viewTag"|undefined} _viewTag
         * @memberof p2p.TransactionOutput
         * @instance
         */
        Object.defineProperty(TransactionOutput.prototype, "_viewTag", {
            get: $util.oneOfGetter($oneOfFields = ["viewTag"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionOutput instance using the specified properties.
         * @function create
         * @memberof p2p.TransactionOutput
         * @static
         * @param {p2p.ITransactionOutput=} [properties] Properties to set
         * @returns {p2p.TransactionOutput} TransactionOutput instance
         */
        TransactionOutput.create = function create(properties) {
            return new TransactionOutput(properties);
        };

        /**
         * Encodes the specified TransactionOutput message. Does not implicitly {@link p2p.TransactionOutput.verify|verify} messages.
         * @function encode
         * @memberof p2p.TransactionOutput
         * @static
         * @param {p2p.ITransactionOutput} message TransactionOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionOutput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.commitment);
            if (message.ephemeralKey != null && Object.hasOwnProperty.call(message, "ephemeralKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ephemeralKey);
            if (message.stealthPayload != null && Object.hasOwnProperty.call(message, "stealthPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stealthPayload);
            if (message.viewTag != null && Object.hasOwnProperty.call(message, "viewTag"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.viewTag);
            return writer;
        };

        /**
         * Encodes the specified TransactionOutput message, length delimited. Does not implicitly {@link p2p.TransactionOutput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.TransactionOutput
         * @static
         * @param {p2p.ITransactionOutput} message TransactionOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionOutput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionOutput message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.TransactionOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.TransactionOutput} TransactionOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionOutput.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.TransactionOutput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commitment = reader.bytes();
                        break;
                    }
                case 3: {
                        message.ephemeralKey = reader.bytes();
                        break;
                    }
                case 4: {
                        message.stealthPayload = reader.bytes();
                        break;
                    }
                case 5: {
                        message.viewTag = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionOutput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.TransactionOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.TransactionOutput} TransactionOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionOutput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionOutput message.
         * @function verify
         * @memberof p2p.TransactionOutput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionOutput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.commitment != null && message.hasOwnProperty("commitment"))
                if (!(message.commitment && typeof message.commitment.length === "number" || $util.isString(message.commitment)))
                    return "commitment: buffer expected";
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey")) {
                properties._ephemeralKey = 1;
                if (!(message.ephemeralKey && typeof message.ephemeralKey.length === "number" || $util.isString(message.ephemeralKey)))
                    return "ephemeralKey: buffer expected";
            }
            if (message.stealthPayload != null && message.hasOwnProperty("stealthPayload")) {
                properties._stealthPayload = 1;
                if (!(message.stealthPayload && typeof message.stealthPayload.length === "number" || $util.isString(message.stealthPayload)))
                    return "stealthPayload: buffer expected";
            }
            if (message.viewTag != null && message.hasOwnProperty("viewTag")) {
                properties._viewTag = 1;
                if (!(message.viewTag && typeof message.viewTag.length === "number" || $util.isString(message.viewTag)))
                    return "viewTag: buffer expected";
            }
            return null;
        };

        /**
         * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.TransactionOutput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.TransactionOutput} TransactionOutput
         */
        TransactionOutput.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.TransactionOutput)
                return object;
            var message = new $root.p2p.TransactionOutput();
            if (object.commitment != null)
                if (typeof object.commitment === "string")
                    $util.base64.decode(object.commitment, message.commitment = $util.newBuffer($util.base64.length(object.commitment)), 0);
                else if (object.commitment.length >= 0)
                    message.commitment = object.commitment;
            if (object.ephemeralKey != null)
                if (typeof object.ephemeralKey === "string")
                    $util.base64.decode(object.ephemeralKey, message.ephemeralKey = $util.newBuffer($util.base64.length(object.ephemeralKey)), 0);
                else if (object.ephemeralKey.length >= 0)
                    message.ephemeralKey = object.ephemeralKey;
            if (object.stealthPayload != null)
                if (typeof object.stealthPayload === "string")
                    $util.base64.decode(object.stealthPayload, message.stealthPayload = $util.newBuffer($util.base64.length(object.stealthPayload)), 0);
                else if (object.stealthPayload.length >= 0)
                    message.stealthPayload = object.stealthPayload;
            if (object.viewTag != null)
                if (typeof object.viewTag === "string")
                    $util.base64.decode(object.viewTag, message.viewTag = $util.newBuffer($util.base64.length(object.viewTag)), 0);
                else if (object.viewTag.length >= 0)
                    message.viewTag = object.viewTag;
            return message;
        };

        /**
         * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.TransactionOutput
         * @static
         * @param {p2p.TransactionOutput} message TransactionOutput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionOutput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.commitment = "";
                else {
                    object.commitment = [];
                    if (options.bytes !== Array)
                        object.commitment = $util.newBuffer(object.commitment);
                }
            if (message.commitment != null && message.hasOwnProperty("commitment"))
                object.commitment = options.bytes === String ? $util.base64.encode(message.commitment, 0, message.commitment.length) : options.bytes === Array ? Array.prototype.slice.call(message.commitment) : message.commitment;
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey")) {
                object.ephemeralKey = options.bytes === String ? $util.base64.encode(message.ephemeralKey, 0, message.ephemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralKey) : message.ephemeralKey;
                if (options.oneofs)
                    object._ephemeralKey = "ephemeralKey";
            }
            if (message.stealthPayload != null && message.hasOwnProperty("stealthPayload")) {
                object.stealthPayload = options.bytes === String ? $util.base64.encode(message.stealthPayload, 0, message.stealthPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.stealthPayload) : message.stealthPayload;
                if (options.oneofs)
                    object._stealthPayload = "stealthPayload";
            }
            if (message.viewTag != null && message.hasOwnProperty("viewTag")) {
                object.viewTag = options.bytes === String ? $util.base64.encode(message.viewTag, 0, message.viewTag.length) : options.bytes === Array ? Array.prototype.slice.call(message.viewTag) : message.viewTag;
                if (options.oneofs)
                    object._viewTag = "viewTag";
            }
            return object;
        };

        /**
         * Converts this TransactionOutput to JSON.
         * @function toJSON
         * @memberof p2p.TransactionOutput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionOutput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransactionOutput
         * @function getTypeUrl
         * @memberof p2p.TransactionOutput
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionOutput.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.TransactionOutput";
        };

        return TransactionOutput;
    })();

    p2p.TransactionKernel = (function() {

        /**
         * Properties of a TransactionKernel.
         * @memberof p2p
         * @interface ITransactionKernel
         * @property {Uint8Array|null} [excess] TransactionKernel excess
         * @property {Uint8Array|null} [signature] TransactionKernel signature
         * @property {number|Long|null} [fee] TransactionKernel fee
         * @property {number|Long|null} [minHeight] TransactionKernel minHeight
         * @property {number|Long|null} [timestamp] TransactionKernel timestamp
         */

        /**
         * Constructs a new TransactionKernel.
         * @memberof p2p
         * @classdesc Represents a TransactionKernel.
         * @implements ITransactionKernel
         * @constructor
         * @param {p2p.ITransactionKernel=} [properties] Properties to set
         */
        function TransactionKernel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionKernel excess.
         * @member {Uint8Array} excess
         * @memberof p2p.TransactionKernel
         * @instance
         */
        TransactionKernel.prototype.excess = $util.newBuffer([]);

        /**
         * TransactionKernel signature.
         * @member {Uint8Array} signature
         * @memberof p2p.TransactionKernel
         * @instance
         */
        TransactionKernel.prototype.signature = $util.newBuffer([]);

        /**
         * TransactionKernel fee.
         * @member {number|Long} fee
         * @memberof p2p.TransactionKernel
         * @instance
         */
        TransactionKernel.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionKernel minHeight.
         * @member {number|Long} minHeight
         * @memberof p2p.TransactionKernel
         * @instance
         */
        TransactionKernel.prototype.minHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionKernel timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.TransactionKernel
         * @instance
         */
        TransactionKernel.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionKernel instance using the specified properties.
         * @function create
         * @memberof p2p.TransactionKernel
         * @static
         * @param {p2p.ITransactionKernel=} [properties] Properties to set
         * @returns {p2p.TransactionKernel} TransactionKernel instance
         */
        TransactionKernel.create = function create(properties) {
            return new TransactionKernel(properties);
        };

        /**
         * Encodes the specified TransactionKernel message. Does not implicitly {@link p2p.TransactionKernel.verify|verify} messages.
         * @function encode
         * @memberof p2p.TransactionKernel
         * @static
         * @param {p2p.ITransactionKernel} message TransactionKernel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionKernel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.excess != null && Object.hasOwnProperty.call(message, "excess"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.excess);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
            if (message.minHeight != null && Object.hasOwnProperty.call(message, "minHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.minHeight);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified TransactionKernel message, length delimited. Does not implicitly {@link p2p.TransactionKernel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.TransactionKernel
         * @static
         * @param {p2p.ITransactionKernel} message TransactionKernel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionKernel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionKernel message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.TransactionKernel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.TransactionKernel} TransactionKernel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionKernel.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.TransactionKernel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.excess = reader.bytes();
                        break;
                    }
                case 2: {
                        message.signature = reader.bytes();
                        break;
                    }
                case 3: {
                        message.fee = reader.uint64();
                        break;
                    }
                case 4: {
                        message.minHeight = reader.uint64();
                        break;
                    }
                case 5: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionKernel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.TransactionKernel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.TransactionKernel} TransactionKernel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionKernel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionKernel message.
         * @function verify
         * @memberof p2p.TransactionKernel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionKernel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.excess != null && message.hasOwnProperty("excess"))
                if (!(message.excess && typeof message.excess.length === "number" || $util.isString(message.excess)))
                    return "excess: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.minHeight != null && message.hasOwnProperty("minHeight"))
                if (!$util.isInteger(message.minHeight) && !(message.minHeight && $util.isInteger(message.minHeight.low) && $util.isInteger(message.minHeight.high)))
                    return "minHeight: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransactionKernel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.TransactionKernel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.TransactionKernel} TransactionKernel
         */
        TransactionKernel.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.TransactionKernel)
                return object;
            var message = new $root.p2p.TransactionKernel();
            if (object.excess != null)
                if (typeof object.excess === "string")
                    $util.base64.decode(object.excess, message.excess = $util.newBuffer($util.base64.length(object.excess)), 0);
                else if (object.excess.length >= 0)
                    message.excess = object.excess;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
            if (object.minHeight != null)
                if ($util.Long)
                    (message.minHeight = $util.Long.fromValue(object.minHeight)).unsigned = true;
                else if (typeof object.minHeight === "string")
                    message.minHeight = parseInt(object.minHeight, 10);
                else if (typeof object.minHeight === "number")
                    message.minHeight = object.minHeight;
                else if (typeof object.minHeight === "object")
                    message.minHeight = new $util.LongBits(object.minHeight.low >>> 0, object.minHeight.high >>> 0).toNumber(true);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a TransactionKernel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.TransactionKernel
         * @static
         * @param {p2p.TransactionKernel} message TransactionKernel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionKernel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.excess = "";
                else {
                    object.excess = [];
                    if (options.bytes !== Array)
                        object.excess = $util.newBuffer(object.excess);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.minHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.excess != null && message.hasOwnProperty("excess"))
                object.excess = options.bytes === String ? $util.base64.encode(message.excess, 0, message.excess.length) : options.bytes === Array ? Array.prototype.slice.call(message.excess) : message.excess;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
            if (message.minHeight != null && message.hasOwnProperty("minHeight"))
                if (typeof message.minHeight === "number")
                    object.minHeight = options.longs === String ? String(message.minHeight) : message.minHeight;
                else
                    object.minHeight = options.longs === String ? $util.Long.prototype.toString.call(message.minHeight) : options.longs === Number ? new $util.LongBits(message.minHeight.low >>> 0, message.minHeight.high >>> 0).toNumber(true) : message.minHeight;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this TransactionKernel to JSON.
         * @function toJSON
         * @memberof p2p.TransactionKernel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionKernel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransactionKernel
         * @function getTypeUrl
         * @memberof p2p.TransactionKernel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransactionKernel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.TransactionKernel";
        };

        return TransactionKernel;
    })();

    p2p.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof p2p
         * @interface ITransaction
         * @property {Array.<p2p.ITransactionInput>|null} [inputs] Transaction inputs
         * @property {Array.<p2p.ITransactionOutput>|null} [outputs] Transaction outputs
         * @property {Array.<p2p.ITransactionKernel>|null} [kernels] Transaction kernels
         * @property {number|Long|null} [timestamp] Transaction timestamp
         * @property {Uint8Array|null} [aggregatedRangeProof] Transaction aggregatedRangeProof
         */

        /**
         * Constructs a new Transaction.
         * @memberof p2p
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {p2p.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.inputs = [];
            this.outputs = [];
            this.kernels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction inputs.
         * @member {Array.<p2p.ITransactionInput>} inputs
         * @memberof p2p.Transaction
         * @instance
         */
        Transaction.prototype.inputs = $util.emptyArray;

        /**
         * Transaction outputs.
         * @member {Array.<p2p.ITransactionOutput>} outputs
         * @memberof p2p.Transaction
         * @instance
         */
        Transaction.prototype.outputs = $util.emptyArray;

        /**
         * Transaction kernels.
         * @member {Array.<p2p.ITransactionKernel>} kernels
         * @memberof p2p.Transaction
         * @instance
         */
        Transaction.prototype.kernels = $util.emptyArray;

        /**
         * Transaction timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.Transaction
         * @instance
         */
        Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Transaction aggregatedRangeProof.
         * @member {Uint8Array} aggregatedRangeProof
         * @memberof p2p.Transaction
         * @instance
         */
        Transaction.prototype.aggregatedRangeProof = $util.newBuffer([]);

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof p2p.Transaction
         * @static
         * @param {p2p.ITransaction=} [properties] Properties to set
         * @returns {p2p.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link p2p.Transaction.verify|verify} messages.
         * @function encode
         * @memberof p2p.Transaction
         * @static
         * @param {p2p.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inputs != null && message.inputs.length)
                for (var i = 0; i < message.inputs.length; ++i)
                    $root.p2p.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.outputs != null && message.outputs.length)
                for (var i = 0; i < message.outputs.length; ++i)
                    $root.p2p.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.kernels != null && message.kernels.length)
                for (var i = 0; i < message.kernels.length; ++i)
                    $root.p2p.TransactionKernel.encode(message.kernels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestamp);
            if (message.aggregatedRangeProof != null && Object.hasOwnProperty.call(message, "aggregatedRangeProof"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.aggregatedRangeProof);
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link p2p.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.Transaction
         * @static
         * @param {p2p.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.inputs && message.inputs.length))
                            message.inputs = [];
                        message.inputs.push($root.p2p.TransactionInput.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.outputs && message.outputs.length))
                            message.outputs = [];
                        message.outputs.push($root.p2p.TransactionOutput.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.kernels && message.kernels.length))
                            message.kernels = [];
                        message.kernels.push($root.p2p.TransactionKernel.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                case 5: {
                        message.aggregatedRangeProof = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof p2p.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!Array.isArray(message.inputs))
                    return "inputs: array expected";
                for (var i = 0; i < message.inputs.length; ++i) {
                    var error = $root.p2p.TransactionInput.verify(message.inputs[i]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.outputs != null && message.hasOwnProperty("outputs")) {
                if (!Array.isArray(message.outputs))
                    return "outputs: array expected";
                for (var i = 0; i < message.outputs.length; ++i) {
                    var error = $root.p2p.TransactionOutput.verify(message.outputs[i]);
                    if (error)
                        return "outputs." + error;
                }
            }
            if (message.kernels != null && message.hasOwnProperty("kernels")) {
                if (!Array.isArray(message.kernels))
                    return "kernels: array expected";
                for (var i = 0; i < message.kernels.length; ++i) {
                    var error = $root.p2p.TransactionKernel.verify(message.kernels[i]);
                    if (error)
                        return "kernels." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.aggregatedRangeProof != null && message.hasOwnProperty("aggregatedRangeProof"))
                if (!(message.aggregatedRangeProof && typeof message.aggregatedRangeProof.length === "number" || $util.isString(message.aggregatedRangeProof)))
                    return "aggregatedRangeProof: buffer expected";
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.Transaction)
                return object;
            var message = new $root.p2p.Transaction();
            if (object.inputs) {
                if (!Array.isArray(object.inputs))
                    throw TypeError(".p2p.Transaction.inputs: array expected");
                message.inputs = [];
                for (var i = 0; i < object.inputs.length; ++i) {
                    if (typeof object.inputs[i] !== "object")
                        throw TypeError(".p2p.Transaction.inputs: object expected");
                    message.inputs[i] = $root.p2p.TransactionInput.fromObject(object.inputs[i]);
                }
            }
            if (object.outputs) {
                if (!Array.isArray(object.outputs))
                    throw TypeError(".p2p.Transaction.outputs: array expected");
                message.outputs = [];
                for (var i = 0; i < object.outputs.length; ++i) {
                    if (typeof object.outputs[i] !== "object")
                        throw TypeError(".p2p.Transaction.outputs: object expected");
                    message.outputs[i] = $root.p2p.TransactionOutput.fromObject(object.outputs[i]);
                }
            }
            if (object.kernels) {
                if (!Array.isArray(object.kernels))
                    throw TypeError(".p2p.Transaction.kernels: array expected");
                message.kernels = [];
                for (var i = 0; i < object.kernels.length; ++i) {
                    if (typeof object.kernels[i] !== "object")
                        throw TypeError(".p2p.Transaction.kernels: object expected");
                    message.kernels[i] = $root.p2p.TransactionKernel.fromObject(object.kernels[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.aggregatedRangeProof != null)
                if (typeof object.aggregatedRangeProof === "string")
                    $util.base64.decode(object.aggregatedRangeProof, message.aggregatedRangeProof = $util.newBuffer($util.base64.length(object.aggregatedRangeProof)), 0);
                else if (object.aggregatedRangeProof.length >= 0)
                    message.aggregatedRangeProof = object.aggregatedRangeProof;
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.Transaction
         * @static
         * @param {p2p.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.inputs = [];
                object.outputs = [];
                object.kernels = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.aggregatedRangeProof = "";
                else {
                    object.aggregatedRangeProof = [];
                    if (options.bytes !== Array)
                        object.aggregatedRangeProof = $util.newBuffer(object.aggregatedRangeProof);
                }
            }
            if (message.inputs && message.inputs.length) {
                object.inputs = [];
                for (var j = 0; j < message.inputs.length; ++j)
                    object.inputs[j] = $root.p2p.TransactionInput.toObject(message.inputs[j], options);
            }
            if (message.outputs && message.outputs.length) {
                object.outputs = [];
                for (var j = 0; j < message.outputs.length; ++j)
                    object.outputs[j] = $root.p2p.TransactionOutput.toObject(message.outputs[j], options);
            }
            if (message.kernels && message.kernels.length) {
                object.kernels = [];
                for (var j = 0; j < message.kernels.length; ++j)
                    object.kernels[j] = $root.p2p.TransactionKernel.toObject(message.kernels[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.aggregatedRangeProof != null && message.hasOwnProperty("aggregatedRangeProof"))
                object.aggregatedRangeProof = options.bytes === String ? $util.base64.encode(message.aggregatedRangeProof, 0, message.aggregatedRangeProof.length) : options.bytes === Array ? Array.prototype.slice.call(message.aggregatedRangeProof) : message.aggregatedRangeProof;
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof p2p.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Transaction
         * @function getTypeUrl
         * @memberof p2p.Transaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.Transaction";
        };

        return Transaction;
    })();

    p2p.Block = (function() {

        /**
         * Properties of a Block.
         * @memberof p2p
         * @interface IBlock
         * @property {number|Long|null} [height] Block height
         * @property {string|null} [prevHash] Block prevHash
         * @property {number|Long|null} [timestamp] Block timestamp
         * @property {Array.<p2p.ITransaction>|null} [transactions] Block transactions
         * @property {number|Long|null} [lotteryNonce] Block lotteryNonce
         * @property {p2p.IVrfProof|null} [vrfProof] Block vrfProof
         * @property {p2p.IVdfProof|null} [vdfProof] Block vdfProof
         * @property {Uint8Array|null} [minerPubkey] Block minerPubkey
         * @property {Uint8Array|null} [vrfThreshold] Block vrfThreshold
         * @property {number|Long|null} [vdfIterations] Block vdfIterations
         * @property {Uint8Array|null} [txMerkleRoot] Block txMerkleRoot
         * @property {number|Long|null} [totalWork] Block totalWork
         * @property {string|null} [hash] Block hash
         */

        /**
         * Constructs a new Block.
         * @memberof p2p
         * @classdesc Represents a Block.
         * @implements IBlock
         * @constructor
         * @param {p2p.IBlock=} [properties] Properties to set
         */
        function Block(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Block height.
         * @member {number|Long} height
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Block prevHash.
         * @member {string} prevHash
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.prevHash = "";

        /**
         * Block timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Block transactions.
         * @member {Array.<p2p.ITransaction>} transactions
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.transactions = $util.emptyArray;

        /**
         * Block lotteryNonce.
         * @member {number|Long} lotteryNonce
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.lotteryNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Block vrfProof.
         * @member {p2p.IVrfProof|null|undefined} vrfProof
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.vrfProof = null;

        /**
         * Block vdfProof.
         * @member {p2p.IVdfProof|null|undefined} vdfProof
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.vdfProof = null;

        /**
         * Block minerPubkey.
         * @member {Uint8Array} minerPubkey
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.minerPubkey = $util.newBuffer([]);

        /**
         * Block vrfThreshold.
         * @member {Uint8Array} vrfThreshold
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.vrfThreshold = $util.newBuffer([]);

        /**
         * Block vdfIterations.
         * @member {number|Long} vdfIterations
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.vdfIterations = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Block txMerkleRoot.
         * @member {Uint8Array} txMerkleRoot
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.txMerkleRoot = $util.newBuffer([]);

        /**
         * Block totalWork.
         * @member {number|Long} totalWork
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.totalWork = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Block hash.
         * @member {string} hash
         * @memberof p2p.Block
         * @instance
         */
        Block.prototype.hash = "";

        /**
         * Creates a new Block instance using the specified properties.
         * @function create
         * @memberof p2p.Block
         * @static
         * @param {p2p.IBlock=} [properties] Properties to set
         * @returns {p2p.Block} Block instance
         */
        Block.create = function create(properties) {
            return new Block(properties);
        };

        /**
         * Encodes the specified Block message. Does not implicitly {@link p2p.Block.verify|verify} messages.
         * @function encode
         * @memberof p2p.Block
         * @static
         * @param {p2p.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.height);
            if (message.prevHash != null && Object.hasOwnProperty.call(message, "prevHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.prevHash);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.p2p.Transaction.encode(message.transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.lotteryNonce != null && Object.hasOwnProperty.call(message, "lotteryNonce"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.lotteryNonce);
            if (message.vrfProof != null && Object.hasOwnProperty.call(message, "vrfProof"))
                $root.p2p.VrfProof.encode(message.vrfProof, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.vdfProof != null && Object.hasOwnProperty.call(message, "vdfProof"))
                $root.p2p.VdfProof.encode(message.vdfProof, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.minerPubkey != null && Object.hasOwnProperty.call(message, "minerPubkey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.minerPubkey);
            if (message.vrfThreshold != null && Object.hasOwnProperty.call(message, "vrfThreshold"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.vrfThreshold);
            if (message.vdfIterations != null && Object.hasOwnProperty.call(message, "vdfIterations"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.vdfIterations);
            if (message.txMerkleRoot != null && Object.hasOwnProperty.call(message, "txMerkleRoot"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.txMerkleRoot);
            if (message.totalWork != null && Object.hasOwnProperty.call(message, "totalWork"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.totalWork);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.hash);
            return writer;
        };

        /**
         * Encodes the specified Block message, length delimited. Does not implicitly {@link p2p.Block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.Block
         * @static
         * @param {p2p.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Block message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.Block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.height = reader.uint64();
                        break;
                    }
                case 2: {
                        message.prevHash = reader.string();
                        break;
                    }
                case 3: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                case 4: {
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.p2p.Transaction.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.lotteryNonce = reader.uint64();
                        break;
                    }
                case 6: {
                        message.vrfProof = $root.p2p.VrfProof.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.vdfProof = $root.p2p.VdfProof.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.minerPubkey = reader.bytes();
                        break;
                    }
                case 9: {
                        message.vrfThreshold = reader.bytes();
                        break;
                    }
                case 10: {
                        message.vdfIterations = reader.uint64();
                        break;
                    }
                case 11: {
                        message.txMerkleRoot = reader.bytes();
                        break;
                    }
                case 12: {
                        message.totalWork = reader.uint64();
                        break;
                    }
                case 13: {
                        message.hash = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Block message.
         * @function verify
         * @memberof p2p.Block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                    return "height: integer|Long expected";
            if (message.prevHash != null && message.hasOwnProperty("prevHash"))
                if (!$util.isString(message.prevHash))
                    return "prevHash: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.p2p.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.lotteryNonce != null && message.hasOwnProperty("lotteryNonce"))
                if (!$util.isInteger(message.lotteryNonce) && !(message.lotteryNonce && $util.isInteger(message.lotteryNonce.low) && $util.isInteger(message.lotteryNonce.high)))
                    return "lotteryNonce: integer|Long expected";
            if (message.vrfProof != null && message.hasOwnProperty("vrfProof")) {
                var error = $root.p2p.VrfProof.verify(message.vrfProof);
                if (error)
                    return "vrfProof." + error;
            }
            if (message.vdfProof != null && message.hasOwnProperty("vdfProof")) {
                var error = $root.p2p.VdfProof.verify(message.vdfProof);
                if (error)
                    return "vdfProof." + error;
            }
            if (message.minerPubkey != null && message.hasOwnProperty("minerPubkey"))
                if (!(message.minerPubkey && typeof message.minerPubkey.length === "number" || $util.isString(message.minerPubkey)))
                    return "minerPubkey: buffer expected";
            if (message.vrfThreshold != null && message.hasOwnProperty("vrfThreshold"))
                if (!(message.vrfThreshold && typeof message.vrfThreshold.length === "number" || $util.isString(message.vrfThreshold)))
                    return "vrfThreshold: buffer expected";
            if (message.vdfIterations != null && message.hasOwnProperty("vdfIterations"))
                if (!$util.isInteger(message.vdfIterations) && !(message.vdfIterations && $util.isInteger(message.vdfIterations.low) && $util.isInteger(message.vdfIterations.high)))
                    return "vdfIterations: integer|Long expected";
            if (message.txMerkleRoot != null && message.hasOwnProperty("txMerkleRoot"))
                if (!(message.txMerkleRoot && typeof message.txMerkleRoot.length === "number" || $util.isString(message.txMerkleRoot)))
                    return "txMerkleRoot: buffer expected";
            if (message.totalWork != null && message.hasOwnProperty("totalWork"))
                if (!$util.isInteger(message.totalWork) && !(message.totalWork && $util.isInteger(message.totalWork.low) && $util.isInteger(message.totalWork.high)))
                    return "totalWork: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };

        /**
         * Creates a Block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.Block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.Block} Block
         */
        Block.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.Block)
                return object;
            var message = new $root.p2p.Block();
            if (object.height != null)
                if ($util.Long)
                    (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                else if (typeof object.height === "string")
                    message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number")
                    message.height = object.height;
                else if (typeof object.height === "object")
                    message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
            if (object.prevHash != null)
                message.prevHash = String(object.prevHash);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".p2p.Block.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".p2p.Block.transactions: object expected");
                    message.transactions[i] = $root.p2p.Transaction.fromObject(object.transactions[i]);
                }
            }
            if (object.lotteryNonce != null)
                if ($util.Long)
                    (message.lotteryNonce = $util.Long.fromValue(object.lotteryNonce)).unsigned = true;
                else if (typeof object.lotteryNonce === "string")
                    message.lotteryNonce = parseInt(object.lotteryNonce, 10);
                else if (typeof object.lotteryNonce === "number")
                    message.lotteryNonce = object.lotteryNonce;
                else if (typeof object.lotteryNonce === "object")
                    message.lotteryNonce = new $util.LongBits(object.lotteryNonce.low >>> 0, object.lotteryNonce.high >>> 0).toNumber(true);
            if (object.vrfProof != null) {
                if (typeof object.vrfProof !== "object")
                    throw TypeError(".p2p.Block.vrfProof: object expected");
                message.vrfProof = $root.p2p.VrfProof.fromObject(object.vrfProof);
            }
            if (object.vdfProof != null) {
                if (typeof object.vdfProof !== "object")
                    throw TypeError(".p2p.Block.vdfProof: object expected");
                message.vdfProof = $root.p2p.VdfProof.fromObject(object.vdfProof);
            }
            if (object.minerPubkey != null)
                if (typeof object.minerPubkey === "string")
                    $util.base64.decode(object.minerPubkey, message.minerPubkey = $util.newBuffer($util.base64.length(object.minerPubkey)), 0);
                else if (object.minerPubkey.length >= 0)
                    message.minerPubkey = object.minerPubkey;
            if (object.vrfThreshold != null)
                if (typeof object.vrfThreshold === "string")
                    $util.base64.decode(object.vrfThreshold, message.vrfThreshold = $util.newBuffer($util.base64.length(object.vrfThreshold)), 0);
                else if (object.vrfThreshold.length >= 0)
                    message.vrfThreshold = object.vrfThreshold;
            if (object.vdfIterations != null)
                if ($util.Long)
                    (message.vdfIterations = $util.Long.fromValue(object.vdfIterations)).unsigned = true;
                else if (typeof object.vdfIterations === "string")
                    message.vdfIterations = parseInt(object.vdfIterations, 10);
                else if (typeof object.vdfIterations === "number")
                    message.vdfIterations = object.vdfIterations;
                else if (typeof object.vdfIterations === "object")
                    message.vdfIterations = new $util.LongBits(object.vdfIterations.low >>> 0, object.vdfIterations.high >>> 0).toNumber(true);
            if (object.txMerkleRoot != null)
                if (typeof object.txMerkleRoot === "string")
                    $util.base64.decode(object.txMerkleRoot, message.txMerkleRoot = $util.newBuffer($util.base64.length(object.txMerkleRoot)), 0);
                else if (object.txMerkleRoot.length >= 0)
                    message.txMerkleRoot = object.txMerkleRoot;
            if (object.totalWork != null)
                if ($util.Long)
                    (message.totalWork = $util.Long.fromValue(object.totalWork)).unsigned = true;
                else if (typeof object.totalWork === "string")
                    message.totalWork = parseInt(object.totalWork, 10);
                else if (typeof object.totalWork === "number")
                    message.totalWork = object.totalWork;
                else if (typeof object.totalWork === "object")
                    message.totalWork = new $util.LongBits(object.totalWork.low >>> 0, object.totalWork.high >>> 0).toNumber(true);
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };

        /**
         * Creates a plain object from a Block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.Block
         * @static
         * @param {p2p.Block} message Block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.height = options.longs === String ? "0" : 0;
                object.prevHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.lotteryNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lotteryNonce = options.longs === String ? "0" : 0;
                object.vrfProof = null;
                object.vdfProof = null;
                if (options.bytes === String)
                    object.minerPubkey = "";
                else {
                    object.minerPubkey = [];
                    if (options.bytes !== Array)
                        object.minerPubkey = $util.newBuffer(object.minerPubkey);
                }
                if (options.bytes === String)
                    object.vrfThreshold = "";
                else {
                    object.vrfThreshold = [];
                    if (options.bytes !== Array)
                        object.vrfThreshold = $util.newBuffer(object.vrfThreshold);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.vdfIterations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vdfIterations = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.txMerkleRoot = "";
                else {
                    object.txMerkleRoot = [];
                    if (options.bytes !== Array)
                        object.txMerkleRoot = $util.newBuffer(object.txMerkleRoot);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalWork = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalWork = options.longs === String ? "0" : 0;
                object.hash = "";
            }
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                    object.height = options.longs === String ? String(message.height) : message.height;
                else
                    object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
            if (message.prevHash != null && message.hasOwnProperty("prevHash"))
                object.prevHash = message.prevHash;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.p2p.Transaction.toObject(message.transactions[j], options);
            }
            if (message.lotteryNonce != null && message.hasOwnProperty("lotteryNonce"))
                if (typeof message.lotteryNonce === "number")
                    object.lotteryNonce = options.longs === String ? String(message.lotteryNonce) : message.lotteryNonce;
                else
                    object.lotteryNonce = options.longs === String ? $util.Long.prototype.toString.call(message.lotteryNonce) : options.longs === Number ? new $util.LongBits(message.lotteryNonce.low >>> 0, message.lotteryNonce.high >>> 0).toNumber(true) : message.lotteryNonce;
            if (message.vrfProof != null && message.hasOwnProperty("vrfProof"))
                object.vrfProof = $root.p2p.VrfProof.toObject(message.vrfProof, options);
            if (message.vdfProof != null && message.hasOwnProperty("vdfProof"))
                object.vdfProof = $root.p2p.VdfProof.toObject(message.vdfProof, options);
            if (message.minerPubkey != null && message.hasOwnProperty("minerPubkey"))
                object.minerPubkey = options.bytes === String ? $util.base64.encode(message.minerPubkey, 0, message.minerPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.minerPubkey) : message.minerPubkey;
            if (message.vrfThreshold != null && message.hasOwnProperty("vrfThreshold"))
                object.vrfThreshold = options.bytes === String ? $util.base64.encode(message.vrfThreshold, 0, message.vrfThreshold.length) : options.bytes === Array ? Array.prototype.slice.call(message.vrfThreshold) : message.vrfThreshold;
            if (message.vdfIterations != null && message.hasOwnProperty("vdfIterations"))
                if (typeof message.vdfIterations === "number")
                    object.vdfIterations = options.longs === String ? String(message.vdfIterations) : message.vdfIterations;
                else
                    object.vdfIterations = options.longs === String ? $util.Long.prototype.toString.call(message.vdfIterations) : options.longs === Number ? new $util.LongBits(message.vdfIterations.low >>> 0, message.vdfIterations.high >>> 0).toNumber(true) : message.vdfIterations;
            if (message.txMerkleRoot != null && message.hasOwnProperty("txMerkleRoot"))
                object.txMerkleRoot = options.bytes === String ? $util.base64.encode(message.txMerkleRoot, 0, message.txMerkleRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txMerkleRoot) : message.txMerkleRoot;
            if (message.totalWork != null && message.hasOwnProperty("totalWork"))
                if (typeof message.totalWork === "number")
                    object.totalWork = options.longs === String ? String(message.totalWork) : message.totalWork;
                else
                    object.totalWork = options.longs === String ? $util.Long.prototype.toString.call(message.totalWork) : options.longs === Number ? new $util.LongBits(message.totalWork.low >>> 0, message.totalWork.high >>> 0).toNumber(true) : message.totalWork;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };

        /**
         * Converts this Block to JSON.
         * @function toJSON
         * @memberof p2p.Block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Block
         * @function getTypeUrl
         * @memberof p2p.Block
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Block.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.Block";
        };

        return Block;
    })();

    p2p.BlockAnnouncement = (function() {

        /**
         * Properties of a BlockAnnouncement.
         * @memberof p2p
         * @interface IBlockAnnouncement
         * @property {string|null} [hash] BlockAnnouncement hash
         * @property {number|Long|null} [height] BlockAnnouncement height
         */

        /**
         * Constructs a new BlockAnnouncement.
         * @memberof p2p
         * @classdesc Represents a BlockAnnouncement.
         * @implements IBlockAnnouncement
         * @constructor
         * @param {p2p.IBlockAnnouncement=} [properties] Properties to set
         */
        function BlockAnnouncement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockAnnouncement hash.
         * @member {string} hash
         * @memberof p2p.BlockAnnouncement
         * @instance
         */
        BlockAnnouncement.prototype.hash = "";

        /**
         * BlockAnnouncement height.
         * @member {number|Long} height
         * @memberof p2p.BlockAnnouncement
         * @instance
         */
        BlockAnnouncement.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new BlockAnnouncement instance using the specified properties.
         * @function create
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {p2p.IBlockAnnouncement=} [properties] Properties to set
         * @returns {p2p.BlockAnnouncement} BlockAnnouncement instance
         */
        BlockAnnouncement.create = function create(properties) {
            return new BlockAnnouncement(properties);
        };

        /**
         * Encodes the specified BlockAnnouncement message. Does not implicitly {@link p2p.BlockAnnouncement.verify|verify} messages.
         * @function encode
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {p2p.IBlockAnnouncement} message BlockAnnouncement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockAnnouncement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
            return writer;
        };

        /**
         * Encodes the specified BlockAnnouncement message, length delimited. Does not implicitly {@link p2p.BlockAnnouncement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {p2p.IBlockAnnouncement} message BlockAnnouncement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockAnnouncement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockAnnouncement message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.BlockAnnouncement} BlockAnnouncement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockAnnouncement.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.BlockAnnouncement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.string();
                        break;
                    }
                case 2: {
                        message.height = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockAnnouncement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.BlockAnnouncement} BlockAnnouncement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockAnnouncement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockAnnouncement message.
         * @function verify
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockAnnouncement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                    return "height: integer|Long expected";
            return null;
        };

        /**
         * Creates a BlockAnnouncement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.BlockAnnouncement} BlockAnnouncement
         */
        BlockAnnouncement.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.BlockAnnouncement)
                return object;
            var message = new $root.p2p.BlockAnnouncement();
            if (object.hash != null)
                message.hash = String(object.hash);
            if (object.height != null)
                if ($util.Long)
                    (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                else if (typeof object.height === "string")
                    message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number")
                    message.height = object.height;
                else if (typeof object.height === "object")
                    message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a BlockAnnouncement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {p2p.BlockAnnouncement} message BlockAnnouncement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockAnnouncement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.height = options.longs === String ? "0" : 0;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                    object.height = options.longs === String ? String(message.height) : message.height;
                else
                    object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
            return object;
        };

        /**
         * Converts this BlockAnnouncement to JSON.
         * @function toJSON
         * @memberof p2p.BlockAnnouncement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockAnnouncement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BlockAnnouncement
         * @function getTypeUrl
         * @memberof p2p.BlockAnnouncement
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockAnnouncement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.BlockAnnouncement";
        };

        return BlockAnnouncement;
    })();

    p2p.BlockRequest = (function() {

        /**
         * Properties of a BlockRequest.
         * @memberof p2p
         * @interface IBlockRequest
         * @property {string|null} [hash] BlockRequest hash
         */

        /**
         * Constructs a new BlockRequest.
         * @memberof p2p
         * @classdesc Represents a BlockRequest.
         * @implements IBlockRequest
         * @constructor
         * @param {p2p.IBlockRequest=} [properties] Properties to set
         */
        function BlockRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockRequest hash.
         * @member {string} hash
         * @memberof p2p.BlockRequest
         * @instance
         */
        BlockRequest.prototype.hash = "";

        /**
         * Creates a new BlockRequest instance using the specified properties.
         * @function create
         * @memberof p2p.BlockRequest
         * @static
         * @param {p2p.IBlockRequest=} [properties] Properties to set
         * @returns {p2p.BlockRequest} BlockRequest instance
         */
        BlockRequest.create = function create(properties) {
            return new BlockRequest(properties);
        };

        /**
         * Encodes the specified BlockRequest message. Does not implicitly {@link p2p.BlockRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.BlockRequest
         * @static
         * @param {p2p.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            return writer;
        };

        /**
         * Encodes the specified BlockRequest message, length delimited. Does not implicitly {@link p2p.BlockRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.BlockRequest
         * @static
         * @param {p2p.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.BlockRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockRequest message.
         * @function verify
         * @memberof p2p.BlockRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };

        /**
         * Creates a BlockRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.BlockRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.BlockRequest} BlockRequest
         */
        BlockRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.BlockRequest)
                return object;
            var message = new $root.p2p.BlockRequest();
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };

        /**
         * Creates a plain object from a BlockRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.BlockRequest
         * @static
         * @param {p2p.BlockRequest} message BlockRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hash = "";
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };

        /**
         * Converts this BlockRequest to JSON.
         * @function toJSON
         * @memberof p2p.BlockRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BlockRequest
         * @function getTypeUrl
         * @memberof p2p.BlockRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.BlockRequest";
        };

        return BlockRequest;
    })();

    p2p.GetHashesRequest = (function() {

        /**
         * Properties of a GetHashesRequest.
         * @memberof p2p
         * @interface IGetHashesRequest
         * @property {number|Long|null} [startHeight] GetHashesRequest startHeight
         * @property {string|null} [requestId] GetHashesRequest requestId
         */

        /**
         * Constructs a new GetHashesRequest.
         * @memberof p2p
         * @classdesc Represents a GetHashesRequest.
         * @implements IGetHashesRequest
         * @constructor
         * @param {p2p.IGetHashesRequest=} [properties] Properties to set
         */
        function GetHashesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetHashesRequest startHeight.
         * @member {number|Long} startHeight
         * @memberof p2p.GetHashesRequest
         * @instance
         */
        GetHashesRequest.prototype.startHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetHashesRequest requestId.
         * @member {string} requestId
         * @memberof p2p.GetHashesRequest
         * @instance
         */
        GetHashesRequest.prototype.requestId = "";

        /**
         * Creates a new GetHashesRequest instance using the specified properties.
         * @function create
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {p2p.IGetHashesRequest=} [properties] Properties to set
         * @returns {p2p.GetHashesRequest} GetHashesRequest instance
         */
        GetHashesRequest.create = function create(properties) {
            return new GetHashesRequest(properties);
        };

        /**
         * Encodes the specified GetHashesRequest message. Does not implicitly {@link p2p.GetHashesRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {p2p.IGetHashesRequest} message GetHashesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHashesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startHeight);
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestId);
            return writer;
        };

        /**
         * Encodes the specified GetHashesRequest message, length delimited. Does not implicitly {@link p2p.GetHashesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {p2p.IGetHashesRequest} message GetHashesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHashesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetHashesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.GetHashesRequest} GetHashesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHashesRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.GetHashesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.startHeight = reader.uint64();
                        break;
                    }
                case 2: {
                        message.requestId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetHashesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.GetHashesRequest} GetHashesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHashesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetHashesRequest message.
         * @function verify
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetHashesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                if (!$util.isInteger(message.startHeight) && !(message.startHeight && $util.isInteger(message.startHeight.low) && $util.isInteger(message.startHeight.high)))
                    return "startHeight: integer|Long expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isString(message.requestId))
                    return "requestId: string expected";
            return null;
        };

        /**
         * Creates a GetHashesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.GetHashesRequest} GetHashesRequest
         */
        GetHashesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.GetHashesRequest)
                return object;
            var message = new $root.p2p.GetHashesRequest();
            if (object.startHeight != null)
                if ($util.Long)
                    (message.startHeight = $util.Long.fromValue(object.startHeight)).unsigned = true;
                else if (typeof object.startHeight === "string")
                    message.startHeight = parseInt(object.startHeight, 10);
                else if (typeof object.startHeight === "number")
                    message.startHeight = object.startHeight;
                else if (typeof object.startHeight === "object")
                    message.startHeight = new $util.LongBits(object.startHeight.low >>> 0, object.startHeight.high >>> 0).toNumber(true);
            if (object.requestId != null)
                message.requestId = String(object.requestId);
            return message;
        };

        /**
         * Creates a plain object from a GetHashesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {p2p.GetHashesRequest} message GetHashesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetHashesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.startHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startHeight = options.longs === String ? "0" : 0;
                object.requestId = "";
            }
            if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                if (typeof message.startHeight === "number")
                    object.startHeight = options.longs === String ? String(message.startHeight) : message.startHeight;
                else
                    object.startHeight = options.longs === String ? $util.Long.prototype.toString.call(message.startHeight) : options.longs === Number ? new $util.LongBits(message.startHeight.low >>> 0, message.startHeight.high >>> 0).toNumber(true) : message.startHeight;
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                object.requestId = message.requestId;
            return object;
        };

        /**
         * Converts this GetHashesRequest to JSON.
         * @function toJSON
         * @memberof p2p.GetHashesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetHashesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetHashesRequest
         * @function getTypeUrl
         * @memberof p2p.GetHashesRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetHashesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.GetHashesRequest";
        };

        return GetHashesRequest;
    })();

    p2p.HashesResponse = (function() {

        /**
         * Properties of a HashesResponse.
         * @memberof p2p
         * @interface IHashesResponse
         * @property {Array.<string>|null} [hashes] HashesResponse hashes
         * @property {string|null} [requestId] HashesResponse requestId
         * @property {boolean|null} [finalChunk] HashesResponse finalChunk
         */

        /**
         * Constructs a new HashesResponse.
         * @memberof p2p
         * @classdesc Represents a HashesResponse.
         * @implements IHashesResponse
         * @constructor
         * @param {p2p.IHashesResponse=} [properties] Properties to set
         */
        function HashesResponse(properties) {
            this.hashes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashesResponse hashes.
         * @member {Array.<string>} hashes
         * @memberof p2p.HashesResponse
         * @instance
         */
        HashesResponse.prototype.hashes = $util.emptyArray;

        /**
         * HashesResponse requestId.
         * @member {string} requestId
         * @memberof p2p.HashesResponse
         * @instance
         */
        HashesResponse.prototype.requestId = "";

        /**
         * HashesResponse finalChunk.
         * @member {boolean} finalChunk
         * @memberof p2p.HashesResponse
         * @instance
         */
        HashesResponse.prototype.finalChunk = false;

        /**
         * Creates a new HashesResponse instance using the specified properties.
         * @function create
         * @memberof p2p.HashesResponse
         * @static
         * @param {p2p.IHashesResponse=} [properties] Properties to set
         * @returns {p2p.HashesResponse} HashesResponse instance
         */
        HashesResponse.create = function create(properties) {
            return new HashesResponse(properties);
        };

        /**
         * Encodes the specified HashesResponse message. Does not implicitly {@link p2p.HashesResponse.verify|verify} messages.
         * @function encode
         * @memberof p2p.HashesResponse
         * @static
         * @param {p2p.IHashesResponse} message HashesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashes != null && message.hashes.length)
                for (var i = 0; i < message.hashes.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.hashes[i]);
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestId);
            if (message.finalChunk != null && Object.hasOwnProperty.call(message, "finalChunk"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.finalChunk);
            return writer;
        };

        /**
         * Encodes the specified HashesResponse message, length delimited. Does not implicitly {@link p2p.HashesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.HashesResponse
         * @static
         * @param {p2p.IHashesResponse} message HashesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.HashesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.HashesResponse} HashesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashesResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.HashesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.hashes && message.hashes.length))
                            message.hashes = [];
                        message.hashes.push(reader.string());
                        break;
                    }
                case 2: {
                        message.requestId = reader.string();
                        break;
                    }
                case 3: {
                        message.finalChunk = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.HashesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.HashesResponse} HashesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashesResponse message.
         * @function verify
         * @memberof p2p.HashesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashes != null && message.hasOwnProperty("hashes")) {
                if (!Array.isArray(message.hashes))
                    return "hashes: array expected";
                for (var i = 0; i < message.hashes.length; ++i)
                    if (!$util.isString(message.hashes[i]))
                        return "hashes: string[] expected";
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isString(message.requestId))
                    return "requestId: string expected";
            if (message.finalChunk != null && message.hasOwnProperty("finalChunk"))
                if (typeof message.finalChunk !== "boolean")
                    return "finalChunk: boolean expected";
            return null;
        };

        /**
         * Creates a HashesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.HashesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.HashesResponse} HashesResponse
         */
        HashesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.HashesResponse)
                return object;
            var message = new $root.p2p.HashesResponse();
            if (object.hashes) {
                if (!Array.isArray(object.hashes))
                    throw TypeError(".p2p.HashesResponse.hashes: array expected");
                message.hashes = [];
                for (var i = 0; i < object.hashes.length; ++i)
                    message.hashes[i] = String(object.hashes[i]);
            }
            if (object.requestId != null)
                message.requestId = String(object.requestId);
            if (object.finalChunk != null)
                message.finalChunk = Boolean(object.finalChunk);
            return message;
        };

        /**
         * Creates a plain object from a HashesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.HashesResponse
         * @static
         * @param {p2p.HashesResponse} message HashesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hashes = [];
            if (options.defaults) {
                object.requestId = "";
                object.finalChunk = false;
            }
            if (message.hashes && message.hashes.length) {
                object.hashes = [];
                for (var j = 0; j < message.hashes.length; ++j)
                    object.hashes[j] = message.hashes[j];
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                object.requestId = message.requestId;
            if (message.finalChunk != null && message.hasOwnProperty("finalChunk"))
                object.finalChunk = message.finalChunk;
            return object;
        };

        /**
         * Converts this HashesResponse to JSON.
         * @function toJSON
         * @memberof p2p.HashesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HashesResponse
         * @function getTypeUrl
         * @memberof p2p.HashesResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HashesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.HashesResponse";
        };

        return HashesResponse;
    })();

    p2p.TipRequest = (function() {

        /**
         * Properties of a TipRequest.
         * @memberof p2p
         * @interface ITipRequest
         */

        /**
         * Constructs a new TipRequest.
         * @memberof p2p
         * @classdesc Represents a TipRequest.
         * @implements ITipRequest
         * @constructor
         * @param {p2p.ITipRequest=} [properties] Properties to set
         */
        function TipRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TipRequest instance using the specified properties.
         * @function create
         * @memberof p2p.TipRequest
         * @static
         * @param {p2p.ITipRequest=} [properties] Properties to set
         * @returns {p2p.TipRequest} TipRequest instance
         */
        TipRequest.create = function create(properties) {
            return new TipRequest(properties);
        };

        /**
         * Encodes the specified TipRequest message. Does not implicitly {@link p2p.TipRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.TipRequest
         * @static
         * @param {p2p.ITipRequest} message TipRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TipRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TipRequest message, length delimited. Does not implicitly {@link p2p.TipRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.TipRequest
         * @static
         * @param {p2p.ITipRequest} message TipRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TipRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TipRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.TipRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.TipRequest} TipRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TipRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.TipRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TipRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.TipRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.TipRequest} TipRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TipRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TipRequest message.
         * @function verify
         * @memberof p2p.TipRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TipRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a TipRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.TipRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.TipRequest} TipRequest
         */
        TipRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.TipRequest)
                return object;
            return new $root.p2p.TipRequest();
        };

        /**
         * Creates a plain object from a TipRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.TipRequest
         * @static
         * @param {p2p.TipRequest} message TipRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TipRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TipRequest to JSON.
         * @function toJSON
         * @memberof p2p.TipRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TipRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TipRequest
         * @function getTypeUrl
         * @memberof p2p.TipRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TipRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.TipRequest";
        };

        return TipRequest;
    })();

    p2p.TipResponse = (function() {

        /**
         * Properties of a TipResponse.
         * @memberof p2p
         * @interface ITipResponse
         * @property {string|null} [tipHash] TipResponse tipHash
         * @property {number|Long|null} [height] TipResponse height
         * @property {string|null} [totalWork] TipResponse totalWork
         */

        /**
         * Constructs a new TipResponse.
         * @memberof p2p
         * @classdesc Represents a TipResponse.
         * @implements ITipResponse
         * @constructor
         * @param {p2p.ITipResponse=} [properties] Properties to set
         */
        function TipResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TipResponse tipHash.
         * @member {string} tipHash
         * @memberof p2p.TipResponse
         * @instance
         */
        TipResponse.prototype.tipHash = "";

        /**
         * TipResponse height.
         * @member {number|Long} height
         * @memberof p2p.TipResponse
         * @instance
         */
        TipResponse.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TipResponse totalWork.
         * @member {string} totalWork
         * @memberof p2p.TipResponse
         * @instance
         */
        TipResponse.prototype.totalWork = "";

        /**
         * Creates a new TipResponse instance using the specified properties.
         * @function create
         * @memberof p2p.TipResponse
         * @static
         * @param {p2p.ITipResponse=} [properties] Properties to set
         * @returns {p2p.TipResponse} TipResponse instance
         */
        TipResponse.create = function create(properties) {
            return new TipResponse(properties);
        };

        /**
         * Encodes the specified TipResponse message. Does not implicitly {@link p2p.TipResponse.verify|verify} messages.
         * @function encode
         * @memberof p2p.TipResponse
         * @static
         * @param {p2p.ITipResponse} message TipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TipResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tipHash != null && Object.hasOwnProperty.call(message, "tipHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tipHash);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
            if (message.totalWork != null && Object.hasOwnProperty.call(message, "totalWork"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.totalWork);
            return writer;
        };

        /**
         * Encodes the specified TipResponse message, length delimited. Does not implicitly {@link p2p.TipResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.TipResponse
         * @static
         * @param {p2p.ITipResponse} message TipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TipResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TipResponse message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.TipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.TipResponse} TipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TipResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.TipResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.tipHash = reader.string();
                        break;
                    }
                case 2: {
                        message.height = reader.uint64();
                        break;
                    }
                case 3: {
                        message.totalWork = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TipResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.TipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.TipResponse} TipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TipResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TipResponse message.
         * @function verify
         * @memberof p2p.TipResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TipResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tipHash != null && message.hasOwnProperty("tipHash"))
                if (!$util.isString(message.tipHash))
                    return "tipHash: string expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                    return "height: integer|Long expected";
            if (message.totalWork != null && message.hasOwnProperty("totalWork"))
                if (!$util.isString(message.totalWork))
                    return "totalWork: string expected";
            return null;
        };

        /**
         * Creates a TipResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.TipResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.TipResponse} TipResponse
         */
        TipResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.TipResponse)
                return object;
            var message = new $root.p2p.TipResponse();
            if (object.tipHash != null)
                message.tipHash = String(object.tipHash);
            if (object.height != null)
                if ($util.Long)
                    (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                else if (typeof object.height === "string")
                    message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number")
                    message.height = object.height;
                else if (typeof object.height === "object")
                    message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
            if (object.totalWork != null)
                message.totalWork = String(object.totalWork);
            return message;
        };

        /**
         * Creates a plain object from a TipResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.TipResponse
         * @static
         * @param {p2p.TipResponse} message TipResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TipResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tipHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.height = options.longs === String ? "0" : 0;
                object.totalWork = "";
            }
            if (message.tipHash != null && message.hasOwnProperty("tipHash"))
                object.tipHash = message.tipHash;
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                    object.height = options.longs === String ? String(message.height) : message.height;
                else
                    object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
            if (message.totalWork != null && message.hasOwnProperty("totalWork"))
                object.totalWork = message.totalWork;
            return object;
        };

        /**
         * Converts this TipResponse to JSON.
         * @function toJSON
         * @memberof p2p.TipResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TipResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TipResponse
         * @function getTypeUrl
         * @memberof p2p.TipResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TipResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.TipResponse";
        };

        return TipResponse;
    })();

    p2p.SyncMessage = (function() {

        /**
         * Properties of a SyncMessage.
         * @memberof p2p
         * @interface ISyncMessage
         * @property {p2p.ITipRequest|null} [tipRequest] SyncMessage tipRequest
         * @property {p2p.ITipResponse|null} [tipResponse] SyncMessage tipResponse
         */

        /**
         * Constructs a new SyncMessage.
         * @memberof p2p
         * @classdesc Represents a SyncMessage.
         * @implements ISyncMessage
         * @constructor
         * @param {p2p.ISyncMessage=} [properties] Properties to set
         */
        function SyncMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncMessage tipRequest.
         * @member {p2p.ITipRequest|null|undefined} tipRequest
         * @memberof p2p.SyncMessage
         * @instance
         */
        SyncMessage.prototype.tipRequest = null;

        /**
         * SyncMessage tipResponse.
         * @member {p2p.ITipResponse|null|undefined} tipResponse
         * @memberof p2p.SyncMessage
         * @instance
         */
        SyncMessage.prototype.tipResponse = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SyncMessage payload.
         * @member {"tipRequest"|"tipResponse"|undefined} payload
         * @memberof p2p.SyncMessage
         * @instance
         */
        Object.defineProperty(SyncMessage.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["tipRequest", "tipResponse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SyncMessage instance using the specified properties.
         * @function create
         * @memberof p2p.SyncMessage
         * @static
         * @param {p2p.ISyncMessage=} [properties] Properties to set
         * @returns {p2p.SyncMessage} SyncMessage instance
         */
        SyncMessage.create = function create(properties) {
            return new SyncMessage(properties);
        };

        /**
         * Encodes the specified SyncMessage message. Does not implicitly {@link p2p.SyncMessage.verify|verify} messages.
         * @function encode
         * @memberof p2p.SyncMessage
         * @static
         * @param {p2p.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tipRequest != null && Object.hasOwnProperty.call(message, "tipRequest"))
                $root.p2p.TipRequest.encode(message.tipRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tipResponse != null && Object.hasOwnProperty.call(message, "tipResponse"))
                $root.p2p.TipResponse.encode(message.tipResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncMessage message, length delimited. Does not implicitly {@link p2p.SyncMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SyncMessage
         * @static
         * @param {p2p.ISyncMessage} message SyncMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SyncMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.tipRequest = $root.p2p.TipRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.tipResponse = $root.p2p.TipResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SyncMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SyncMessage} SyncMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncMessage message.
         * @function verify
         * @memberof p2p.SyncMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.tipRequest != null && message.hasOwnProperty("tipRequest")) {
                properties.payload = 1;
                {
                    var error = $root.p2p.TipRequest.verify(message.tipRequest);
                    if (error)
                        return "tipRequest." + error;
                }
            }
            if (message.tipResponse != null && message.hasOwnProperty("tipResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.TipResponse.verify(message.tipResponse);
                    if (error)
                        return "tipResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SyncMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SyncMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SyncMessage} SyncMessage
         */
        SyncMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SyncMessage)
                return object;
            var message = new $root.p2p.SyncMessage();
            if (object.tipRequest != null) {
                if (typeof object.tipRequest !== "object")
                    throw TypeError(".p2p.SyncMessage.tipRequest: object expected");
                message.tipRequest = $root.p2p.TipRequest.fromObject(object.tipRequest);
            }
            if (object.tipResponse != null) {
                if (typeof object.tipResponse !== "object")
                    throw TypeError(".p2p.SyncMessage.tipResponse: object expected");
                message.tipResponse = $root.p2p.TipResponse.fromObject(object.tipResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SyncMessage
         * @static
         * @param {p2p.SyncMessage} message SyncMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.tipRequest != null && message.hasOwnProperty("tipRequest")) {
                object.tipRequest = $root.p2p.TipRequest.toObject(message.tipRequest, options);
                if (options.oneofs)
                    object.payload = "tipRequest";
            }
            if (message.tipResponse != null && message.hasOwnProperty("tipResponse")) {
                object.tipResponse = $root.p2p.TipResponse.toObject(message.tipResponse, options);
                if (options.oneofs)
                    object.payload = "tipResponse";
            }
            return object;
        };

        /**
         * Converts this SyncMessage to JSON.
         * @function toJSON
         * @memberof p2p.SyncMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncMessage
         * @function getTypeUrl
         * @memberof p2p.SyncMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SyncMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SyncMessage";
        };

        return SyncMessage;
    })();

    p2p.DandelionStem = (function() {

        /**
         * Properties of a DandelionStem.
         * @memberof p2p
         * @interface IDandelionStem
         * @property {p2p.ITransaction|null} [transaction] DandelionStem transaction
         * @property {number|null} [hopCount] DandelionStem hopCount
         * @property {number|Long|null} [timestamp] DandelionStem timestamp
         */

        /**
         * Constructs a new DandelionStem.
         * @memberof p2p
         * @classdesc Represents a DandelionStem.
         * @implements IDandelionStem
         * @constructor
         * @param {p2p.IDandelionStem=} [properties] Properties to set
         */
        function DandelionStem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DandelionStem transaction.
         * @member {p2p.ITransaction|null|undefined} transaction
         * @memberof p2p.DandelionStem
         * @instance
         */
        DandelionStem.prototype.transaction = null;

        /**
         * DandelionStem hopCount.
         * @member {number} hopCount
         * @memberof p2p.DandelionStem
         * @instance
         */
        DandelionStem.prototype.hopCount = 0;

        /**
         * DandelionStem timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.DandelionStem
         * @instance
         */
        DandelionStem.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DandelionStem instance using the specified properties.
         * @function create
         * @memberof p2p.DandelionStem
         * @static
         * @param {p2p.IDandelionStem=} [properties] Properties to set
         * @returns {p2p.DandelionStem} DandelionStem instance
         */
        DandelionStem.create = function create(properties) {
            return new DandelionStem(properties);
        };

        /**
         * Encodes the specified DandelionStem message. Does not implicitly {@link p2p.DandelionStem.verify|verify} messages.
         * @function encode
         * @memberof p2p.DandelionStem
         * @static
         * @param {p2p.IDandelionStem} message DandelionStem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DandelionStem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.p2p.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hopCount != null && Object.hasOwnProperty.call(message, "hopCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hopCount);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified DandelionStem message, length delimited. Does not implicitly {@link p2p.DandelionStem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.DandelionStem
         * @static
         * @param {p2p.IDandelionStem} message DandelionStem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DandelionStem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DandelionStem message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.DandelionStem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.DandelionStem} DandelionStem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DandelionStem.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.DandelionStem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.transaction = $root.p2p.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.hopCount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DandelionStem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.DandelionStem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.DandelionStem} DandelionStem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DandelionStem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DandelionStem message.
         * @function verify
         * @memberof p2p.DandelionStem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DandelionStem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.p2p.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.hopCount != null && message.hasOwnProperty("hopCount"))
                if (!$util.isInteger(message.hopCount))
                    return "hopCount: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a DandelionStem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.DandelionStem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.DandelionStem} DandelionStem
         */
        DandelionStem.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.DandelionStem)
                return object;
            var message = new $root.p2p.DandelionStem();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".p2p.DandelionStem.transaction: object expected");
                message.transaction = $root.p2p.Transaction.fromObject(object.transaction);
            }
            if (object.hopCount != null)
                message.hopCount = object.hopCount >>> 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DandelionStem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.DandelionStem
         * @static
         * @param {p2p.DandelionStem} message DandelionStem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DandelionStem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                object.hopCount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.p2p.Transaction.toObject(message.transaction, options);
            if (message.hopCount != null && message.hasOwnProperty("hopCount"))
                object.hopCount = message.hopCount;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this DandelionStem to JSON.
         * @function toJSON
         * @memberof p2p.DandelionStem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DandelionStem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DandelionStem
         * @function getTypeUrl
         * @memberof p2p.DandelionStem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DandelionStem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.DandelionStem";
        };

        return DandelionStem;
    })();

    p2p.ReorgMarker = (function() {

        /**
         * Properties of a ReorgMarker.
         * @memberof p2p
         * @interface IReorgMarker
         * @property {number|Long|null} [originalTipHeight] ReorgMarker originalTipHeight
         * @property {number|Long|null} [newTipHeight] ReorgMarker newTipHeight
         * @property {string|null} [newTipHash] ReorgMarker newTipHash
         * @property {Array.<string>|null} [blocksToAttach] ReorgMarker blocksToAttach
         * @property {Array.<number|Long>|null} [blocksToDetachHeights] ReorgMarker blocksToDetachHeights
         * @property {number|Long|null} [timestamp] ReorgMarker timestamp
         */

        /**
         * Constructs a new ReorgMarker.
         * @memberof p2p
         * @classdesc Represents a ReorgMarker.
         * @implements IReorgMarker
         * @constructor
         * @param {p2p.IReorgMarker=} [properties] Properties to set
         */
        function ReorgMarker(properties) {
            this.blocksToAttach = [];
            this.blocksToDetachHeights = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReorgMarker originalTipHeight.
         * @member {number|Long} originalTipHeight
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.originalTipHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReorgMarker newTipHeight.
         * @member {number|Long} newTipHeight
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.newTipHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReorgMarker newTipHash.
         * @member {string} newTipHash
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.newTipHash = "";

        /**
         * ReorgMarker blocksToAttach.
         * @member {Array.<string>} blocksToAttach
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.blocksToAttach = $util.emptyArray;

        /**
         * ReorgMarker blocksToDetachHeights.
         * @member {Array.<number|Long>} blocksToDetachHeights
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.blocksToDetachHeights = $util.emptyArray;

        /**
         * ReorgMarker timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.ReorgMarker
         * @instance
         */
        ReorgMarker.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ReorgMarker instance using the specified properties.
         * @function create
         * @memberof p2p.ReorgMarker
         * @static
         * @param {p2p.IReorgMarker=} [properties] Properties to set
         * @returns {p2p.ReorgMarker} ReorgMarker instance
         */
        ReorgMarker.create = function create(properties) {
            return new ReorgMarker(properties);
        };

        /**
         * Encodes the specified ReorgMarker message. Does not implicitly {@link p2p.ReorgMarker.verify|verify} messages.
         * @function encode
         * @memberof p2p.ReorgMarker
         * @static
         * @param {p2p.IReorgMarker} message ReorgMarker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReorgMarker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originalTipHeight != null && Object.hasOwnProperty.call(message, "originalTipHeight"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.originalTipHeight);
            if (message.newTipHeight != null && Object.hasOwnProperty.call(message, "newTipHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.newTipHeight);
            if (message.newTipHash != null && Object.hasOwnProperty.call(message, "newTipHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newTipHash);
            if (message.blocksToAttach != null && message.blocksToAttach.length)
                for (var i = 0; i < message.blocksToAttach.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.blocksToAttach[i]);
            if (message.blocksToDetachHeights != null && message.blocksToDetachHeights.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.blocksToDetachHeights.length; ++i)
                    writer.uint64(message.blocksToDetachHeights[i]);
                writer.ldelim();
            }
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified ReorgMarker message, length delimited. Does not implicitly {@link p2p.ReorgMarker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ReorgMarker
         * @static
         * @param {p2p.IReorgMarker} message ReorgMarker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReorgMarker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReorgMarker message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ReorgMarker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ReorgMarker} ReorgMarker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReorgMarker.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ReorgMarker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.originalTipHeight = reader.uint64();
                        break;
                    }
                case 2: {
                        message.newTipHeight = reader.uint64();
                        break;
                    }
                case 3: {
                        message.newTipHash = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.blocksToAttach && message.blocksToAttach.length))
                            message.blocksToAttach = [];
                        message.blocksToAttach.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.blocksToDetachHeights && message.blocksToDetachHeights.length))
                            message.blocksToDetachHeights = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.blocksToDetachHeights.push(reader.uint64());
                        } else
                            message.blocksToDetachHeights.push(reader.uint64());
                        break;
                    }
                case 6: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReorgMarker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ReorgMarker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ReorgMarker} ReorgMarker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReorgMarker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReorgMarker message.
         * @function verify
         * @memberof p2p.ReorgMarker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReorgMarker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originalTipHeight != null && message.hasOwnProperty("originalTipHeight"))
                if (!$util.isInteger(message.originalTipHeight) && !(message.originalTipHeight && $util.isInteger(message.originalTipHeight.low) && $util.isInteger(message.originalTipHeight.high)))
                    return "originalTipHeight: integer|Long expected";
            if (message.newTipHeight != null && message.hasOwnProperty("newTipHeight"))
                if (!$util.isInteger(message.newTipHeight) && !(message.newTipHeight && $util.isInteger(message.newTipHeight.low) && $util.isInteger(message.newTipHeight.high)))
                    return "newTipHeight: integer|Long expected";
            if (message.newTipHash != null && message.hasOwnProperty("newTipHash"))
                if (!$util.isString(message.newTipHash))
                    return "newTipHash: string expected";
            if (message.blocksToAttach != null && message.hasOwnProperty("blocksToAttach")) {
                if (!Array.isArray(message.blocksToAttach))
                    return "blocksToAttach: array expected";
                for (var i = 0; i < message.blocksToAttach.length; ++i)
                    if (!$util.isString(message.blocksToAttach[i]))
                        return "blocksToAttach: string[] expected";
            }
            if (message.blocksToDetachHeights != null && message.hasOwnProperty("blocksToDetachHeights")) {
                if (!Array.isArray(message.blocksToDetachHeights))
                    return "blocksToDetachHeights: array expected";
                for (var i = 0; i < message.blocksToDetachHeights.length; ++i)
                    if (!$util.isInteger(message.blocksToDetachHeights[i]) && !(message.blocksToDetachHeights[i] && $util.isInteger(message.blocksToDetachHeights[i].low) && $util.isInteger(message.blocksToDetachHeights[i].high)))
                        return "blocksToDetachHeights: integer|Long[] expected";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a ReorgMarker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ReorgMarker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ReorgMarker} ReorgMarker
         */
        ReorgMarker.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ReorgMarker)
                return object;
            var message = new $root.p2p.ReorgMarker();
            if (object.originalTipHeight != null)
                if ($util.Long)
                    (message.originalTipHeight = $util.Long.fromValue(object.originalTipHeight)).unsigned = true;
                else if (typeof object.originalTipHeight === "string")
                    message.originalTipHeight = parseInt(object.originalTipHeight, 10);
                else if (typeof object.originalTipHeight === "number")
                    message.originalTipHeight = object.originalTipHeight;
                else if (typeof object.originalTipHeight === "object")
                    message.originalTipHeight = new $util.LongBits(object.originalTipHeight.low >>> 0, object.originalTipHeight.high >>> 0).toNumber(true);
            if (object.newTipHeight != null)
                if ($util.Long)
                    (message.newTipHeight = $util.Long.fromValue(object.newTipHeight)).unsigned = true;
                else if (typeof object.newTipHeight === "string")
                    message.newTipHeight = parseInt(object.newTipHeight, 10);
                else if (typeof object.newTipHeight === "number")
                    message.newTipHeight = object.newTipHeight;
                else if (typeof object.newTipHeight === "object")
                    message.newTipHeight = new $util.LongBits(object.newTipHeight.low >>> 0, object.newTipHeight.high >>> 0).toNumber(true);
            if (object.newTipHash != null)
                message.newTipHash = String(object.newTipHash);
            if (object.blocksToAttach) {
                if (!Array.isArray(object.blocksToAttach))
                    throw TypeError(".p2p.ReorgMarker.blocksToAttach: array expected");
                message.blocksToAttach = [];
                for (var i = 0; i < object.blocksToAttach.length; ++i)
                    message.blocksToAttach[i] = String(object.blocksToAttach[i]);
            }
            if (object.blocksToDetachHeights) {
                if (!Array.isArray(object.blocksToDetachHeights))
                    throw TypeError(".p2p.ReorgMarker.blocksToDetachHeights: array expected");
                message.blocksToDetachHeights = [];
                for (var i = 0; i < object.blocksToDetachHeights.length; ++i)
                    if ($util.Long)
                        (message.blocksToDetachHeights[i] = $util.Long.fromValue(object.blocksToDetachHeights[i])).unsigned = true;
                    else if (typeof object.blocksToDetachHeights[i] === "string")
                        message.blocksToDetachHeights[i] = parseInt(object.blocksToDetachHeights[i], 10);
                    else if (typeof object.blocksToDetachHeights[i] === "number")
                        message.blocksToDetachHeights[i] = object.blocksToDetachHeights[i];
                    else if (typeof object.blocksToDetachHeights[i] === "object")
                        message.blocksToDetachHeights[i] = new $util.LongBits(object.blocksToDetachHeights[i].low >>> 0, object.blocksToDetachHeights[i].high >>> 0).toNumber(true);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ReorgMarker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ReorgMarker
         * @static
         * @param {p2p.ReorgMarker} message ReorgMarker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReorgMarker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.blocksToAttach = [];
                object.blocksToDetachHeights = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.originalTipHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.originalTipHeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.newTipHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newTipHeight = options.longs === String ? "0" : 0;
                object.newTipHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.originalTipHeight != null && message.hasOwnProperty("originalTipHeight"))
                if (typeof message.originalTipHeight === "number")
                    object.originalTipHeight = options.longs === String ? String(message.originalTipHeight) : message.originalTipHeight;
                else
                    object.originalTipHeight = options.longs === String ? $util.Long.prototype.toString.call(message.originalTipHeight) : options.longs === Number ? new $util.LongBits(message.originalTipHeight.low >>> 0, message.originalTipHeight.high >>> 0).toNumber(true) : message.originalTipHeight;
            if (message.newTipHeight != null && message.hasOwnProperty("newTipHeight"))
                if (typeof message.newTipHeight === "number")
                    object.newTipHeight = options.longs === String ? String(message.newTipHeight) : message.newTipHeight;
                else
                    object.newTipHeight = options.longs === String ? $util.Long.prototype.toString.call(message.newTipHeight) : options.longs === Number ? new $util.LongBits(message.newTipHeight.low >>> 0, message.newTipHeight.high >>> 0).toNumber(true) : message.newTipHeight;
            if (message.newTipHash != null && message.hasOwnProperty("newTipHash"))
                object.newTipHash = message.newTipHash;
            if (message.blocksToAttach && message.blocksToAttach.length) {
                object.blocksToAttach = [];
                for (var j = 0; j < message.blocksToAttach.length; ++j)
                    object.blocksToAttach[j] = message.blocksToAttach[j];
            }
            if (message.blocksToDetachHeights && message.blocksToDetachHeights.length) {
                object.blocksToDetachHeights = [];
                for (var j = 0; j < message.blocksToDetachHeights.length; ++j)
                    if (typeof message.blocksToDetachHeights[j] === "number")
                        object.blocksToDetachHeights[j] = options.longs === String ? String(message.blocksToDetachHeights[j]) : message.blocksToDetachHeights[j];
                    else
                        object.blocksToDetachHeights[j] = options.longs === String ? $util.Long.prototype.toString.call(message.blocksToDetachHeights[j]) : options.longs === Number ? new $util.LongBits(message.blocksToDetachHeights[j].low >>> 0, message.blocksToDetachHeights[j].high >>> 0).toNumber(true) : message.blocksToDetachHeights[j];
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this ReorgMarker to JSON.
         * @function toJSON
         * @memberof p2p.ReorgMarker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReorgMarker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReorgMarker
         * @function getTypeUrl
         * @memberof p2p.ReorgMarker
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReorgMarker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ReorgMarker";
        };

        return ReorgMarker;
    })();

    p2p.AdaptorSignature = (function() {

        /**
         * Properties of an AdaptorSignature.
         * @memberof p2p
         * @interface IAdaptorSignature
         * @property {Uint8Array|null} [publicNonce] AdaptorSignature publicNonce
         * @property {Uint8Array|null} [adaptorPoint] AdaptorSignature adaptorPoint
         * @property {Uint8Array|null} [preSignature] AdaptorSignature preSignature
         * @property {Uint8Array|null} [challenge] AdaptorSignature challenge
         */

        /**
         * Constructs a new AdaptorSignature.
         * @memberof p2p
         * @classdesc Represents an AdaptorSignature.
         * @implements IAdaptorSignature
         * @constructor
         * @param {p2p.IAdaptorSignature=} [properties] Properties to set
         */
        function AdaptorSignature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdaptorSignature publicNonce.
         * @member {Uint8Array} publicNonce
         * @memberof p2p.AdaptorSignature
         * @instance
         */
        AdaptorSignature.prototype.publicNonce = $util.newBuffer([]);

        /**
         * AdaptorSignature adaptorPoint.
         * @member {Uint8Array} adaptorPoint
         * @memberof p2p.AdaptorSignature
         * @instance
         */
        AdaptorSignature.prototype.adaptorPoint = $util.newBuffer([]);

        /**
         * AdaptorSignature preSignature.
         * @member {Uint8Array} preSignature
         * @memberof p2p.AdaptorSignature
         * @instance
         */
        AdaptorSignature.prototype.preSignature = $util.newBuffer([]);

        /**
         * AdaptorSignature challenge.
         * @member {Uint8Array} challenge
         * @memberof p2p.AdaptorSignature
         * @instance
         */
        AdaptorSignature.prototype.challenge = $util.newBuffer([]);

        /**
         * Creates a new AdaptorSignature instance using the specified properties.
         * @function create
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {p2p.IAdaptorSignature=} [properties] Properties to set
         * @returns {p2p.AdaptorSignature} AdaptorSignature instance
         */
        AdaptorSignature.create = function create(properties) {
            return new AdaptorSignature(properties);
        };

        /**
         * Encodes the specified AdaptorSignature message. Does not implicitly {@link p2p.AdaptorSignature.verify|verify} messages.
         * @function encode
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {p2p.IAdaptorSignature} message AdaptorSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdaptorSignature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicNonce != null && Object.hasOwnProperty.call(message, "publicNonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicNonce);
            if (message.adaptorPoint != null && Object.hasOwnProperty.call(message, "adaptorPoint"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.adaptorPoint);
            if (message.preSignature != null && Object.hasOwnProperty.call(message, "preSignature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preSignature);
            if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.challenge);
            return writer;
        };

        /**
         * Encodes the specified AdaptorSignature message, length delimited. Does not implicitly {@link p2p.AdaptorSignature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {p2p.IAdaptorSignature} message AdaptorSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdaptorSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdaptorSignature message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.AdaptorSignature} AdaptorSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdaptorSignature.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.AdaptorSignature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.publicNonce = reader.bytes();
                        break;
                    }
                case 2: {
                        message.adaptorPoint = reader.bytes();
                        break;
                    }
                case 3: {
                        message.preSignature = reader.bytes();
                        break;
                    }
                case 4: {
                        message.challenge = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdaptorSignature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.AdaptorSignature} AdaptorSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdaptorSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdaptorSignature message.
         * @function verify
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdaptorSignature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicNonce != null && message.hasOwnProperty("publicNonce"))
                if (!(message.publicNonce && typeof message.publicNonce.length === "number" || $util.isString(message.publicNonce)))
                    return "publicNonce: buffer expected";
            if (message.adaptorPoint != null && message.hasOwnProperty("adaptorPoint"))
                if (!(message.adaptorPoint && typeof message.adaptorPoint.length === "number" || $util.isString(message.adaptorPoint)))
                    return "adaptorPoint: buffer expected";
            if (message.preSignature != null && message.hasOwnProperty("preSignature"))
                if (!(message.preSignature && typeof message.preSignature.length === "number" || $util.isString(message.preSignature)))
                    return "preSignature: buffer expected";
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                if (!(message.challenge && typeof message.challenge.length === "number" || $util.isString(message.challenge)))
                    return "challenge: buffer expected";
            return null;
        };

        /**
         * Creates an AdaptorSignature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.AdaptorSignature} AdaptorSignature
         */
        AdaptorSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.AdaptorSignature)
                return object;
            var message = new $root.p2p.AdaptorSignature();
            if (object.publicNonce != null)
                if (typeof object.publicNonce === "string")
                    $util.base64.decode(object.publicNonce, message.publicNonce = $util.newBuffer($util.base64.length(object.publicNonce)), 0);
                else if (object.publicNonce.length >= 0)
                    message.publicNonce = object.publicNonce;
            if (object.adaptorPoint != null)
                if (typeof object.adaptorPoint === "string")
                    $util.base64.decode(object.adaptorPoint, message.adaptorPoint = $util.newBuffer($util.base64.length(object.adaptorPoint)), 0);
                else if (object.adaptorPoint.length >= 0)
                    message.adaptorPoint = object.adaptorPoint;
            if (object.preSignature != null)
                if (typeof object.preSignature === "string")
                    $util.base64.decode(object.preSignature, message.preSignature = $util.newBuffer($util.base64.length(object.preSignature)), 0);
                else if (object.preSignature.length >= 0)
                    message.preSignature = object.preSignature;
            if (object.challenge != null)
                if (typeof object.challenge === "string")
                    $util.base64.decode(object.challenge, message.challenge = $util.newBuffer($util.base64.length(object.challenge)), 0);
                else if (object.challenge.length >= 0)
                    message.challenge = object.challenge;
            return message;
        };

        /**
         * Creates a plain object from an AdaptorSignature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {p2p.AdaptorSignature} message AdaptorSignature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdaptorSignature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicNonce = "";
                else {
                    object.publicNonce = [];
                    if (options.bytes !== Array)
                        object.publicNonce = $util.newBuffer(object.publicNonce);
                }
                if (options.bytes === String)
                    object.adaptorPoint = "";
                else {
                    object.adaptorPoint = [];
                    if (options.bytes !== Array)
                        object.adaptorPoint = $util.newBuffer(object.adaptorPoint);
                }
                if (options.bytes === String)
                    object.preSignature = "";
                else {
                    object.preSignature = [];
                    if (options.bytes !== Array)
                        object.preSignature = $util.newBuffer(object.preSignature);
                }
                if (options.bytes === String)
                    object.challenge = "";
                else {
                    object.challenge = [];
                    if (options.bytes !== Array)
                        object.challenge = $util.newBuffer(object.challenge);
                }
            }
            if (message.publicNonce != null && message.hasOwnProperty("publicNonce"))
                object.publicNonce = options.bytes === String ? $util.base64.encode(message.publicNonce, 0, message.publicNonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicNonce) : message.publicNonce;
            if (message.adaptorPoint != null && message.hasOwnProperty("adaptorPoint"))
                object.adaptorPoint = options.bytes === String ? $util.base64.encode(message.adaptorPoint, 0, message.adaptorPoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.adaptorPoint) : message.adaptorPoint;
            if (message.preSignature != null && message.hasOwnProperty("preSignature"))
                object.preSignature = options.bytes === String ? $util.base64.encode(message.preSignature, 0, message.preSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.preSignature) : message.preSignature;
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                object.challenge = options.bytes === String ? $util.base64.encode(message.challenge, 0, message.challenge.length) : options.bytes === Array ? Array.prototype.slice.call(message.challenge) : message.challenge;
            return object;
        };

        /**
         * Converts this AdaptorSignature to JSON.
         * @function toJSON
         * @memberof p2p.AdaptorSignature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdaptorSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AdaptorSignature
         * @function getTypeUrl
         * @memberof p2p.AdaptorSignature
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AdaptorSignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.AdaptorSignature";
        };

        return AdaptorSignature;
    })();

    p2p.AtomicSwap = (function() {

        /**
         * Properties of an AtomicSwap.
         * @memberof p2p
         * @interface IAtomicSwap
         * @property {Uint8Array|null} [swapId] AtomicSwap swapId
         * @property {number|Long|null} [stateEnum] AtomicSwap stateEnum
         * @property {number|Long|null} [aliceAmount] AtomicSwap aliceAmount
         * @property {Uint8Array|null} [alicePubkey] AtomicSwap alicePubkey
         * @property {Uint8Array|null} [aliceCommitment] AtomicSwap aliceCommitment
         * @property {p2p.IAdaptorSignature|null} [aliceAdaptorSig] AtomicSwap aliceAdaptorSig
         * @property {number|Long|null} [aliceTimeoutHeight] AtomicSwap aliceTimeoutHeight
         * @property {number|Long|null} [bobAmount] AtomicSwap bobAmount
         * @property {Uint8Array|null} [bobPubkey] AtomicSwap bobPubkey
         * @property {string|null} [bobBtcAddress] AtomicSwap bobBtcAddress
         * @property {string|null} [bobBtcTxid] AtomicSwap bobBtcTxid
         * @property {number|null} [bobBtcVout] AtomicSwap bobBtcVout
         * @property {Uint8Array|null} [bobAdaptorSig] AtomicSwap bobAdaptorSig
         * @property {number|Long|null} [bobTimeoutHeight] AtomicSwap bobTimeoutHeight
         * @property {Uint8Array|null} [sharedAdaptorPoint] AtomicSwap sharedAdaptorPoint
         * @property {Uint8Array|null} [secretHash] AtomicSwap secretHash
         * @property {number|Long|null} [createdAt] AtomicSwap createdAt
         * @property {number|Long|null} [expiresAt] AtomicSwap expiresAt
         * @property {number|Long|null} [lastUpdated] AtomicSwap lastUpdated
         */

        /**
         * Constructs a new AtomicSwap.
         * @memberof p2p
         * @classdesc Represents an AtomicSwap.
         * @implements IAtomicSwap
         * @constructor
         * @param {p2p.IAtomicSwap=} [properties] Properties to set
         */
        function AtomicSwap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AtomicSwap swapId.
         * @member {Uint8Array} swapId
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.swapId = $util.newBuffer([]);

        /**
         * AtomicSwap stateEnum.
         * @member {number|Long} stateEnum
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.stateEnum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap aliceAmount.
         * @member {number|Long} aliceAmount
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.aliceAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap alicePubkey.
         * @member {Uint8Array} alicePubkey
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.alicePubkey = $util.newBuffer([]);

        /**
         * AtomicSwap aliceCommitment.
         * @member {Uint8Array} aliceCommitment
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.aliceCommitment = $util.newBuffer([]);

        /**
         * AtomicSwap aliceAdaptorSig.
         * @member {p2p.IAdaptorSignature|null|undefined} aliceAdaptorSig
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.aliceAdaptorSig = null;

        /**
         * AtomicSwap aliceTimeoutHeight.
         * @member {number|Long} aliceTimeoutHeight
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.aliceTimeoutHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap bobAmount.
         * @member {number|Long} bobAmount
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap bobPubkey.
         * @member {Uint8Array} bobPubkey
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobPubkey = $util.newBuffer([]);

        /**
         * AtomicSwap bobBtcAddress.
         * @member {string} bobBtcAddress
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobBtcAddress = "";

        /**
         * AtomicSwap bobBtcTxid.
         * @member {string} bobBtcTxid
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobBtcTxid = "";

        /**
         * AtomicSwap bobBtcVout.
         * @member {number} bobBtcVout
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobBtcVout = 0;

        /**
         * AtomicSwap bobAdaptorSig.
         * @member {Uint8Array} bobAdaptorSig
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobAdaptorSig = $util.newBuffer([]);

        /**
         * AtomicSwap bobTimeoutHeight.
         * @member {number|Long} bobTimeoutHeight
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.bobTimeoutHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap sharedAdaptorPoint.
         * @member {Uint8Array} sharedAdaptorPoint
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.sharedAdaptorPoint = $util.newBuffer([]);

        /**
         * AtomicSwap secretHash.
         * @member {Uint8Array} secretHash
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.secretHash = $util.newBuffer([]);

        /**
         * AtomicSwap createdAt.
         * @member {number|Long} createdAt
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap expiresAt.
         * @member {number|Long} expiresAt
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.expiresAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AtomicSwap lastUpdated.
         * @member {number|Long} lastUpdated
         * @memberof p2p.AtomicSwap
         * @instance
         */
        AtomicSwap.prototype.lastUpdated = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AtomicSwap _aliceAdaptorSig.
         * @member {"aliceAdaptorSig"|undefined} _aliceAdaptorSig
         * @memberof p2p.AtomicSwap
         * @instance
         */
        Object.defineProperty(AtomicSwap.prototype, "_aliceAdaptorSig", {
            get: $util.oneOfGetter($oneOfFields = ["aliceAdaptorSig"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AtomicSwap instance using the specified properties.
         * @function create
         * @memberof p2p.AtomicSwap
         * @static
         * @param {p2p.IAtomicSwap=} [properties] Properties to set
         * @returns {p2p.AtomicSwap} AtomicSwap instance
         */
        AtomicSwap.create = function create(properties) {
            return new AtomicSwap(properties);
        };

        /**
         * Encodes the specified AtomicSwap message. Does not implicitly {@link p2p.AtomicSwap.verify|verify} messages.
         * @function encode
         * @memberof p2p.AtomicSwap
         * @static
         * @param {p2p.IAtomicSwap} message AtomicSwap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicSwap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swapId);
            if (message.stateEnum != null && Object.hasOwnProperty.call(message, "stateEnum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.stateEnum);
            if (message.aliceAmount != null && Object.hasOwnProperty.call(message, "aliceAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.aliceAmount);
            if (message.alicePubkey != null && Object.hasOwnProperty.call(message, "alicePubkey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.alicePubkey);
            if (message.aliceCommitment != null && Object.hasOwnProperty.call(message, "aliceCommitment"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.aliceCommitment);
            if (message.aliceAdaptorSig != null && Object.hasOwnProperty.call(message, "aliceAdaptorSig"))
                $root.p2p.AdaptorSignature.encode(message.aliceAdaptorSig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.aliceTimeoutHeight != null && Object.hasOwnProperty.call(message, "aliceTimeoutHeight"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.aliceTimeoutHeight);
            if (message.bobAmount != null && Object.hasOwnProperty.call(message, "bobAmount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.bobAmount);
            if (message.bobPubkey != null && Object.hasOwnProperty.call(message, "bobPubkey"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.bobPubkey);
            if (message.bobBtcAddress != null && Object.hasOwnProperty.call(message, "bobBtcAddress"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.bobBtcAddress);
            if (message.bobBtcTxid != null && Object.hasOwnProperty.call(message, "bobBtcTxid"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.bobBtcTxid);
            if (message.bobBtcVout != null && Object.hasOwnProperty.call(message, "bobBtcVout"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.bobBtcVout);
            if (message.bobAdaptorSig != null && Object.hasOwnProperty.call(message, "bobAdaptorSig"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.bobAdaptorSig);
            if (message.bobTimeoutHeight != null && Object.hasOwnProperty.call(message, "bobTimeoutHeight"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.bobTimeoutHeight);
            if (message.sharedAdaptorPoint != null && Object.hasOwnProperty.call(message, "sharedAdaptorPoint"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.sharedAdaptorPoint);
            if (message.secretHash != null && Object.hasOwnProperty.call(message, "secretHash"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.secretHash);
            if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.createdAt);
            if (message.expiresAt != null && Object.hasOwnProperty.call(message, "expiresAt"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint64(message.expiresAt);
            if (message.lastUpdated != null && Object.hasOwnProperty.call(message, "lastUpdated"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint64(message.lastUpdated);
            return writer;
        };

        /**
         * Encodes the specified AtomicSwap message, length delimited. Does not implicitly {@link p2p.AtomicSwap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.AtomicSwap
         * @static
         * @param {p2p.IAtomicSwap} message AtomicSwap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicSwap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AtomicSwap message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.AtomicSwap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.AtomicSwap} AtomicSwap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicSwap.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.AtomicSwap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.swapId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.stateEnum = reader.uint64();
                        break;
                    }
                case 3: {
                        message.aliceAmount = reader.uint64();
                        break;
                    }
                case 4: {
                        message.alicePubkey = reader.bytes();
                        break;
                    }
                case 5: {
                        message.aliceCommitment = reader.bytes();
                        break;
                    }
                case 6: {
                        message.aliceAdaptorSig = $root.p2p.AdaptorSignature.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.aliceTimeoutHeight = reader.uint64();
                        break;
                    }
                case 8: {
                        message.bobAmount = reader.uint64();
                        break;
                    }
                case 9: {
                        message.bobPubkey = reader.bytes();
                        break;
                    }
                case 10: {
                        message.bobBtcAddress = reader.string();
                        break;
                    }
                case 11: {
                        message.bobBtcTxid = reader.string();
                        break;
                    }
                case 12: {
                        message.bobBtcVout = reader.uint32();
                        break;
                    }
                case 13: {
                        message.bobAdaptorSig = reader.bytes();
                        break;
                    }
                case 14: {
                        message.bobTimeoutHeight = reader.uint64();
                        break;
                    }
                case 15: {
                        message.sharedAdaptorPoint = reader.bytes();
                        break;
                    }
                case 16: {
                        message.secretHash = reader.bytes();
                        break;
                    }
                case 17: {
                        message.createdAt = reader.uint64();
                        break;
                    }
                case 18: {
                        message.expiresAt = reader.uint64();
                        break;
                    }
                case 19: {
                        message.lastUpdated = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AtomicSwap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.AtomicSwap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.AtomicSwap} AtomicSwap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicSwap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AtomicSwap message.
         * @function verify
         * @memberof p2p.AtomicSwap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AtomicSwap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            if (message.stateEnum != null && message.hasOwnProperty("stateEnum"))
                if (!$util.isInteger(message.stateEnum) && !(message.stateEnum && $util.isInteger(message.stateEnum.low) && $util.isInteger(message.stateEnum.high)))
                    return "stateEnum: integer|Long expected";
            if (message.aliceAmount != null && message.hasOwnProperty("aliceAmount"))
                if (!$util.isInteger(message.aliceAmount) && !(message.aliceAmount && $util.isInteger(message.aliceAmount.low) && $util.isInteger(message.aliceAmount.high)))
                    return "aliceAmount: integer|Long expected";
            if (message.alicePubkey != null && message.hasOwnProperty("alicePubkey"))
                if (!(message.alicePubkey && typeof message.alicePubkey.length === "number" || $util.isString(message.alicePubkey)))
                    return "alicePubkey: buffer expected";
            if (message.aliceCommitment != null && message.hasOwnProperty("aliceCommitment"))
                if (!(message.aliceCommitment && typeof message.aliceCommitment.length === "number" || $util.isString(message.aliceCommitment)))
                    return "aliceCommitment: buffer expected";
            if (message.aliceAdaptorSig != null && message.hasOwnProperty("aliceAdaptorSig")) {
                properties._aliceAdaptorSig = 1;
                {
                    var error = $root.p2p.AdaptorSignature.verify(message.aliceAdaptorSig);
                    if (error)
                        return "aliceAdaptorSig." + error;
                }
            }
            if (message.aliceTimeoutHeight != null && message.hasOwnProperty("aliceTimeoutHeight"))
                if (!$util.isInteger(message.aliceTimeoutHeight) && !(message.aliceTimeoutHeight && $util.isInteger(message.aliceTimeoutHeight.low) && $util.isInteger(message.aliceTimeoutHeight.high)))
                    return "aliceTimeoutHeight: integer|Long expected";
            if (message.bobAmount != null && message.hasOwnProperty("bobAmount"))
                if (!$util.isInteger(message.bobAmount) && !(message.bobAmount && $util.isInteger(message.bobAmount.low) && $util.isInteger(message.bobAmount.high)))
                    return "bobAmount: integer|Long expected";
            if (message.bobPubkey != null && message.hasOwnProperty("bobPubkey"))
                if (!(message.bobPubkey && typeof message.bobPubkey.length === "number" || $util.isString(message.bobPubkey)))
                    return "bobPubkey: buffer expected";
            if (message.bobBtcAddress != null && message.hasOwnProperty("bobBtcAddress"))
                if (!$util.isString(message.bobBtcAddress))
                    return "bobBtcAddress: string expected";
            if (message.bobBtcTxid != null && message.hasOwnProperty("bobBtcTxid"))
                if (!$util.isString(message.bobBtcTxid))
                    return "bobBtcTxid: string expected";
            if (message.bobBtcVout != null && message.hasOwnProperty("bobBtcVout"))
                if (!$util.isInteger(message.bobBtcVout))
                    return "bobBtcVout: integer expected";
            if (message.bobAdaptorSig != null && message.hasOwnProperty("bobAdaptorSig"))
                if (!(message.bobAdaptorSig && typeof message.bobAdaptorSig.length === "number" || $util.isString(message.bobAdaptorSig)))
                    return "bobAdaptorSig: buffer expected";
            if (message.bobTimeoutHeight != null && message.hasOwnProperty("bobTimeoutHeight"))
                if (!$util.isInteger(message.bobTimeoutHeight) && !(message.bobTimeoutHeight && $util.isInteger(message.bobTimeoutHeight.low) && $util.isInteger(message.bobTimeoutHeight.high)))
                    return "bobTimeoutHeight: integer|Long expected";
            if (message.sharedAdaptorPoint != null && message.hasOwnProperty("sharedAdaptorPoint"))
                if (!(message.sharedAdaptorPoint && typeof message.sharedAdaptorPoint.length === "number" || $util.isString(message.sharedAdaptorPoint)))
                    return "sharedAdaptorPoint: buffer expected";
            if (message.secretHash != null && message.hasOwnProperty("secretHash"))
                if (!(message.secretHash && typeof message.secretHash.length === "number" || $util.isString(message.secretHash)))
                    return "secretHash: buffer expected";
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                    return "createdAt: integer|Long expected";
            if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                if (!$util.isInteger(message.expiresAt) && !(message.expiresAt && $util.isInteger(message.expiresAt.low) && $util.isInteger(message.expiresAt.high)))
                    return "expiresAt: integer|Long expected";
            if (message.lastUpdated != null && message.hasOwnProperty("lastUpdated"))
                if (!$util.isInteger(message.lastUpdated) && !(message.lastUpdated && $util.isInteger(message.lastUpdated.low) && $util.isInteger(message.lastUpdated.high)))
                    return "lastUpdated: integer|Long expected";
            return null;
        };

        /**
         * Creates an AtomicSwap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.AtomicSwap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.AtomicSwap} AtomicSwap
         */
        AtomicSwap.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.AtomicSwap)
                return object;
            var message = new $root.p2p.AtomicSwap();
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length >= 0)
                    message.swapId = object.swapId;
            if (object.stateEnum != null)
                if ($util.Long)
                    (message.stateEnum = $util.Long.fromValue(object.stateEnum)).unsigned = true;
                else if (typeof object.stateEnum === "string")
                    message.stateEnum = parseInt(object.stateEnum, 10);
                else if (typeof object.stateEnum === "number")
                    message.stateEnum = object.stateEnum;
                else if (typeof object.stateEnum === "object")
                    message.stateEnum = new $util.LongBits(object.stateEnum.low >>> 0, object.stateEnum.high >>> 0).toNumber(true);
            if (object.aliceAmount != null)
                if ($util.Long)
                    (message.aliceAmount = $util.Long.fromValue(object.aliceAmount)).unsigned = true;
                else if (typeof object.aliceAmount === "string")
                    message.aliceAmount = parseInt(object.aliceAmount, 10);
                else if (typeof object.aliceAmount === "number")
                    message.aliceAmount = object.aliceAmount;
                else if (typeof object.aliceAmount === "object")
                    message.aliceAmount = new $util.LongBits(object.aliceAmount.low >>> 0, object.aliceAmount.high >>> 0).toNumber(true);
            if (object.alicePubkey != null)
                if (typeof object.alicePubkey === "string")
                    $util.base64.decode(object.alicePubkey, message.alicePubkey = $util.newBuffer($util.base64.length(object.alicePubkey)), 0);
                else if (object.alicePubkey.length >= 0)
                    message.alicePubkey = object.alicePubkey;
            if (object.aliceCommitment != null)
                if (typeof object.aliceCommitment === "string")
                    $util.base64.decode(object.aliceCommitment, message.aliceCommitment = $util.newBuffer($util.base64.length(object.aliceCommitment)), 0);
                else if (object.aliceCommitment.length >= 0)
                    message.aliceCommitment = object.aliceCommitment;
            if (object.aliceAdaptorSig != null) {
                if (typeof object.aliceAdaptorSig !== "object")
                    throw TypeError(".p2p.AtomicSwap.aliceAdaptorSig: object expected");
                message.aliceAdaptorSig = $root.p2p.AdaptorSignature.fromObject(object.aliceAdaptorSig);
            }
            if (object.aliceTimeoutHeight != null)
                if ($util.Long)
                    (message.aliceTimeoutHeight = $util.Long.fromValue(object.aliceTimeoutHeight)).unsigned = true;
                else if (typeof object.aliceTimeoutHeight === "string")
                    message.aliceTimeoutHeight = parseInt(object.aliceTimeoutHeight, 10);
                else if (typeof object.aliceTimeoutHeight === "number")
                    message.aliceTimeoutHeight = object.aliceTimeoutHeight;
                else if (typeof object.aliceTimeoutHeight === "object")
                    message.aliceTimeoutHeight = new $util.LongBits(object.aliceTimeoutHeight.low >>> 0, object.aliceTimeoutHeight.high >>> 0).toNumber(true);
            if (object.bobAmount != null)
                if ($util.Long)
                    (message.bobAmount = $util.Long.fromValue(object.bobAmount)).unsigned = true;
                else if (typeof object.bobAmount === "string")
                    message.bobAmount = parseInt(object.bobAmount, 10);
                else if (typeof object.bobAmount === "number")
                    message.bobAmount = object.bobAmount;
                else if (typeof object.bobAmount === "object")
                    message.bobAmount = new $util.LongBits(object.bobAmount.low >>> 0, object.bobAmount.high >>> 0).toNumber(true);
            if (object.bobPubkey != null)
                if (typeof object.bobPubkey === "string")
                    $util.base64.decode(object.bobPubkey, message.bobPubkey = $util.newBuffer($util.base64.length(object.bobPubkey)), 0);
                else if (object.bobPubkey.length >= 0)
                    message.bobPubkey = object.bobPubkey;
            if (object.bobBtcAddress != null)
                message.bobBtcAddress = String(object.bobBtcAddress);
            if (object.bobBtcTxid != null)
                message.bobBtcTxid = String(object.bobBtcTxid);
            if (object.bobBtcVout != null)
                message.bobBtcVout = object.bobBtcVout >>> 0;
            if (object.bobAdaptorSig != null)
                if (typeof object.bobAdaptorSig === "string")
                    $util.base64.decode(object.bobAdaptorSig, message.bobAdaptorSig = $util.newBuffer($util.base64.length(object.bobAdaptorSig)), 0);
                else if (object.bobAdaptorSig.length >= 0)
                    message.bobAdaptorSig = object.bobAdaptorSig;
            if (object.bobTimeoutHeight != null)
                if ($util.Long)
                    (message.bobTimeoutHeight = $util.Long.fromValue(object.bobTimeoutHeight)).unsigned = true;
                else if (typeof object.bobTimeoutHeight === "string")
                    message.bobTimeoutHeight = parseInt(object.bobTimeoutHeight, 10);
                else if (typeof object.bobTimeoutHeight === "number")
                    message.bobTimeoutHeight = object.bobTimeoutHeight;
                else if (typeof object.bobTimeoutHeight === "object")
                    message.bobTimeoutHeight = new $util.LongBits(object.bobTimeoutHeight.low >>> 0, object.bobTimeoutHeight.high >>> 0).toNumber(true);
            if (object.sharedAdaptorPoint != null)
                if (typeof object.sharedAdaptorPoint === "string")
                    $util.base64.decode(object.sharedAdaptorPoint, message.sharedAdaptorPoint = $util.newBuffer($util.base64.length(object.sharedAdaptorPoint)), 0);
                else if (object.sharedAdaptorPoint.length >= 0)
                    message.sharedAdaptorPoint = object.sharedAdaptorPoint;
            if (object.secretHash != null)
                if (typeof object.secretHash === "string")
                    $util.base64.decode(object.secretHash, message.secretHash = $util.newBuffer($util.base64.length(object.secretHash)), 0);
                else if (object.secretHash.length >= 0)
                    message.secretHash = object.secretHash;
            if (object.createdAt != null)
                if ($util.Long)
                    (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = true;
                else if (typeof object.createdAt === "string")
                    message.createdAt = parseInt(object.createdAt, 10);
                else if (typeof object.createdAt === "number")
                    message.createdAt = object.createdAt;
                else if (typeof object.createdAt === "object")
                    message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber(true);
            if (object.expiresAt != null)
                if ($util.Long)
                    (message.expiresAt = $util.Long.fromValue(object.expiresAt)).unsigned = true;
                else if (typeof object.expiresAt === "string")
                    message.expiresAt = parseInt(object.expiresAt, 10);
                else if (typeof object.expiresAt === "number")
                    message.expiresAt = object.expiresAt;
                else if (typeof object.expiresAt === "object")
                    message.expiresAt = new $util.LongBits(object.expiresAt.low >>> 0, object.expiresAt.high >>> 0).toNumber(true);
            if (object.lastUpdated != null)
                if ($util.Long)
                    (message.lastUpdated = $util.Long.fromValue(object.lastUpdated)).unsigned = true;
                else if (typeof object.lastUpdated === "string")
                    message.lastUpdated = parseInt(object.lastUpdated, 10);
                else if (typeof object.lastUpdated === "number")
                    message.lastUpdated = object.lastUpdated;
                else if (typeof object.lastUpdated === "object")
                    message.lastUpdated = new $util.LongBits(object.lastUpdated.low >>> 0, object.lastUpdated.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AtomicSwap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.AtomicSwap
         * @static
         * @param {p2p.AtomicSwap} message AtomicSwap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AtomicSwap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.stateEnum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.stateEnum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.aliceAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.aliceAmount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.alicePubkey = "";
                else {
                    object.alicePubkey = [];
                    if (options.bytes !== Array)
                        object.alicePubkey = $util.newBuffer(object.alicePubkey);
                }
                if (options.bytes === String)
                    object.aliceCommitment = "";
                else {
                    object.aliceCommitment = [];
                    if (options.bytes !== Array)
                        object.aliceCommitment = $util.newBuffer(object.aliceCommitment);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.aliceTimeoutHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.aliceTimeoutHeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bobAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bobAmount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.bobPubkey = "";
                else {
                    object.bobPubkey = [];
                    if (options.bytes !== Array)
                        object.bobPubkey = $util.newBuffer(object.bobPubkey);
                }
                object.bobBtcAddress = "";
                object.bobBtcTxid = "";
                object.bobBtcVout = 0;
                if (options.bytes === String)
                    object.bobAdaptorSig = "";
                else {
                    object.bobAdaptorSig = [];
                    if (options.bytes !== Array)
                        object.bobAdaptorSig = $util.newBuffer(object.bobAdaptorSig);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bobTimeoutHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bobTimeoutHeight = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.sharedAdaptorPoint = "";
                else {
                    object.sharedAdaptorPoint = [];
                    if (options.bytes !== Array)
                        object.sharedAdaptorPoint = $util.newBuffer(object.sharedAdaptorPoint);
                }
                if (options.bytes === String)
                    object.secretHash = "";
                else {
                    object.secretHash = [];
                    if (options.bytes !== Array)
                        object.secretHash = $util.newBuffer(object.secretHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdAt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.expiresAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresAt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.lastUpdated = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdated = options.longs === String ? "0" : 0;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            if (message.stateEnum != null && message.hasOwnProperty("stateEnum"))
                if (typeof message.stateEnum === "number")
                    object.stateEnum = options.longs === String ? String(message.stateEnum) : message.stateEnum;
                else
                    object.stateEnum = options.longs === String ? $util.Long.prototype.toString.call(message.stateEnum) : options.longs === Number ? new $util.LongBits(message.stateEnum.low >>> 0, message.stateEnum.high >>> 0).toNumber(true) : message.stateEnum;
            if (message.aliceAmount != null && message.hasOwnProperty("aliceAmount"))
                if (typeof message.aliceAmount === "number")
                    object.aliceAmount = options.longs === String ? String(message.aliceAmount) : message.aliceAmount;
                else
                    object.aliceAmount = options.longs === String ? $util.Long.prototype.toString.call(message.aliceAmount) : options.longs === Number ? new $util.LongBits(message.aliceAmount.low >>> 0, message.aliceAmount.high >>> 0).toNumber(true) : message.aliceAmount;
            if (message.alicePubkey != null && message.hasOwnProperty("alicePubkey"))
                object.alicePubkey = options.bytes === String ? $util.base64.encode(message.alicePubkey, 0, message.alicePubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.alicePubkey) : message.alicePubkey;
            if (message.aliceCommitment != null && message.hasOwnProperty("aliceCommitment"))
                object.aliceCommitment = options.bytes === String ? $util.base64.encode(message.aliceCommitment, 0, message.aliceCommitment.length) : options.bytes === Array ? Array.prototype.slice.call(message.aliceCommitment) : message.aliceCommitment;
            if (message.aliceAdaptorSig != null && message.hasOwnProperty("aliceAdaptorSig")) {
                object.aliceAdaptorSig = $root.p2p.AdaptorSignature.toObject(message.aliceAdaptorSig, options);
                if (options.oneofs)
                    object._aliceAdaptorSig = "aliceAdaptorSig";
            }
            if (message.aliceTimeoutHeight != null && message.hasOwnProperty("aliceTimeoutHeight"))
                if (typeof message.aliceTimeoutHeight === "number")
                    object.aliceTimeoutHeight = options.longs === String ? String(message.aliceTimeoutHeight) : message.aliceTimeoutHeight;
                else
                    object.aliceTimeoutHeight = options.longs === String ? $util.Long.prototype.toString.call(message.aliceTimeoutHeight) : options.longs === Number ? new $util.LongBits(message.aliceTimeoutHeight.low >>> 0, message.aliceTimeoutHeight.high >>> 0).toNumber(true) : message.aliceTimeoutHeight;
            if (message.bobAmount != null && message.hasOwnProperty("bobAmount"))
                if (typeof message.bobAmount === "number")
                    object.bobAmount = options.longs === String ? String(message.bobAmount) : message.bobAmount;
                else
                    object.bobAmount = options.longs === String ? $util.Long.prototype.toString.call(message.bobAmount) : options.longs === Number ? new $util.LongBits(message.bobAmount.low >>> 0, message.bobAmount.high >>> 0).toNumber(true) : message.bobAmount;
            if (message.bobPubkey != null && message.hasOwnProperty("bobPubkey"))
                object.bobPubkey = options.bytes === String ? $util.base64.encode(message.bobPubkey, 0, message.bobPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.bobPubkey) : message.bobPubkey;
            if (message.bobBtcAddress != null && message.hasOwnProperty("bobBtcAddress"))
                object.bobBtcAddress = message.bobBtcAddress;
            if (message.bobBtcTxid != null && message.hasOwnProperty("bobBtcTxid"))
                object.bobBtcTxid = message.bobBtcTxid;
            if (message.bobBtcVout != null && message.hasOwnProperty("bobBtcVout"))
                object.bobBtcVout = message.bobBtcVout;
            if (message.bobAdaptorSig != null && message.hasOwnProperty("bobAdaptorSig"))
                object.bobAdaptorSig = options.bytes === String ? $util.base64.encode(message.bobAdaptorSig, 0, message.bobAdaptorSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.bobAdaptorSig) : message.bobAdaptorSig;
            if (message.bobTimeoutHeight != null && message.hasOwnProperty("bobTimeoutHeight"))
                if (typeof message.bobTimeoutHeight === "number")
                    object.bobTimeoutHeight = options.longs === String ? String(message.bobTimeoutHeight) : message.bobTimeoutHeight;
                else
                    object.bobTimeoutHeight = options.longs === String ? $util.Long.prototype.toString.call(message.bobTimeoutHeight) : options.longs === Number ? new $util.LongBits(message.bobTimeoutHeight.low >>> 0, message.bobTimeoutHeight.high >>> 0).toNumber(true) : message.bobTimeoutHeight;
            if (message.sharedAdaptorPoint != null && message.hasOwnProperty("sharedAdaptorPoint"))
                object.sharedAdaptorPoint = options.bytes === String ? $util.base64.encode(message.sharedAdaptorPoint, 0, message.sharedAdaptorPoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharedAdaptorPoint) : message.sharedAdaptorPoint;
            if (message.secretHash != null && message.hasOwnProperty("secretHash"))
                object.secretHash = options.bytes === String ? $util.base64.encode(message.secretHash, 0, message.secretHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.secretHash) : message.secretHash;
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (typeof message.createdAt === "number")
                    object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
                else
                    object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber(true) : message.createdAt;
            if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                if (typeof message.expiresAt === "number")
                    object.expiresAt = options.longs === String ? String(message.expiresAt) : message.expiresAt;
                else
                    object.expiresAt = options.longs === String ? $util.Long.prototype.toString.call(message.expiresAt) : options.longs === Number ? new $util.LongBits(message.expiresAt.low >>> 0, message.expiresAt.high >>> 0).toNumber(true) : message.expiresAt;
            if (message.lastUpdated != null && message.hasOwnProperty("lastUpdated"))
                if (typeof message.lastUpdated === "number")
                    object.lastUpdated = options.longs === String ? String(message.lastUpdated) : message.lastUpdated;
                else
                    object.lastUpdated = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdated) : options.longs === Number ? new $util.LongBits(message.lastUpdated.low >>> 0, message.lastUpdated.high >>> 0).toNumber(true) : message.lastUpdated;
            return object;
        };

        /**
         * Converts this AtomicSwap to JSON.
         * @function toJSON
         * @memberof p2p.AtomicSwap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AtomicSwap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AtomicSwap
         * @function getTypeUrl
         * @memberof p2p.AtomicSwap
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AtomicSwap.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.AtomicSwap";
        };

        return AtomicSwap;
    })();

    p2p.SwapAliceAdaptorSig = (function() {

        /**
         * Properties of a SwapAliceAdaptorSig.
         * @memberof p2p
         * @interface ISwapAliceAdaptorSig
         * @property {Uint8Array|null} [swapId] SwapAliceAdaptorSig swapId
         * @property {p2p.IAdaptorSignature|null} [adaptorSig] SwapAliceAdaptorSig adaptorSig
         */

        /**
         * Constructs a new SwapAliceAdaptorSig.
         * @memberof p2p
         * @classdesc Represents a SwapAliceAdaptorSig.
         * @implements ISwapAliceAdaptorSig
         * @constructor
         * @param {p2p.ISwapAliceAdaptorSig=} [properties] Properties to set
         */
        function SwapAliceAdaptorSig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwapAliceAdaptorSig swapId.
         * @member {Uint8Array} swapId
         * @memberof p2p.SwapAliceAdaptorSig
         * @instance
         */
        SwapAliceAdaptorSig.prototype.swapId = $util.newBuffer([]);

        /**
         * SwapAliceAdaptorSig adaptorSig.
         * @member {p2p.IAdaptorSignature|null|undefined} adaptorSig
         * @memberof p2p.SwapAliceAdaptorSig
         * @instance
         */
        SwapAliceAdaptorSig.prototype.adaptorSig = null;

        /**
         * Creates a new SwapAliceAdaptorSig instance using the specified properties.
         * @function create
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {p2p.ISwapAliceAdaptorSig=} [properties] Properties to set
         * @returns {p2p.SwapAliceAdaptorSig} SwapAliceAdaptorSig instance
         */
        SwapAliceAdaptorSig.create = function create(properties) {
            return new SwapAliceAdaptorSig(properties);
        };

        /**
         * Encodes the specified SwapAliceAdaptorSig message. Does not implicitly {@link p2p.SwapAliceAdaptorSig.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {p2p.ISwapAliceAdaptorSig} message SwapAliceAdaptorSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapAliceAdaptorSig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swapId);
            if (message.adaptorSig != null && Object.hasOwnProperty.call(message, "adaptorSig"))
                $root.p2p.AdaptorSignature.encode(message.adaptorSig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SwapAliceAdaptorSig message, length delimited. Does not implicitly {@link p2p.SwapAliceAdaptorSig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {p2p.ISwapAliceAdaptorSig} message SwapAliceAdaptorSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapAliceAdaptorSig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapAliceAdaptorSig message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapAliceAdaptorSig} SwapAliceAdaptorSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapAliceAdaptorSig.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapAliceAdaptorSig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.swapId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.adaptorSig = $root.p2p.AdaptorSignature.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapAliceAdaptorSig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapAliceAdaptorSig} SwapAliceAdaptorSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapAliceAdaptorSig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapAliceAdaptorSig message.
         * @function verify
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapAliceAdaptorSig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            if (message.adaptorSig != null && message.hasOwnProperty("adaptorSig")) {
                var error = $root.p2p.AdaptorSignature.verify(message.adaptorSig);
                if (error)
                    return "adaptorSig." + error;
            }
            return null;
        };

        /**
         * Creates a SwapAliceAdaptorSig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapAliceAdaptorSig} SwapAliceAdaptorSig
         */
        SwapAliceAdaptorSig.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapAliceAdaptorSig)
                return object;
            var message = new $root.p2p.SwapAliceAdaptorSig();
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length >= 0)
                    message.swapId = object.swapId;
            if (object.adaptorSig != null) {
                if (typeof object.adaptorSig !== "object")
                    throw TypeError(".p2p.SwapAliceAdaptorSig.adaptorSig: object expected");
                message.adaptorSig = $root.p2p.AdaptorSignature.fromObject(object.adaptorSig);
            }
            return message;
        };

        /**
         * Creates a plain object from a SwapAliceAdaptorSig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {p2p.SwapAliceAdaptorSig} message SwapAliceAdaptorSig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapAliceAdaptorSig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
                object.adaptorSig = null;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            if (message.adaptorSig != null && message.hasOwnProperty("adaptorSig"))
                object.adaptorSig = $root.p2p.AdaptorSignature.toObject(message.adaptorSig, options);
            return object;
        };

        /**
         * Converts this SwapAliceAdaptorSig to JSON.
         * @function toJSON
         * @memberof p2p.SwapAliceAdaptorSig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapAliceAdaptorSig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapAliceAdaptorSig
         * @function getTypeUrl
         * @memberof p2p.SwapAliceAdaptorSig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapAliceAdaptorSig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapAliceAdaptorSig";
        };

        return SwapAliceAdaptorSig;
    })();

    p2p.ChannelProposal = (function() {

        /**
         * Properties of a ChannelProposal.
         * @memberof p2p
         * @interface IChannelProposal
         * @property {Uint8Array|null} [channelId] ChannelProposal channelId
         * @property {number|null} [version] ChannelProposal version
         * @property {Uint8Array|null} [partyAPubkey] ChannelProposal partyAPubkey
         * @property {number|Long|null} [partyAFunding] ChannelProposal partyAFunding
         * @property {Uint8Array|null} [partyBPubkey] ChannelProposal partyBPubkey
         * @property {number|Long|null} [partyBFunding] ChannelProposal partyBFunding
         * @property {number|Long|null} [disputePeriod] ChannelProposal disputePeriod
         * @property {number|Long|null} [minConfirmations] ChannelProposal minConfirmations
         * @property {number|Long|null} [createdAt] ChannelProposal createdAt
         */

        /**
         * Constructs a new ChannelProposal.
         * @memberof p2p
         * @classdesc Represents a ChannelProposal.
         * @implements IChannelProposal
         * @constructor
         * @param {p2p.IChannelProposal=} [properties] Properties to set
         */
        function ChannelProposal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelProposal channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.channelId = $util.newBuffer([]);

        /**
         * ChannelProposal version.
         * @member {number} version
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.version = 0;

        /**
         * ChannelProposal partyAPubkey.
         * @member {Uint8Array} partyAPubkey
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.partyAPubkey = $util.newBuffer([]);

        /**
         * ChannelProposal partyAFunding.
         * @member {number|Long} partyAFunding
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.partyAFunding = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelProposal partyBPubkey.
         * @member {Uint8Array} partyBPubkey
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.partyBPubkey = $util.newBuffer([]);

        /**
         * ChannelProposal partyBFunding.
         * @member {number|Long} partyBFunding
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.partyBFunding = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelProposal disputePeriod.
         * @member {number|Long} disputePeriod
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.disputePeriod = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelProposal minConfirmations.
         * @member {number|Long} minConfirmations
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.minConfirmations = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelProposal createdAt.
         * @member {number|Long} createdAt
         * @memberof p2p.ChannelProposal
         * @instance
         */
        ChannelProposal.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelProposal instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelProposal
         * @static
         * @param {p2p.IChannelProposal=} [properties] Properties to set
         * @returns {p2p.ChannelProposal} ChannelProposal instance
         */
        ChannelProposal.create = function create(properties) {
            return new ChannelProposal(properties);
        };

        /**
         * Encodes the specified ChannelProposal message. Does not implicitly {@link p2p.ChannelProposal.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelProposal
         * @static
         * @param {p2p.IChannelProposal} message ChannelProposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelProposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.partyAPubkey != null && Object.hasOwnProperty.call(message, "partyAPubkey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.partyAPubkey);
            if (message.partyAFunding != null && Object.hasOwnProperty.call(message, "partyAFunding"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.partyAFunding);
            if (message.partyBPubkey != null && Object.hasOwnProperty.call(message, "partyBPubkey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.partyBPubkey);
            if (message.partyBFunding != null && Object.hasOwnProperty.call(message, "partyBFunding"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.partyBFunding);
            if (message.disputePeriod != null && Object.hasOwnProperty.call(message, "disputePeriod"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.disputePeriod);
            if (message.minConfirmations != null && Object.hasOwnProperty.call(message, "minConfirmations"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.minConfirmations);
            if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.createdAt);
            return writer;
        };

        /**
         * Encodes the specified ChannelProposal message, length delimited. Does not implicitly {@link p2p.ChannelProposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelProposal
         * @static
         * @param {p2p.IChannelProposal} message ChannelProposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelProposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelProposal message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelProposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelProposal} ChannelProposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelProposal.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelProposal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.version = reader.uint32();
                        break;
                    }
                case 3: {
                        message.partyAPubkey = reader.bytes();
                        break;
                    }
                case 4: {
                        message.partyAFunding = reader.uint64();
                        break;
                    }
                case 5: {
                        message.partyBPubkey = reader.bytes();
                        break;
                    }
                case 6: {
                        message.partyBFunding = reader.uint64();
                        break;
                    }
                case 7: {
                        message.disputePeriod = reader.uint64();
                        break;
                    }
                case 8: {
                        message.minConfirmations = reader.uint64();
                        break;
                    }
                case 9: {
                        message.createdAt = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelProposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelProposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelProposal} ChannelProposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelProposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelProposal message.
         * @function verify
         * @memberof p2p.ChannelProposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelProposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.partyAPubkey != null && message.hasOwnProperty("partyAPubkey"))
                if (!(message.partyAPubkey && typeof message.partyAPubkey.length === "number" || $util.isString(message.partyAPubkey)))
                    return "partyAPubkey: buffer expected";
            if (message.partyAFunding != null && message.hasOwnProperty("partyAFunding"))
                if (!$util.isInteger(message.partyAFunding) && !(message.partyAFunding && $util.isInteger(message.partyAFunding.low) && $util.isInteger(message.partyAFunding.high)))
                    return "partyAFunding: integer|Long expected";
            if (message.partyBPubkey != null && message.hasOwnProperty("partyBPubkey"))
                if (!(message.partyBPubkey && typeof message.partyBPubkey.length === "number" || $util.isString(message.partyBPubkey)))
                    return "partyBPubkey: buffer expected";
            if (message.partyBFunding != null && message.hasOwnProperty("partyBFunding"))
                if (!$util.isInteger(message.partyBFunding) && !(message.partyBFunding && $util.isInteger(message.partyBFunding.low) && $util.isInteger(message.partyBFunding.high)))
                    return "partyBFunding: integer|Long expected";
            if (message.disputePeriod != null && message.hasOwnProperty("disputePeriod"))
                if (!$util.isInteger(message.disputePeriod) && !(message.disputePeriod && $util.isInteger(message.disputePeriod.low) && $util.isInteger(message.disputePeriod.high)))
                    return "disputePeriod: integer|Long expected";
            if (message.minConfirmations != null && message.hasOwnProperty("minConfirmations"))
                if (!$util.isInteger(message.minConfirmations) && !(message.minConfirmations && $util.isInteger(message.minConfirmations.low) && $util.isInteger(message.minConfirmations.high)))
                    return "minConfirmations: integer|Long expected";
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                    return "createdAt: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelProposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelProposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelProposal} ChannelProposal
         */
        ChannelProposal.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelProposal)
                return object;
            var message = new $root.p2p.ChannelProposal();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.partyAPubkey != null)
                if (typeof object.partyAPubkey === "string")
                    $util.base64.decode(object.partyAPubkey, message.partyAPubkey = $util.newBuffer($util.base64.length(object.partyAPubkey)), 0);
                else if (object.partyAPubkey.length >= 0)
                    message.partyAPubkey = object.partyAPubkey;
            if (object.partyAFunding != null)
                if ($util.Long)
                    (message.partyAFunding = $util.Long.fromValue(object.partyAFunding)).unsigned = true;
                else if (typeof object.partyAFunding === "string")
                    message.partyAFunding = parseInt(object.partyAFunding, 10);
                else if (typeof object.partyAFunding === "number")
                    message.partyAFunding = object.partyAFunding;
                else if (typeof object.partyAFunding === "object")
                    message.partyAFunding = new $util.LongBits(object.partyAFunding.low >>> 0, object.partyAFunding.high >>> 0).toNumber(true);
            if (object.partyBPubkey != null)
                if (typeof object.partyBPubkey === "string")
                    $util.base64.decode(object.partyBPubkey, message.partyBPubkey = $util.newBuffer($util.base64.length(object.partyBPubkey)), 0);
                else if (object.partyBPubkey.length >= 0)
                    message.partyBPubkey = object.partyBPubkey;
            if (object.partyBFunding != null)
                if ($util.Long)
                    (message.partyBFunding = $util.Long.fromValue(object.partyBFunding)).unsigned = true;
                else if (typeof object.partyBFunding === "string")
                    message.partyBFunding = parseInt(object.partyBFunding, 10);
                else if (typeof object.partyBFunding === "number")
                    message.partyBFunding = object.partyBFunding;
                else if (typeof object.partyBFunding === "object")
                    message.partyBFunding = new $util.LongBits(object.partyBFunding.low >>> 0, object.partyBFunding.high >>> 0).toNumber(true);
            if (object.disputePeriod != null)
                if ($util.Long)
                    (message.disputePeriod = $util.Long.fromValue(object.disputePeriod)).unsigned = true;
                else if (typeof object.disputePeriod === "string")
                    message.disputePeriod = parseInt(object.disputePeriod, 10);
                else if (typeof object.disputePeriod === "number")
                    message.disputePeriod = object.disputePeriod;
                else if (typeof object.disputePeriod === "object")
                    message.disputePeriod = new $util.LongBits(object.disputePeriod.low >>> 0, object.disputePeriod.high >>> 0).toNumber(true);
            if (object.minConfirmations != null)
                if ($util.Long)
                    (message.minConfirmations = $util.Long.fromValue(object.minConfirmations)).unsigned = true;
                else if (typeof object.minConfirmations === "string")
                    message.minConfirmations = parseInt(object.minConfirmations, 10);
                else if (typeof object.minConfirmations === "number")
                    message.minConfirmations = object.minConfirmations;
                else if (typeof object.minConfirmations === "object")
                    message.minConfirmations = new $util.LongBits(object.minConfirmations.low >>> 0, object.minConfirmations.high >>> 0).toNumber(true);
            if (object.createdAt != null)
                if ($util.Long)
                    (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = true;
                else if (typeof object.createdAt === "string")
                    message.createdAt = parseInt(object.createdAt, 10);
                else if (typeof object.createdAt === "number")
                    message.createdAt = object.createdAt;
                else if (typeof object.createdAt === "object")
                    message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelProposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelProposal
         * @static
         * @param {p2p.ChannelProposal} message ChannelProposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelProposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.version = 0;
                if (options.bytes === String)
                    object.partyAPubkey = "";
                else {
                    object.partyAPubkey = [];
                    if (options.bytes !== Array)
                        object.partyAPubkey = $util.newBuffer(object.partyAPubkey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.partyAFunding = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.partyAFunding = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.partyBPubkey = "";
                else {
                    object.partyBPubkey = [];
                    if (options.bytes !== Array)
                        object.partyBPubkey = $util.newBuffer(object.partyBPubkey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.partyBFunding = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.partyBFunding = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.disputePeriod = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.disputePeriod = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.minConfirmations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minConfirmations = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdAt = options.longs === String ? "0" : 0;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.partyAPubkey != null && message.hasOwnProperty("partyAPubkey"))
                object.partyAPubkey = options.bytes === String ? $util.base64.encode(message.partyAPubkey, 0, message.partyAPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.partyAPubkey) : message.partyAPubkey;
            if (message.partyAFunding != null && message.hasOwnProperty("partyAFunding"))
                if (typeof message.partyAFunding === "number")
                    object.partyAFunding = options.longs === String ? String(message.partyAFunding) : message.partyAFunding;
                else
                    object.partyAFunding = options.longs === String ? $util.Long.prototype.toString.call(message.partyAFunding) : options.longs === Number ? new $util.LongBits(message.partyAFunding.low >>> 0, message.partyAFunding.high >>> 0).toNumber(true) : message.partyAFunding;
            if (message.partyBPubkey != null && message.hasOwnProperty("partyBPubkey"))
                object.partyBPubkey = options.bytes === String ? $util.base64.encode(message.partyBPubkey, 0, message.partyBPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.partyBPubkey) : message.partyBPubkey;
            if (message.partyBFunding != null && message.hasOwnProperty("partyBFunding"))
                if (typeof message.partyBFunding === "number")
                    object.partyBFunding = options.longs === String ? String(message.partyBFunding) : message.partyBFunding;
                else
                    object.partyBFunding = options.longs === String ? $util.Long.prototype.toString.call(message.partyBFunding) : options.longs === Number ? new $util.LongBits(message.partyBFunding.low >>> 0, message.partyBFunding.high >>> 0).toNumber(true) : message.partyBFunding;
            if (message.disputePeriod != null && message.hasOwnProperty("disputePeriod"))
                if (typeof message.disputePeriod === "number")
                    object.disputePeriod = options.longs === String ? String(message.disputePeriod) : message.disputePeriod;
                else
                    object.disputePeriod = options.longs === String ? $util.Long.prototype.toString.call(message.disputePeriod) : options.longs === Number ? new $util.LongBits(message.disputePeriod.low >>> 0, message.disputePeriod.high >>> 0).toNumber(true) : message.disputePeriod;
            if (message.minConfirmations != null && message.hasOwnProperty("minConfirmations"))
                if (typeof message.minConfirmations === "number")
                    object.minConfirmations = options.longs === String ? String(message.minConfirmations) : message.minConfirmations;
                else
                    object.minConfirmations = options.longs === String ? $util.Long.prototype.toString.call(message.minConfirmations) : options.longs === Number ? new $util.LongBits(message.minConfirmations.low >>> 0, message.minConfirmations.high >>> 0).toNumber(true) : message.minConfirmations;
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                if (typeof message.createdAt === "number")
                    object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
                else
                    object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber(true) : message.createdAt;
            return object;
        };

        /**
         * Converts this ChannelProposal to JSON.
         * @function toJSON
         * @memberof p2p.ChannelProposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelProposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelProposal
         * @function getTypeUrl
         * @memberof p2p.ChannelProposal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelProposal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelProposal";
        };

        return ChannelProposal;
    })();

    p2p.CommitmentState = (function() {

        /**
         * Properties of a CommitmentState.
         * @memberof p2p
         * @interface ICommitmentState
         * @property {number|Long|null} [sequenceNumber] CommitmentState sequenceNumber
         * @property {number|null} [ownerPartyEnum] CommitmentState ownerPartyEnum
         * @property {number|Long|null} [ownerBalance] CommitmentState ownerBalance
         * @property {number|Long|null} [counterpartyBalance] CommitmentState counterpartyBalance
         * @property {p2p.ITransaction|null} [commitmentTx] CommitmentState commitmentTx
         * @property {Uint8Array|null} [ownerBlinding] CommitmentState ownerBlinding
         * @property {Uint8Array|null} [counterpartyBlinding] CommitmentState counterpartyBlinding
         * @property {p2p.IAdaptorSignature|null} [adaptorSignature] CommitmentState adaptorSignature
         * @property {Uint8Array|null} [revocationPoint] CommitmentState revocationPoint
         */

        /**
         * Constructs a new CommitmentState.
         * @memberof p2p
         * @classdesc Represents a CommitmentState.
         * @implements ICommitmentState
         * @constructor
         * @param {p2p.ICommitmentState=} [properties] Properties to set
         */
        function CommitmentState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommitmentState sequenceNumber.
         * @member {number|Long} sequenceNumber
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CommitmentState ownerPartyEnum.
         * @member {number} ownerPartyEnum
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.ownerPartyEnum = 0;

        /**
         * CommitmentState ownerBalance.
         * @member {number|Long} ownerBalance
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.ownerBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CommitmentState counterpartyBalance.
         * @member {number|Long} counterpartyBalance
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.counterpartyBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CommitmentState commitmentTx.
         * @member {p2p.ITransaction|null|undefined} commitmentTx
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.commitmentTx = null;

        /**
         * CommitmentState ownerBlinding.
         * @member {Uint8Array} ownerBlinding
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.ownerBlinding = $util.newBuffer([]);

        /**
         * CommitmentState counterpartyBlinding.
         * @member {Uint8Array} counterpartyBlinding
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.counterpartyBlinding = $util.newBuffer([]);

        /**
         * CommitmentState adaptorSignature.
         * @member {p2p.IAdaptorSignature|null|undefined} adaptorSignature
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.adaptorSignature = null;

        /**
         * CommitmentState revocationPoint.
         * @member {Uint8Array} revocationPoint
         * @memberof p2p.CommitmentState
         * @instance
         */
        CommitmentState.prototype.revocationPoint = $util.newBuffer([]);

        /**
         * Creates a new CommitmentState instance using the specified properties.
         * @function create
         * @memberof p2p.CommitmentState
         * @static
         * @param {p2p.ICommitmentState=} [properties] Properties to set
         * @returns {p2p.CommitmentState} CommitmentState instance
         */
        CommitmentState.create = function create(properties) {
            return new CommitmentState(properties);
        };

        /**
         * Encodes the specified CommitmentState message. Does not implicitly {@link p2p.CommitmentState.verify|verify} messages.
         * @function encode
         * @memberof p2p.CommitmentState
         * @static
         * @param {p2p.ICommitmentState} message CommitmentState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitmentState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sequenceNumber);
            if (message.ownerPartyEnum != null && Object.hasOwnProperty.call(message, "ownerPartyEnum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ownerPartyEnum);
            if (message.ownerBalance != null && Object.hasOwnProperty.call(message, "ownerBalance"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ownerBalance);
            if (message.counterpartyBalance != null && Object.hasOwnProperty.call(message, "counterpartyBalance"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.counterpartyBalance);
            if (message.commitmentTx != null && Object.hasOwnProperty.call(message, "commitmentTx"))
                $root.p2p.Transaction.encode(message.commitmentTx, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ownerBlinding != null && Object.hasOwnProperty.call(message, "ownerBlinding"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.ownerBlinding);
            if (message.counterpartyBlinding != null && Object.hasOwnProperty.call(message, "counterpartyBlinding"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.counterpartyBlinding);
            if (message.adaptorSignature != null && Object.hasOwnProperty.call(message, "adaptorSignature"))
                $root.p2p.AdaptorSignature.encode(message.adaptorSignature, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.revocationPoint != null && Object.hasOwnProperty.call(message, "revocationPoint"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.revocationPoint);
            return writer;
        };

        /**
         * Encodes the specified CommitmentState message, length delimited. Does not implicitly {@link p2p.CommitmentState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.CommitmentState
         * @static
         * @param {p2p.ICommitmentState} message CommitmentState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitmentState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitmentState message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.CommitmentState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.CommitmentState} CommitmentState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitmentState.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.CommitmentState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.sequenceNumber = reader.uint64();
                        break;
                    }
                case 2: {
                        message.ownerPartyEnum = reader.uint32();
                        break;
                    }
                case 3: {
                        message.ownerBalance = reader.uint64();
                        break;
                    }
                case 4: {
                        message.counterpartyBalance = reader.uint64();
                        break;
                    }
                case 5: {
                        message.commitmentTx = $root.p2p.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.ownerBlinding = reader.bytes();
                        break;
                    }
                case 7: {
                        message.counterpartyBlinding = reader.bytes();
                        break;
                    }
                case 8: {
                        message.adaptorSignature = $root.p2p.AdaptorSignature.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.revocationPoint = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommitmentState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.CommitmentState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.CommitmentState} CommitmentState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitmentState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitmentState message.
         * @function verify
         * @memberof p2p.CommitmentState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitmentState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                    return "sequenceNumber: integer|Long expected";
            if (message.ownerPartyEnum != null && message.hasOwnProperty("ownerPartyEnum"))
                if (!$util.isInteger(message.ownerPartyEnum))
                    return "ownerPartyEnum: integer expected";
            if (message.ownerBalance != null && message.hasOwnProperty("ownerBalance"))
                if (!$util.isInteger(message.ownerBalance) && !(message.ownerBalance && $util.isInteger(message.ownerBalance.low) && $util.isInteger(message.ownerBalance.high)))
                    return "ownerBalance: integer|Long expected";
            if (message.counterpartyBalance != null && message.hasOwnProperty("counterpartyBalance"))
                if (!$util.isInteger(message.counterpartyBalance) && !(message.counterpartyBalance && $util.isInteger(message.counterpartyBalance.low) && $util.isInteger(message.counterpartyBalance.high)))
                    return "counterpartyBalance: integer|Long expected";
            if (message.commitmentTx != null && message.hasOwnProperty("commitmentTx")) {
                var error = $root.p2p.Transaction.verify(message.commitmentTx);
                if (error)
                    return "commitmentTx." + error;
            }
            if (message.ownerBlinding != null && message.hasOwnProperty("ownerBlinding"))
                if (!(message.ownerBlinding && typeof message.ownerBlinding.length === "number" || $util.isString(message.ownerBlinding)))
                    return "ownerBlinding: buffer expected";
            if (message.counterpartyBlinding != null && message.hasOwnProperty("counterpartyBlinding"))
                if (!(message.counterpartyBlinding && typeof message.counterpartyBlinding.length === "number" || $util.isString(message.counterpartyBlinding)))
                    return "counterpartyBlinding: buffer expected";
            if (message.adaptorSignature != null && message.hasOwnProperty("adaptorSignature")) {
                var error = $root.p2p.AdaptorSignature.verify(message.adaptorSignature);
                if (error)
                    return "adaptorSignature." + error;
            }
            if (message.revocationPoint != null && message.hasOwnProperty("revocationPoint"))
                if (!(message.revocationPoint && typeof message.revocationPoint.length === "number" || $util.isString(message.revocationPoint)))
                    return "revocationPoint: buffer expected";
            return null;
        };

        /**
         * Creates a CommitmentState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.CommitmentState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.CommitmentState} CommitmentState
         */
        CommitmentState.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.CommitmentState)
                return object;
            var message = new $root.p2p.CommitmentState();
            if (object.sequenceNumber != null)
                if ($util.Long)
                    (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = true;
                else if (typeof object.sequenceNumber === "string")
                    message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                else if (typeof object.sequenceNumber === "number")
                    message.sequenceNumber = object.sequenceNumber;
                else if (typeof object.sequenceNumber === "object")
                    message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber(true);
            if (object.ownerPartyEnum != null)
                message.ownerPartyEnum = object.ownerPartyEnum >>> 0;
            if (object.ownerBalance != null)
                if ($util.Long)
                    (message.ownerBalance = $util.Long.fromValue(object.ownerBalance)).unsigned = true;
                else if (typeof object.ownerBalance === "string")
                    message.ownerBalance = parseInt(object.ownerBalance, 10);
                else if (typeof object.ownerBalance === "number")
                    message.ownerBalance = object.ownerBalance;
                else if (typeof object.ownerBalance === "object")
                    message.ownerBalance = new $util.LongBits(object.ownerBalance.low >>> 0, object.ownerBalance.high >>> 0).toNumber(true);
            if (object.counterpartyBalance != null)
                if ($util.Long)
                    (message.counterpartyBalance = $util.Long.fromValue(object.counterpartyBalance)).unsigned = true;
                else if (typeof object.counterpartyBalance === "string")
                    message.counterpartyBalance = parseInt(object.counterpartyBalance, 10);
                else if (typeof object.counterpartyBalance === "number")
                    message.counterpartyBalance = object.counterpartyBalance;
                else if (typeof object.counterpartyBalance === "object")
                    message.counterpartyBalance = new $util.LongBits(object.counterpartyBalance.low >>> 0, object.counterpartyBalance.high >>> 0).toNumber(true);
            if (object.commitmentTx != null) {
                if (typeof object.commitmentTx !== "object")
                    throw TypeError(".p2p.CommitmentState.commitmentTx: object expected");
                message.commitmentTx = $root.p2p.Transaction.fromObject(object.commitmentTx);
            }
            if (object.ownerBlinding != null)
                if (typeof object.ownerBlinding === "string")
                    $util.base64.decode(object.ownerBlinding, message.ownerBlinding = $util.newBuffer($util.base64.length(object.ownerBlinding)), 0);
                else if (object.ownerBlinding.length >= 0)
                    message.ownerBlinding = object.ownerBlinding;
            if (object.counterpartyBlinding != null)
                if (typeof object.counterpartyBlinding === "string")
                    $util.base64.decode(object.counterpartyBlinding, message.counterpartyBlinding = $util.newBuffer($util.base64.length(object.counterpartyBlinding)), 0);
                else if (object.counterpartyBlinding.length >= 0)
                    message.counterpartyBlinding = object.counterpartyBlinding;
            if (object.adaptorSignature != null) {
                if (typeof object.adaptorSignature !== "object")
                    throw TypeError(".p2p.CommitmentState.adaptorSignature: object expected");
                message.adaptorSignature = $root.p2p.AdaptorSignature.fromObject(object.adaptorSignature);
            }
            if (object.revocationPoint != null)
                if (typeof object.revocationPoint === "string")
                    $util.base64.decode(object.revocationPoint, message.revocationPoint = $util.newBuffer($util.base64.length(object.revocationPoint)), 0);
                else if (object.revocationPoint.length >= 0)
                    message.revocationPoint = object.revocationPoint;
            return message;
        };

        /**
         * Creates a plain object from a CommitmentState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.CommitmentState
         * @static
         * @param {p2p.CommitmentState} message CommitmentState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitmentState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequenceNumber = options.longs === String ? "0" : 0;
                object.ownerPartyEnum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ownerBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ownerBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.counterpartyBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.counterpartyBalance = options.longs === String ? "0" : 0;
                object.commitmentTx = null;
                if (options.bytes === String)
                    object.ownerBlinding = "";
                else {
                    object.ownerBlinding = [];
                    if (options.bytes !== Array)
                        object.ownerBlinding = $util.newBuffer(object.ownerBlinding);
                }
                if (options.bytes === String)
                    object.counterpartyBlinding = "";
                else {
                    object.counterpartyBlinding = [];
                    if (options.bytes !== Array)
                        object.counterpartyBlinding = $util.newBuffer(object.counterpartyBlinding);
                }
                object.adaptorSignature = null;
                if (options.bytes === String)
                    object.revocationPoint = "";
                else {
                    object.revocationPoint = [];
                    if (options.bytes !== Array)
                        object.revocationPoint = $util.newBuffer(object.revocationPoint);
                }
            }
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (typeof message.sequenceNumber === "number")
                    object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                else
                    object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber(true) : message.sequenceNumber;
            if (message.ownerPartyEnum != null && message.hasOwnProperty("ownerPartyEnum"))
                object.ownerPartyEnum = message.ownerPartyEnum;
            if (message.ownerBalance != null && message.hasOwnProperty("ownerBalance"))
                if (typeof message.ownerBalance === "number")
                    object.ownerBalance = options.longs === String ? String(message.ownerBalance) : message.ownerBalance;
                else
                    object.ownerBalance = options.longs === String ? $util.Long.prototype.toString.call(message.ownerBalance) : options.longs === Number ? new $util.LongBits(message.ownerBalance.low >>> 0, message.ownerBalance.high >>> 0).toNumber(true) : message.ownerBalance;
            if (message.counterpartyBalance != null && message.hasOwnProperty("counterpartyBalance"))
                if (typeof message.counterpartyBalance === "number")
                    object.counterpartyBalance = options.longs === String ? String(message.counterpartyBalance) : message.counterpartyBalance;
                else
                    object.counterpartyBalance = options.longs === String ? $util.Long.prototype.toString.call(message.counterpartyBalance) : options.longs === Number ? new $util.LongBits(message.counterpartyBalance.low >>> 0, message.counterpartyBalance.high >>> 0).toNumber(true) : message.counterpartyBalance;
            if (message.commitmentTx != null && message.hasOwnProperty("commitmentTx"))
                object.commitmentTx = $root.p2p.Transaction.toObject(message.commitmentTx, options);
            if (message.ownerBlinding != null && message.hasOwnProperty("ownerBlinding"))
                object.ownerBlinding = options.bytes === String ? $util.base64.encode(message.ownerBlinding, 0, message.ownerBlinding.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerBlinding) : message.ownerBlinding;
            if (message.counterpartyBlinding != null && message.hasOwnProperty("counterpartyBlinding"))
                object.counterpartyBlinding = options.bytes === String ? $util.base64.encode(message.counterpartyBlinding, 0, message.counterpartyBlinding.length) : options.bytes === Array ? Array.prototype.slice.call(message.counterpartyBlinding) : message.counterpartyBlinding;
            if (message.adaptorSignature != null && message.hasOwnProperty("adaptorSignature"))
                object.adaptorSignature = $root.p2p.AdaptorSignature.toObject(message.adaptorSignature, options);
            if (message.revocationPoint != null && message.hasOwnProperty("revocationPoint"))
                object.revocationPoint = options.bytes === String ? $util.base64.encode(message.revocationPoint, 0, message.revocationPoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.revocationPoint) : message.revocationPoint;
            return object;
        };

        /**
         * Converts this CommitmentState to JSON.
         * @function toJSON
         * @memberof p2p.CommitmentState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitmentState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CommitmentState
         * @function getTypeUrl
         * @memberof p2p.CommitmentState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CommitmentState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.CommitmentState";
        };

        return CommitmentState;
    })();

    p2p.ChannelAcceptance = (function() {

        /**
         * Properties of a ChannelAcceptance.
         * @memberof p2p
         * @interface IChannelAcceptance
         * @property {Uint8Array|null} [channelId] ChannelAcceptance channelId
         * @property {p2p.ICommitmentState|null} [partyBCommitment] ChannelAcceptance partyBCommitment
         * @property {Uint8Array|null} [partyBRevocationPoint] ChannelAcceptance partyBRevocationPoint
         * @property {number|Long|null} [acceptedAt] ChannelAcceptance acceptedAt
         */

        /**
         * Constructs a new ChannelAcceptance.
         * @memberof p2p
         * @classdesc Represents a ChannelAcceptance.
         * @implements IChannelAcceptance
         * @constructor
         * @param {p2p.IChannelAcceptance=} [properties] Properties to set
         */
        function ChannelAcceptance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelAcceptance channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.ChannelAcceptance
         * @instance
         */
        ChannelAcceptance.prototype.channelId = $util.newBuffer([]);

        /**
         * ChannelAcceptance partyBCommitment.
         * @member {p2p.ICommitmentState|null|undefined} partyBCommitment
         * @memberof p2p.ChannelAcceptance
         * @instance
         */
        ChannelAcceptance.prototype.partyBCommitment = null;

        /**
         * ChannelAcceptance partyBRevocationPoint.
         * @member {Uint8Array} partyBRevocationPoint
         * @memberof p2p.ChannelAcceptance
         * @instance
         */
        ChannelAcceptance.prototype.partyBRevocationPoint = $util.newBuffer([]);

        /**
         * ChannelAcceptance acceptedAt.
         * @member {number|Long} acceptedAt
         * @memberof p2p.ChannelAcceptance
         * @instance
         */
        ChannelAcceptance.prototype.acceptedAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelAcceptance instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {p2p.IChannelAcceptance=} [properties] Properties to set
         * @returns {p2p.ChannelAcceptance} ChannelAcceptance instance
         */
        ChannelAcceptance.create = function create(properties) {
            return new ChannelAcceptance(properties);
        };

        /**
         * Encodes the specified ChannelAcceptance message. Does not implicitly {@link p2p.ChannelAcceptance.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {p2p.IChannelAcceptance} message ChannelAcceptance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.partyBCommitment != null && Object.hasOwnProperty.call(message, "partyBCommitment"))
                $root.p2p.CommitmentState.encode(message.partyBCommitment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.partyBRevocationPoint != null && Object.hasOwnProperty.call(message, "partyBRevocationPoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.partyBRevocationPoint);
            if (message.acceptedAt != null && Object.hasOwnProperty.call(message, "acceptedAt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.acceptedAt);
            return writer;
        };

        /**
         * Encodes the specified ChannelAcceptance message, length delimited. Does not implicitly {@link p2p.ChannelAcceptance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {p2p.IChannelAcceptance} message ChannelAcceptance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelAcceptance message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelAcceptance} ChannelAcceptance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptance.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelAcceptance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.partyBCommitment = $root.p2p.CommitmentState.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.partyBRevocationPoint = reader.bytes();
                        break;
                    }
                case 4: {
                        message.acceptedAt = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelAcceptance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelAcceptance} ChannelAcceptance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelAcceptance message.
         * @function verify
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelAcceptance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.partyBCommitment != null && message.hasOwnProperty("partyBCommitment")) {
                var error = $root.p2p.CommitmentState.verify(message.partyBCommitment);
                if (error)
                    return "partyBCommitment." + error;
            }
            if (message.partyBRevocationPoint != null && message.hasOwnProperty("partyBRevocationPoint"))
                if (!(message.partyBRevocationPoint && typeof message.partyBRevocationPoint.length === "number" || $util.isString(message.partyBRevocationPoint)))
                    return "partyBRevocationPoint: buffer expected";
            if (message.acceptedAt != null && message.hasOwnProperty("acceptedAt"))
                if (!$util.isInteger(message.acceptedAt) && !(message.acceptedAt && $util.isInteger(message.acceptedAt.low) && $util.isInteger(message.acceptedAt.high)))
                    return "acceptedAt: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelAcceptance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelAcceptance} ChannelAcceptance
         */
        ChannelAcceptance.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelAcceptance)
                return object;
            var message = new $root.p2p.ChannelAcceptance();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.partyBCommitment != null) {
                if (typeof object.partyBCommitment !== "object")
                    throw TypeError(".p2p.ChannelAcceptance.partyBCommitment: object expected");
                message.partyBCommitment = $root.p2p.CommitmentState.fromObject(object.partyBCommitment);
            }
            if (object.partyBRevocationPoint != null)
                if (typeof object.partyBRevocationPoint === "string")
                    $util.base64.decode(object.partyBRevocationPoint, message.partyBRevocationPoint = $util.newBuffer($util.base64.length(object.partyBRevocationPoint)), 0);
                else if (object.partyBRevocationPoint.length >= 0)
                    message.partyBRevocationPoint = object.partyBRevocationPoint;
            if (object.acceptedAt != null)
                if ($util.Long)
                    (message.acceptedAt = $util.Long.fromValue(object.acceptedAt)).unsigned = true;
                else if (typeof object.acceptedAt === "string")
                    message.acceptedAt = parseInt(object.acceptedAt, 10);
                else if (typeof object.acceptedAt === "number")
                    message.acceptedAt = object.acceptedAt;
                else if (typeof object.acceptedAt === "object")
                    message.acceptedAt = new $util.LongBits(object.acceptedAt.low >>> 0, object.acceptedAt.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelAcceptance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {p2p.ChannelAcceptance} message ChannelAcceptance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelAcceptance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.partyBCommitment = null;
                if (options.bytes === String)
                    object.partyBRevocationPoint = "";
                else {
                    object.partyBRevocationPoint = [];
                    if (options.bytes !== Array)
                        object.partyBRevocationPoint = $util.newBuffer(object.partyBRevocationPoint);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.acceptedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.acceptedAt = options.longs === String ? "0" : 0;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.partyBCommitment != null && message.hasOwnProperty("partyBCommitment"))
                object.partyBCommitment = $root.p2p.CommitmentState.toObject(message.partyBCommitment, options);
            if (message.partyBRevocationPoint != null && message.hasOwnProperty("partyBRevocationPoint"))
                object.partyBRevocationPoint = options.bytes === String ? $util.base64.encode(message.partyBRevocationPoint, 0, message.partyBRevocationPoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.partyBRevocationPoint) : message.partyBRevocationPoint;
            if (message.acceptedAt != null && message.hasOwnProperty("acceptedAt"))
                if (typeof message.acceptedAt === "number")
                    object.acceptedAt = options.longs === String ? String(message.acceptedAt) : message.acceptedAt;
                else
                    object.acceptedAt = options.longs === String ? $util.Long.prototype.toString.call(message.acceptedAt) : options.longs === Number ? new $util.LongBits(message.acceptedAt.low >>> 0, message.acceptedAt.high >>> 0).toNumber(true) : message.acceptedAt;
            return object;
        };

        /**
         * Converts this ChannelAcceptance to JSON.
         * @function toJSON
         * @memberof p2p.ChannelAcceptance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelAcceptance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelAcceptance
         * @function getTypeUrl
         * @memberof p2p.ChannelAcceptance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelAcceptance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelAcceptance";
        };

        return ChannelAcceptance;
    })();

    p2p.ChannelNonce = (function() {

        /**
         * Properties of a ChannelNonce.
         * @memberof p2p
         * @interface IChannelNonce
         * @property {Uint8Array|null} [channelId] ChannelNonce channelId
         * @property {Uint8Array|null} [publicNoncePoint] ChannelNonce publicNoncePoint
         */

        /**
         * Constructs a new ChannelNonce.
         * @memberof p2p
         * @classdesc Represents a ChannelNonce.
         * @implements IChannelNonce
         * @constructor
         * @param {p2p.IChannelNonce=} [properties] Properties to set
         */
        function ChannelNonce(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelNonce channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.ChannelNonce
         * @instance
         */
        ChannelNonce.prototype.channelId = $util.newBuffer([]);

        /**
         * ChannelNonce publicNoncePoint.
         * @member {Uint8Array} publicNoncePoint
         * @memberof p2p.ChannelNonce
         * @instance
         */
        ChannelNonce.prototype.publicNoncePoint = $util.newBuffer([]);

        /**
         * Creates a new ChannelNonce instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelNonce
         * @static
         * @param {p2p.IChannelNonce=} [properties] Properties to set
         * @returns {p2p.ChannelNonce} ChannelNonce instance
         */
        ChannelNonce.create = function create(properties) {
            return new ChannelNonce(properties);
        };

        /**
         * Encodes the specified ChannelNonce message. Does not implicitly {@link p2p.ChannelNonce.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelNonce
         * @static
         * @param {p2p.IChannelNonce} message ChannelNonce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelNonce.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.publicNoncePoint != null && Object.hasOwnProperty.call(message, "publicNoncePoint"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicNoncePoint);
            return writer;
        };

        /**
         * Encodes the specified ChannelNonce message, length delimited. Does not implicitly {@link p2p.ChannelNonce.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelNonce
         * @static
         * @param {p2p.IChannelNonce} message ChannelNonce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelNonce.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelNonce message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelNonce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelNonce} ChannelNonce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelNonce.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelNonce();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.publicNoncePoint = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelNonce message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelNonce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelNonce} ChannelNonce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelNonce.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelNonce message.
         * @function verify
         * @memberof p2p.ChannelNonce
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelNonce.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.publicNoncePoint != null && message.hasOwnProperty("publicNoncePoint"))
                if (!(message.publicNoncePoint && typeof message.publicNoncePoint.length === "number" || $util.isString(message.publicNoncePoint)))
                    return "publicNoncePoint: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelNonce message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelNonce
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelNonce} ChannelNonce
         */
        ChannelNonce.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelNonce)
                return object;
            var message = new $root.p2p.ChannelNonce();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.publicNoncePoint != null)
                if (typeof object.publicNoncePoint === "string")
                    $util.base64.decode(object.publicNoncePoint, message.publicNoncePoint = $util.newBuffer($util.base64.length(object.publicNoncePoint)), 0);
                else if (object.publicNoncePoint.length >= 0)
                    message.publicNoncePoint = object.publicNoncePoint;
            return message;
        };

        /**
         * Creates a plain object from a ChannelNonce message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelNonce
         * @static
         * @param {p2p.ChannelNonce} message ChannelNonce
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelNonce.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                if (options.bytes === String)
                    object.publicNoncePoint = "";
                else {
                    object.publicNoncePoint = [];
                    if (options.bytes !== Array)
                        object.publicNoncePoint = $util.newBuffer(object.publicNoncePoint);
                }
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.publicNoncePoint != null && message.hasOwnProperty("publicNoncePoint"))
                object.publicNoncePoint = options.bytes === String ? $util.base64.encode(message.publicNoncePoint, 0, message.publicNoncePoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicNoncePoint) : message.publicNoncePoint;
            return object;
        };

        /**
         * Converts this ChannelNonce to JSON.
         * @function toJSON
         * @memberof p2p.ChannelNonce
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelNonce.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelNonce
         * @function getTypeUrl
         * @memberof p2p.ChannelNonce
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelNonce.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelNonce";
        };

        return ChannelNonce;
    })();

    p2p.ChannelPartialSig = (function() {

        /**
         * Properties of a ChannelPartialSig.
         * @memberof p2p
         * @interface IChannelPartialSig
         * @property {Uint8Array|null} [channelId] ChannelPartialSig channelId
         * @property {Uint8Array|null} [partialSignature] ChannelPartialSig partialSignature
         * @property {p2p.ITransaction|null} [fundingTx] ChannelPartialSig fundingTx
         */

        /**
         * Constructs a new ChannelPartialSig.
         * @memberof p2p
         * @classdesc Represents a ChannelPartialSig.
         * @implements IChannelPartialSig
         * @constructor
         * @param {p2p.IChannelPartialSig=} [properties] Properties to set
         */
        function ChannelPartialSig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPartialSig channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.ChannelPartialSig
         * @instance
         */
        ChannelPartialSig.prototype.channelId = $util.newBuffer([]);

        /**
         * ChannelPartialSig partialSignature.
         * @member {Uint8Array} partialSignature
         * @memberof p2p.ChannelPartialSig
         * @instance
         */
        ChannelPartialSig.prototype.partialSignature = $util.newBuffer([]);

        /**
         * ChannelPartialSig fundingTx.
         * @member {p2p.ITransaction|null|undefined} fundingTx
         * @memberof p2p.ChannelPartialSig
         * @instance
         */
        ChannelPartialSig.prototype.fundingTx = null;

        /**
         * Creates a new ChannelPartialSig instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {p2p.IChannelPartialSig=} [properties] Properties to set
         * @returns {p2p.ChannelPartialSig} ChannelPartialSig instance
         */
        ChannelPartialSig.create = function create(properties) {
            return new ChannelPartialSig(properties);
        };

        /**
         * Encodes the specified ChannelPartialSig message. Does not implicitly {@link p2p.ChannelPartialSig.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {p2p.IChannelPartialSig} message ChannelPartialSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPartialSig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.partialSignature != null && Object.hasOwnProperty.call(message, "partialSignature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.partialSignature);
            if (message.fundingTx != null && Object.hasOwnProperty.call(message, "fundingTx"))
                $root.p2p.Transaction.encode(message.fundingTx, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelPartialSig message, length delimited. Does not implicitly {@link p2p.ChannelPartialSig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {p2p.IChannelPartialSig} message ChannelPartialSig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPartialSig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPartialSig message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelPartialSig} ChannelPartialSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPartialSig.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelPartialSig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.partialSignature = reader.bytes();
                        break;
                    }
                case 3: {
                        message.fundingTx = $root.p2p.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPartialSig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelPartialSig} ChannelPartialSig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPartialSig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPartialSig message.
         * @function verify
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPartialSig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.partialSignature != null && message.hasOwnProperty("partialSignature"))
                if (!(message.partialSignature && typeof message.partialSignature.length === "number" || $util.isString(message.partialSignature)))
                    return "partialSignature: buffer expected";
            if (message.fundingTx != null && message.hasOwnProperty("fundingTx")) {
                var error = $root.p2p.Transaction.verify(message.fundingTx);
                if (error)
                    return "fundingTx." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelPartialSig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelPartialSig} ChannelPartialSig
         */
        ChannelPartialSig.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelPartialSig)
                return object;
            var message = new $root.p2p.ChannelPartialSig();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.partialSignature != null)
                if (typeof object.partialSignature === "string")
                    $util.base64.decode(object.partialSignature, message.partialSignature = $util.newBuffer($util.base64.length(object.partialSignature)), 0);
                else if (object.partialSignature.length >= 0)
                    message.partialSignature = object.partialSignature;
            if (object.fundingTx != null) {
                if (typeof object.fundingTx !== "object")
                    throw TypeError(".p2p.ChannelPartialSig.fundingTx: object expected");
                message.fundingTx = $root.p2p.Transaction.fromObject(object.fundingTx);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelPartialSig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {p2p.ChannelPartialSig} message ChannelPartialSig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPartialSig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                if (options.bytes === String)
                    object.partialSignature = "";
                else {
                    object.partialSignature = [];
                    if (options.bytes !== Array)
                        object.partialSignature = $util.newBuffer(object.partialSignature);
                }
                object.fundingTx = null;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.partialSignature != null && message.hasOwnProperty("partialSignature"))
                object.partialSignature = options.bytes === String ? $util.base64.encode(message.partialSignature, 0, message.partialSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.partialSignature) : message.partialSignature;
            if (message.fundingTx != null && message.hasOwnProperty("fundingTx"))
                object.fundingTx = $root.p2p.Transaction.toObject(message.fundingTx, options);
            return object;
        };

        /**
         * Converts this ChannelPartialSig to JSON.
         * @function toJSON
         * @memberof p2p.ChannelPartialSig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPartialSig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelPartialSig
         * @function getTypeUrl
         * @memberof p2p.ChannelPartialSig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelPartialSig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelPartialSig";
        };

        return ChannelPartialSig;
    })();

    p2p.RevocationData = (function() {

        /**
         * Properties of a RevocationData.
         * @memberof p2p
         * @interface IRevocationData
         * @property {number|null} [partyEnum] RevocationData partyEnum
         * @property {number|Long|null} [sequenceNumber] RevocationData sequenceNumber
         * @property {Uint8Array|null} [revocationSecret] RevocationData revocationSecret
         * @property {Uint8Array|null} [revocationPoint] RevocationData revocationPoint
         * @property {number|Long|null} [revokedAt] RevocationData revokedAt
         */

        /**
         * Constructs a new RevocationData.
         * @memberof p2p
         * @classdesc Represents a RevocationData.
         * @implements IRevocationData
         * @constructor
         * @param {p2p.IRevocationData=} [properties] Properties to set
         */
        function RevocationData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RevocationData partyEnum.
         * @member {number} partyEnum
         * @memberof p2p.RevocationData
         * @instance
         */
        RevocationData.prototype.partyEnum = 0;

        /**
         * RevocationData sequenceNumber.
         * @member {number|Long} sequenceNumber
         * @memberof p2p.RevocationData
         * @instance
         */
        RevocationData.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RevocationData revocationSecret.
         * @member {Uint8Array} revocationSecret
         * @memberof p2p.RevocationData
         * @instance
         */
        RevocationData.prototype.revocationSecret = $util.newBuffer([]);

        /**
         * RevocationData revocationPoint.
         * @member {Uint8Array} revocationPoint
         * @memberof p2p.RevocationData
         * @instance
         */
        RevocationData.prototype.revocationPoint = $util.newBuffer([]);

        /**
         * RevocationData revokedAt.
         * @member {number|Long} revokedAt
         * @memberof p2p.RevocationData
         * @instance
         */
        RevocationData.prototype.revokedAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new RevocationData instance using the specified properties.
         * @function create
         * @memberof p2p.RevocationData
         * @static
         * @param {p2p.IRevocationData=} [properties] Properties to set
         * @returns {p2p.RevocationData} RevocationData instance
         */
        RevocationData.create = function create(properties) {
            return new RevocationData(properties);
        };

        /**
         * Encodes the specified RevocationData message. Does not implicitly {@link p2p.RevocationData.verify|verify} messages.
         * @function encode
         * @memberof p2p.RevocationData
         * @static
         * @param {p2p.IRevocationData} message RevocationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevocationData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partyEnum != null && Object.hasOwnProperty.call(message, "partyEnum"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.partyEnum);
            if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sequenceNumber);
            if (message.revocationSecret != null && Object.hasOwnProperty.call(message, "revocationSecret"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.revocationSecret);
            if (message.revocationPoint != null && Object.hasOwnProperty.call(message, "revocationPoint"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.revocationPoint);
            if (message.revokedAt != null && Object.hasOwnProperty.call(message, "revokedAt"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.revokedAt);
            return writer;
        };

        /**
         * Encodes the specified RevocationData message, length delimited. Does not implicitly {@link p2p.RevocationData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.RevocationData
         * @static
         * @param {p2p.IRevocationData} message RevocationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevocationData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RevocationData message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.RevocationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.RevocationData} RevocationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevocationData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.RevocationData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.partyEnum = reader.uint32();
                        break;
                    }
                case 2: {
                        message.sequenceNumber = reader.uint64();
                        break;
                    }
                case 3: {
                        message.revocationSecret = reader.bytes();
                        break;
                    }
                case 4: {
                        message.revocationPoint = reader.bytes();
                        break;
                    }
                case 5: {
                        message.revokedAt = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RevocationData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.RevocationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.RevocationData} RevocationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevocationData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RevocationData message.
         * @function verify
         * @memberof p2p.RevocationData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RevocationData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partyEnum != null && message.hasOwnProperty("partyEnum"))
                if (!$util.isInteger(message.partyEnum))
                    return "partyEnum: integer expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                    return "sequenceNumber: integer|Long expected";
            if (message.revocationSecret != null && message.hasOwnProperty("revocationSecret"))
                if (!(message.revocationSecret && typeof message.revocationSecret.length === "number" || $util.isString(message.revocationSecret)))
                    return "revocationSecret: buffer expected";
            if (message.revocationPoint != null && message.hasOwnProperty("revocationPoint"))
                if (!(message.revocationPoint && typeof message.revocationPoint.length === "number" || $util.isString(message.revocationPoint)))
                    return "revocationPoint: buffer expected";
            if (message.revokedAt != null && message.hasOwnProperty("revokedAt"))
                if (!$util.isInteger(message.revokedAt) && !(message.revokedAt && $util.isInteger(message.revokedAt.low) && $util.isInteger(message.revokedAt.high)))
                    return "revokedAt: integer|Long expected";
            return null;
        };

        /**
         * Creates a RevocationData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.RevocationData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.RevocationData} RevocationData
         */
        RevocationData.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.RevocationData)
                return object;
            var message = new $root.p2p.RevocationData();
            if (object.partyEnum != null)
                message.partyEnum = object.partyEnum >>> 0;
            if (object.sequenceNumber != null)
                if ($util.Long)
                    (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = true;
                else if (typeof object.sequenceNumber === "string")
                    message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                else if (typeof object.sequenceNumber === "number")
                    message.sequenceNumber = object.sequenceNumber;
                else if (typeof object.sequenceNumber === "object")
                    message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber(true);
            if (object.revocationSecret != null)
                if (typeof object.revocationSecret === "string")
                    $util.base64.decode(object.revocationSecret, message.revocationSecret = $util.newBuffer($util.base64.length(object.revocationSecret)), 0);
                else if (object.revocationSecret.length >= 0)
                    message.revocationSecret = object.revocationSecret;
            if (object.revocationPoint != null)
                if (typeof object.revocationPoint === "string")
                    $util.base64.decode(object.revocationPoint, message.revocationPoint = $util.newBuffer($util.base64.length(object.revocationPoint)), 0);
                else if (object.revocationPoint.length >= 0)
                    message.revocationPoint = object.revocationPoint;
            if (object.revokedAt != null)
                if ($util.Long)
                    (message.revokedAt = $util.Long.fromValue(object.revokedAt)).unsigned = true;
                else if (typeof object.revokedAt === "string")
                    message.revokedAt = parseInt(object.revokedAt, 10);
                else if (typeof object.revokedAt === "number")
                    message.revokedAt = object.revokedAt;
                else if (typeof object.revokedAt === "object")
                    message.revokedAt = new $util.LongBits(object.revokedAt.low >>> 0, object.revokedAt.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a RevocationData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.RevocationData
         * @static
         * @param {p2p.RevocationData} message RevocationData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RevocationData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.partyEnum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequenceNumber = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.revocationSecret = "";
                else {
                    object.revocationSecret = [];
                    if (options.bytes !== Array)
                        object.revocationSecret = $util.newBuffer(object.revocationSecret);
                }
                if (options.bytes === String)
                    object.revocationPoint = "";
                else {
                    object.revocationPoint = [];
                    if (options.bytes !== Array)
                        object.revocationPoint = $util.newBuffer(object.revocationPoint);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.revokedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revokedAt = options.longs === String ? "0" : 0;
            }
            if (message.partyEnum != null && message.hasOwnProperty("partyEnum"))
                object.partyEnum = message.partyEnum;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (typeof message.sequenceNumber === "number")
                    object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                else
                    object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber(true) : message.sequenceNumber;
            if (message.revocationSecret != null && message.hasOwnProperty("revocationSecret"))
                object.revocationSecret = options.bytes === String ? $util.base64.encode(message.revocationSecret, 0, message.revocationSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.revocationSecret) : message.revocationSecret;
            if (message.revocationPoint != null && message.hasOwnProperty("revocationPoint"))
                object.revocationPoint = options.bytes === String ? $util.base64.encode(message.revocationPoint, 0, message.revocationPoint.length) : options.bytes === Array ? Array.prototype.slice.call(message.revocationPoint) : message.revocationPoint;
            if (message.revokedAt != null && message.hasOwnProperty("revokedAt"))
                if (typeof message.revokedAt === "number")
                    object.revokedAt = options.longs === String ? String(message.revokedAt) : message.revokedAt;
                else
                    object.revokedAt = options.longs === String ? $util.Long.prototype.toString.call(message.revokedAt) : options.longs === Number ? new $util.LongBits(message.revokedAt.low >>> 0, message.revokedAt.high >>> 0).toNumber(true) : message.revokedAt;
            return object;
        };

        /**
         * Converts this RevocationData to JSON.
         * @function toJSON
         * @memberof p2p.RevocationData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RevocationData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RevocationData
         * @function getTypeUrl
         * @memberof p2p.RevocationData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RevocationData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.RevocationData";
        };

        return RevocationData;
    })();

    p2p.PaymentProposal = (function() {

        /**
         * Properties of a PaymentProposal.
         * @memberof p2p
         * @interface IPaymentProposal
         * @property {Uint8Array|null} [channelId] PaymentProposal channelId
         * @property {number|Long|null} [newSequence] PaymentProposal newSequence
         * @property {number|Long|null} [amount] PaymentProposal amount
         * @property {number|null} [senderPartyEnum] PaymentProposal senderPartyEnum
         * @property {number|Long|null} [newBalanceA] PaymentProposal newBalanceA
         * @property {number|Long|null} [newBalanceB] PaymentProposal newBalanceB
         * @property {p2p.ICommitmentState|null} [newCommitment] PaymentProposal newCommitment
         * @property {p2p.IRevocationData|null} [oldRevocation] PaymentProposal oldRevocation
         * @property {number|Long|null} [timestamp] PaymentProposal timestamp
         */

        /**
         * Constructs a new PaymentProposal.
         * @memberof p2p
         * @classdesc Represents a PaymentProposal.
         * @implements IPaymentProposal
         * @constructor
         * @param {p2p.IPaymentProposal=} [properties] Properties to set
         */
        function PaymentProposal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentProposal channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.channelId = $util.newBuffer([]);

        /**
         * PaymentProposal newSequence.
         * @member {number|Long} newSequence
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.newSequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentProposal amount.
         * @member {number|Long} amount
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentProposal senderPartyEnum.
         * @member {number} senderPartyEnum
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.senderPartyEnum = 0;

        /**
         * PaymentProposal newBalanceA.
         * @member {number|Long} newBalanceA
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.newBalanceA = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentProposal newBalanceB.
         * @member {number|Long} newBalanceB
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.newBalanceB = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentProposal newCommitment.
         * @member {p2p.ICommitmentState|null|undefined} newCommitment
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.newCommitment = null;

        /**
         * PaymentProposal oldRevocation.
         * @member {p2p.IRevocationData|null|undefined} oldRevocation
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.oldRevocation = null;

        /**
         * PaymentProposal timestamp.
         * @member {number|Long} timestamp
         * @memberof p2p.PaymentProposal
         * @instance
         */
        PaymentProposal.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PaymentProposal _oldRevocation.
         * @member {"oldRevocation"|undefined} _oldRevocation
         * @memberof p2p.PaymentProposal
         * @instance
         */
        Object.defineProperty(PaymentProposal.prototype, "_oldRevocation", {
            get: $util.oneOfGetter($oneOfFields = ["oldRevocation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PaymentProposal instance using the specified properties.
         * @function create
         * @memberof p2p.PaymentProposal
         * @static
         * @param {p2p.IPaymentProposal=} [properties] Properties to set
         * @returns {p2p.PaymentProposal} PaymentProposal instance
         */
        PaymentProposal.create = function create(properties) {
            return new PaymentProposal(properties);
        };

        /**
         * Encodes the specified PaymentProposal message. Does not implicitly {@link p2p.PaymentProposal.verify|verify} messages.
         * @function encode
         * @memberof p2p.PaymentProposal
         * @static
         * @param {p2p.IPaymentProposal} message PaymentProposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentProposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.newSequence != null && Object.hasOwnProperty.call(message, "newSequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.newSequence);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
            if (message.senderPartyEnum != null && Object.hasOwnProperty.call(message, "senderPartyEnum"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.senderPartyEnum);
            if (message.newBalanceA != null && Object.hasOwnProperty.call(message, "newBalanceA"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.newBalanceA);
            if (message.newBalanceB != null && Object.hasOwnProperty.call(message, "newBalanceB"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.newBalanceB);
            if (message.newCommitment != null && Object.hasOwnProperty.call(message, "newCommitment"))
                $root.p2p.CommitmentState.encode(message.newCommitment, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.oldRevocation != null && Object.hasOwnProperty.call(message, "oldRevocation"))
                $root.p2p.RevocationData.encode(message.oldRevocation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PaymentProposal message, length delimited. Does not implicitly {@link p2p.PaymentProposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PaymentProposal
         * @static
         * @param {p2p.IPaymentProposal} message PaymentProposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentProposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentProposal message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PaymentProposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PaymentProposal} PaymentProposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentProposal.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PaymentProposal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.newSequence = reader.uint64();
                        break;
                    }
                case 3: {
                        message.amount = reader.uint64();
                        break;
                    }
                case 4: {
                        message.senderPartyEnum = reader.uint32();
                        break;
                    }
                case 5: {
                        message.newBalanceA = reader.uint64();
                        break;
                    }
                case 6: {
                        message.newBalanceB = reader.uint64();
                        break;
                    }
                case 7: {
                        message.newCommitment = $root.p2p.CommitmentState.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.oldRevocation = $root.p2p.RevocationData.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentProposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PaymentProposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PaymentProposal} PaymentProposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentProposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentProposal message.
         * @function verify
         * @memberof p2p.PaymentProposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentProposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.newSequence != null && message.hasOwnProperty("newSequence"))
                if (!$util.isInteger(message.newSequence) && !(message.newSequence && $util.isInteger(message.newSequence.low) && $util.isInteger(message.newSequence.high)))
                    return "newSequence: integer|Long expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.senderPartyEnum != null && message.hasOwnProperty("senderPartyEnum"))
                if (!$util.isInteger(message.senderPartyEnum))
                    return "senderPartyEnum: integer expected";
            if (message.newBalanceA != null && message.hasOwnProperty("newBalanceA"))
                if (!$util.isInteger(message.newBalanceA) && !(message.newBalanceA && $util.isInteger(message.newBalanceA.low) && $util.isInteger(message.newBalanceA.high)))
                    return "newBalanceA: integer|Long expected";
            if (message.newBalanceB != null && message.hasOwnProperty("newBalanceB"))
                if (!$util.isInteger(message.newBalanceB) && !(message.newBalanceB && $util.isInteger(message.newBalanceB.low) && $util.isInteger(message.newBalanceB.high)))
                    return "newBalanceB: integer|Long expected";
            if (message.newCommitment != null && message.hasOwnProperty("newCommitment")) {
                var error = $root.p2p.CommitmentState.verify(message.newCommitment);
                if (error)
                    return "newCommitment." + error;
            }
            if (message.oldRevocation != null && message.hasOwnProperty("oldRevocation")) {
                properties._oldRevocation = 1;
                {
                    var error = $root.p2p.RevocationData.verify(message.oldRevocation);
                    if (error)
                        return "oldRevocation." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PaymentProposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PaymentProposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PaymentProposal} PaymentProposal
         */
        PaymentProposal.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PaymentProposal)
                return object;
            var message = new $root.p2p.PaymentProposal();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.newSequence != null)
                if ($util.Long)
                    (message.newSequence = $util.Long.fromValue(object.newSequence)).unsigned = true;
                else if (typeof object.newSequence === "string")
                    message.newSequence = parseInt(object.newSequence, 10);
                else if (typeof object.newSequence === "number")
                    message.newSequence = object.newSequence;
                else if (typeof object.newSequence === "object")
                    message.newSequence = new $util.LongBits(object.newSequence.low >>> 0, object.newSequence.high >>> 0).toNumber(true);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            if (object.senderPartyEnum != null)
                message.senderPartyEnum = object.senderPartyEnum >>> 0;
            if (object.newBalanceA != null)
                if ($util.Long)
                    (message.newBalanceA = $util.Long.fromValue(object.newBalanceA)).unsigned = true;
                else if (typeof object.newBalanceA === "string")
                    message.newBalanceA = parseInt(object.newBalanceA, 10);
                else if (typeof object.newBalanceA === "number")
                    message.newBalanceA = object.newBalanceA;
                else if (typeof object.newBalanceA === "object")
                    message.newBalanceA = new $util.LongBits(object.newBalanceA.low >>> 0, object.newBalanceA.high >>> 0).toNumber(true);
            if (object.newBalanceB != null)
                if ($util.Long)
                    (message.newBalanceB = $util.Long.fromValue(object.newBalanceB)).unsigned = true;
                else if (typeof object.newBalanceB === "string")
                    message.newBalanceB = parseInt(object.newBalanceB, 10);
                else if (typeof object.newBalanceB === "number")
                    message.newBalanceB = object.newBalanceB;
                else if (typeof object.newBalanceB === "object")
                    message.newBalanceB = new $util.LongBits(object.newBalanceB.low >>> 0, object.newBalanceB.high >>> 0).toNumber(true);
            if (object.newCommitment != null) {
                if (typeof object.newCommitment !== "object")
                    throw TypeError(".p2p.PaymentProposal.newCommitment: object expected");
                message.newCommitment = $root.p2p.CommitmentState.fromObject(object.newCommitment);
            }
            if (object.oldRevocation != null) {
                if (typeof object.oldRevocation !== "object")
                    throw TypeError(".p2p.PaymentProposal.oldRevocation: object expected");
                message.oldRevocation = $root.p2p.RevocationData.fromObject(object.oldRevocation);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PaymentProposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PaymentProposal
         * @static
         * @param {p2p.PaymentProposal} message PaymentProposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentProposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.newSequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newSequence = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.senderPartyEnum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.newBalanceA = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newBalanceA = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.newBalanceB = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newBalanceB = options.longs === String ? "0" : 0;
                object.newCommitment = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.newSequence != null && message.hasOwnProperty("newSequence"))
                if (typeof message.newSequence === "number")
                    object.newSequence = options.longs === String ? String(message.newSequence) : message.newSequence;
                else
                    object.newSequence = options.longs === String ? $util.Long.prototype.toString.call(message.newSequence) : options.longs === Number ? new $util.LongBits(message.newSequence.low >>> 0, message.newSequence.high >>> 0).toNumber(true) : message.newSequence;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            if (message.senderPartyEnum != null && message.hasOwnProperty("senderPartyEnum"))
                object.senderPartyEnum = message.senderPartyEnum;
            if (message.newBalanceA != null && message.hasOwnProperty("newBalanceA"))
                if (typeof message.newBalanceA === "number")
                    object.newBalanceA = options.longs === String ? String(message.newBalanceA) : message.newBalanceA;
                else
                    object.newBalanceA = options.longs === String ? $util.Long.prototype.toString.call(message.newBalanceA) : options.longs === Number ? new $util.LongBits(message.newBalanceA.low >>> 0, message.newBalanceA.high >>> 0).toNumber(true) : message.newBalanceA;
            if (message.newBalanceB != null && message.hasOwnProperty("newBalanceB"))
                if (typeof message.newBalanceB === "number")
                    object.newBalanceB = options.longs === String ? String(message.newBalanceB) : message.newBalanceB;
                else
                    object.newBalanceB = options.longs === String ? $util.Long.prototype.toString.call(message.newBalanceB) : options.longs === Number ? new $util.LongBits(message.newBalanceB.low >>> 0, message.newBalanceB.high >>> 0).toNumber(true) : message.newBalanceB;
            if (message.newCommitment != null && message.hasOwnProperty("newCommitment"))
                object.newCommitment = $root.p2p.CommitmentState.toObject(message.newCommitment, options);
            if (message.oldRevocation != null && message.hasOwnProperty("oldRevocation")) {
                object.oldRevocation = $root.p2p.RevocationData.toObject(message.oldRevocation, options);
                if (options.oneofs)
                    object._oldRevocation = "oldRevocation";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };

        /**
         * Converts this PaymentProposal to JSON.
         * @function toJSON
         * @memberof p2p.PaymentProposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentProposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PaymentProposal
         * @function getTypeUrl
         * @memberof p2p.PaymentProposal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PaymentProposal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PaymentProposal";
        };

        return PaymentProposal;
    })();

    p2p.PaymentAcceptance = (function() {

        /**
         * Properties of a PaymentAcceptance.
         * @memberof p2p
         * @interface IPaymentAcceptance
         * @property {Uint8Array|null} [channelId] PaymentAcceptance channelId
         * @property {number|Long|null} [sequence] PaymentAcceptance sequence
         * @property {p2p.ICommitmentState|null} [newCommitment] PaymentAcceptance newCommitment
         * @property {p2p.IRevocationData|null} [oldRevocation] PaymentAcceptance oldRevocation
         * @property {number|Long|null} [acceptedAt] PaymentAcceptance acceptedAt
         */

        /**
         * Constructs a new PaymentAcceptance.
         * @memberof p2p
         * @classdesc Represents a PaymentAcceptance.
         * @implements IPaymentAcceptance
         * @constructor
         * @param {p2p.IPaymentAcceptance=} [properties] Properties to set
         */
        function PaymentAcceptance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentAcceptance channelId.
         * @member {Uint8Array} channelId
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        PaymentAcceptance.prototype.channelId = $util.newBuffer([]);

        /**
         * PaymentAcceptance sequence.
         * @member {number|Long} sequence
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        PaymentAcceptance.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentAcceptance newCommitment.
         * @member {p2p.ICommitmentState|null|undefined} newCommitment
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        PaymentAcceptance.prototype.newCommitment = null;

        /**
         * PaymentAcceptance oldRevocation.
         * @member {p2p.IRevocationData|null|undefined} oldRevocation
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        PaymentAcceptance.prototype.oldRevocation = null;

        /**
         * PaymentAcceptance acceptedAt.
         * @member {number|Long} acceptedAt
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        PaymentAcceptance.prototype.acceptedAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PaymentAcceptance _oldRevocation.
         * @member {"oldRevocation"|undefined} _oldRevocation
         * @memberof p2p.PaymentAcceptance
         * @instance
         */
        Object.defineProperty(PaymentAcceptance.prototype, "_oldRevocation", {
            get: $util.oneOfGetter($oneOfFields = ["oldRevocation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PaymentAcceptance instance using the specified properties.
         * @function create
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {p2p.IPaymentAcceptance=} [properties] Properties to set
         * @returns {p2p.PaymentAcceptance} PaymentAcceptance instance
         */
        PaymentAcceptance.create = function create(properties) {
            return new PaymentAcceptance(properties);
        };

        /**
         * Encodes the specified PaymentAcceptance message. Does not implicitly {@link p2p.PaymentAcceptance.verify|verify} messages.
         * @function encode
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {p2p.IPaymentAcceptance} message PaymentAcceptance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentAcceptance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelId);
            if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sequence);
            if (message.newCommitment != null && Object.hasOwnProperty.call(message, "newCommitment"))
                $root.p2p.CommitmentState.encode(message.newCommitment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.oldRevocation != null && Object.hasOwnProperty.call(message, "oldRevocation"))
                $root.p2p.RevocationData.encode(message.oldRevocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.acceptedAt != null && Object.hasOwnProperty.call(message, "acceptedAt"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.acceptedAt);
            return writer;
        };

        /**
         * Encodes the specified PaymentAcceptance message, length delimited. Does not implicitly {@link p2p.PaymentAcceptance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {p2p.IPaymentAcceptance} message PaymentAcceptance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentAcceptance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentAcceptance message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PaymentAcceptance} PaymentAcceptance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentAcceptance.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PaymentAcceptance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelId = reader.bytes();
                        break;
                    }
                case 2: {
                        message.sequence = reader.uint64();
                        break;
                    }
                case 3: {
                        message.newCommitment = $root.p2p.CommitmentState.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.oldRevocation = $root.p2p.RevocationData.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.acceptedAt = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentAcceptance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PaymentAcceptance} PaymentAcceptance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentAcceptance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentAcceptance message.
         * @function verify
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentAcceptance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            if (message.newCommitment != null && message.hasOwnProperty("newCommitment")) {
                var error = $root.p2p.CommitmentState.verify(message.newCommitment);
                if (error)
                    return "newCommitment." + error;
            }
            if (message.oldRevocation != null && message.hasOwnProperty("oldRevocation")) {
                properties._oldRevocation = 1;
                {
                    var error = $root.p2p.RevocationData.verify(message.oldRevocation);
                    if (error)
                        return "oldRevocation." + error;
                }
            }
            if (message.acceptedAt != null && message.hasOwnProperty("acceptedAt"))
                if (!$util.isInteger(message.acceptedAt) && !(message.acceptedAt && $util.isInteger(message.acceptedAt.low) && $util.isInteger(message.acceptedAt.high)))
                    return "acceptedAt: integer|Long expected";
            return null;
        };

        /**
         * Creates a PaymentAcceptance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PaymentAcceptance} PaymentAcceptance
         */
        PaymentAcceptance.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PaymentAcceptance)
                return object;
            var message = new $root.p2p.PaymentAcceptance();
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length >= 0)
                    message.channelId = object.channelId;
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
            if (object.newCommitment != null) {
                if (typeof object.newCommitment !== "object")
                    throw TypeError(".p2p.PaymentAcceptance.newCommitment: object expected");
                message.newCommitment = $root.p2p.CommitmentState.fromObject(object.newCommitment);
            }
            if (object.oldRevocation != null) {
                if (typeof object.oldRevocation !== "object")
                    throw TypeError(".p2p.PaymentAcceptance.oldRevocation: object expected");
                message.oldRevocation = $root.p2p.RevocationData.fromObject(object.oldRevocation);
            }
            if (object.acceptedAt != null)
                if ($util.Long)
                    (message.acceptedAt = $util.Long.fromValue(object.acceptedAt)).unsigned = true;
                else if (typeof object.acceptedAt === "string")
                    message.acceptedAt = parseInt(object.acceptedAt, 10);
                else if (typeof object.acceptedAt === "number")
                    message.acceptedAt = object.acceptedAt;
                else if (typeof object.acceptedAt === "object")
                    message.acceptedAt = new $util.LongBits(object.acceptedAt.low >>> 0, object.acceptedAt.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PaymentAcceptance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {p2p.PaymentAcceptance} message PaymentAcceptance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentAcceptance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
                object.newCommitment = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.acceptedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.acceptedAt = options.longs === String ? "0" : 0;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
            if (message.newCommitment != null && message.hasOwnProperty("newCommitment"))
                object.newCommitment = $root.p2p.CommitmentState.toObject(message.newCommitment, options);
            if (message.oldRevocation != null && message.hasOwnProperty("oldRevocation")) {
                object.oldRevocation = $root.p2p.RevocationData.toObject(message.oldRevocation, options);
                if (options.oneofs)
                    object._oldRevocation = "oldRevocation";
            }
            if (message.acceptedAt != null && message.hasOwnProperty("acceptedAt"))
                if (typeof message.acceptedAt === "number")
                    object.acceptedAt = options.longs === String ? String(message.acceptedAt) : message.acceptedAt;
                else
                    object.acceptedAt = options.longs === String ? $util.Long.prototype.toString.call(message.acceptedAt) : options.longs === Number ? new $util.LongBits(message.acceptedAt.low >>> 0, message.acceptedAt.high >>> 0).toNumber(true) : message.acceptedAt;
            return object;
        };

        /**
         * Converts this PaymentAcceptance to JSON.
         * @function toJSON
         * @memberof p2p.PaymentAcceptance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentAcceptance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PaymentAcceptance
         * @function getTypeUrl
         * @memberof p2p.PaymentAcceptance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PaymentAcceptance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PaymentAcceptance";
        };

        return PaymentAcceptance;
    })();

    p2p.P2pMessage = (function() {

        /**
         * Properties of a P2pMessage.
         * @memberof p2p
         * @interface IP2pMessage
         * @property {p2p.IBlock|null} [block] P2pMessage block
         * @property {p2p.ITransaction|null} [transaction] P2pMessage transaction
         * @property {p2p.IBlockAnnouncement|null} [blockAnnouncement] P2pMessage blockAnnouncement
         * @property {p2p.IBlockRequest|null} [blockRequest] P2pMessage blockRequest
         * @property {p2p.IGetHashesRequest|null} [getHashesRequest] P2pMessage getHashesRequest
         * @property {p2p.IHashesResponse|null} [hashesResponse] P2pMessage hashesResponse
         * @property {p2p.ISyncMessage|null} [syncMessage] P2pMessage syncMessage
         * @property {p2p.IDandelionStem|null} [dandelionStem] P2pMessage dandelionStem
         * @property {p2p.IAtomicSwap|null} [swapPropose] P2pMessage swapPropose
         * @property {p2p.IAtomicSwap|null} [swapRespond] P2pMessage swapRespond
         * @property {p2p.ISwapAliceAdaptorSig|null} [swapAliceAdaptorSig] P2pMessage swapAliceAdaptorSig
         * @property {p2p.IChannelProposal|null} [channelPropose] P2pMessage channelPropose
         * @property {p2p.IChannelAcceptance|null} [channelAccept] P2pMessage channelAccept
         * @property {p2p.IChannelNonce|null} [channelFundNonce] P2pMessage channelFundNonce
         * @property {p2p.IChannelPartialSig|null} [channelFundSig] P2pMessage channelFundSig
         * @property {p2p.IPaymentProposal|null} [channelPayPropose] P2pMessage channelPayPropose
         * @property {p2p.IPaymentAcceptance|null} [channelPayAccept] P2pMessage channelPayAccept
         * @property {p2p.IChannelNonce|null} [channelCloseNonce] P2pMessage channelCloseNonce
         * @property {p2p.IChannelPartialSig|null} [channelCloseSig] P2pMessage channelCloseSig
         */

        /**
         * Constructs a new P2pMessage.
         * @memberof p2p
         * @classdesc Represents a P2pMessage.
         * @implements IP2pMessage
         * @constructor
         * @param {p2p.IP2pMessage=} [properties] Properties to set
         */
        function P2pMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * P2pMessage block.
         * @member {p2p.IBlock|null|undefined} block
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.block = null;

        /**
         * P2pMessage transaction.
         * @member {p2p.ITransaction|null|undefined} transaction
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.transaction = null;

        /**
         * P2pMessage blockAnnouncement.
         * @member {p2p.IBlockAnnouncement|null|undefined} blockAnnouncement
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.blockAnnouncement = null;

        /**
         * P2pMessage blockRequest.
         * @member {p2p.IBlockRequest|null|undefined} blockRequest
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.blockRequest = null;

        /**
         * P2pMessage getHashesRequest.
         * @member {p2p.IGetHashesRequest|null|undefined} getHashesRequest
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.getHashesRequest = null;

        /**
         * P2pMessage hashesResponse.
         * @member {p2p.IHashesResponse|null|undefined} hashesResponse
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.hashesResponse = null;

        /**
         * P2pMessage syncMessage.
         * @member {p2p.ISyncMessage|null|undefined} syncMessage
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.syncMessage = null;

        /**
         * P2pMessage dandelionStem.
         * @member {p2p.IDandelionStem|null|undefined} dandelionStem
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.dandelionStem = null;

        /**
         * P2pMessage swapPropose.
         * @member {p2p.IAtomicSwap|null|undefined} swapPropose
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.swapPropose = null;

        /**
         * P2pMessage swapRespond.
         * @member {p2p.IAtomicSwap|null|undefined} swapRespond
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.swapRespond = null;

        /**
         * P2pMessage swapAliceAdaptorSig.
         * @member {p2p.ISwapAliceAdaptorSig|null|undefined} swapAliceAdaptorSig
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.swapAliceAdaptorSig = null;

        /**
         * P2pMessage channelPropose.
         * @member {p2p.IChannelProposal|null|undefined} channelPropose
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelPropose = null;

        /**
         * P2pMessage channelAccept.
         * @member {p2p.IChannelAcceptance|null|undefined} channelAccept
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelAccept = null;

        /**
         * P2pMessage channelFundNonce.
         * @member {p2p.IChannelNonce|null|undefined} channelFundNonce
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelFundNonce = null;

        /**
         * P2pMessage channelFundSig.
         * @member {p2p.IChannelPartialSig|null|undefined} channelFundSig
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelFundSig = null;

        /**
         * P2pMessage channelPayPropose.
         * @member {p2p.IPaymentProposal|null|undefined} channelPayPropose
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelPayPropose = null;

        /**
         * P2pMessage channelPayAccept.
         * @member {p2p.IPaymentAcceptance|null|undefined} channelPayAccept
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelPayAccept = null;

        /**
         * P2pMessage channelCloseNonce.
         * @member {p2p.IChannelNonce|null|undefined} channelCloseNonce
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelCloseNonce = null;

        /**
         * P2pMessage channelCloseSig.
         * @member {p2p.IChannelPartialSig|null|undefined} channelCloseSig
         * @memberof p2p.P2pMessage
         * @instance
         */
        P2pMessage.prototype.channelCloseSig = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * P2pMessage payload.
         * @member {"block"|"transaction"|"blockAnnouncement"|"blockRequest"|"getHashesRequest"|"hashesResponse"|"syncMessage"|"dandelionStem"|"swapPropose"|"swapRespond"|"swapAliceAdaptorSig"|"channelPropose"|"channelAccept"|"channelFundNonce"|"channelFundSig"|"channelPayPropose"|"channelPayAccept"|"channelCloseNonce"|"channelCloseSig"|undefined} payload
         * @memberof p2p.P2pMessage
         * @instance
         */
        Object.defineProperty(P2pMessage.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["block", "transaction", "blockAnnouncement", "blockRequest", "getHashesRequest", "hashesResponse", "syncMessage", "dandelionStem", "swapPropose", "swapRespond", "swapAliceAdaptorSig", "channelPropose", "channelAccept", "channelFundNonce", "channelFundSig", "channelPayPropose", "channelPayAccept", "channelCloseNonce", "channelCloseSig"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new P2pMessage instance using the specified properties.
         * @function create
         * @memberof p2p.P2pMessage
         * @static
         * @param {p2p.IP2pMessage=} [properties] Properties to set
         * @returns {p2p.P2pMessage} P2pMessage instance
         */
        P2pMessage.create = function create(properties) {
            return new P2pMessage(properties);
        };

        /**
         * Encodes the specified P2pMessage message. Does not implicitly {@link p2p.P2pMessage.verify|verify} messages.
         * @function encode
         * @memberof p2p.P2pMessage
         * @static
         * @param {p2p.IP2pMessage} message P2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        P2pMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                $root.p2p.Block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.p2p.Transaction.encode(message.transaction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.blockAnnouncement != null && Object.hasOwnProperty.call(message, "blockAnnouncement"))
                $root.p2p.BlockAnnouncement.encode(message.blockAnnouncement, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.blockRequest != null && Object.hasOwnProperty.call(message, "blockRequest"))
                $root.p2p.BlockRequest.encode(message.blockRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.getHashesRequest != null && Object.hasOwnProperty.call(message, "getHashesRequest"))
                $root.p2p.GetHashesRequest.encode(message.getHashesRequest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.hashesResponse != null && Object.hasOwnProperty.call(message, "hashesResponse"))
                $root.p2p.HashesResponse.encode(message.hashesResponse, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.syncMessage != null && Object.hasOwnProperty.call(message, "syncMessage"))
                $root.p2p.SyncMessage.encode(message.syncMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.dandelionStem != null && Object.hasOwnProperty.call(message, "dandelionStem"))
                $root.p2p.DandelionStem.encode(message.dandelionStem, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.swapPropose != null && Object.hasOwnProperty.call(message, "swapPropose"))
                $root.p2p.AtomicSwap.encode(message.swapPropose, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.swapRespond != null && Object.hasOwnProperty.call(message, "swapRespond"))
                $root.p2p.AtomicSwap.encode(message.swapRespond, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.swapAliceAdaptorSig != null && Object.hasOwnProperty.call(message, "swapAliceAdaptorSig"))
                $root.p2p.SwapAliceAdaptorSig.encode(message.swapAliceAdaptorSig, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.channelPropose != null && Object.hasOwnProperty.call(message, "channelPropose"))
                $root.p2p.ChannelProposal.encode(message.channelPropose, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.channelAccept != null && Object.hasOwnProperty.call(message, "channelAccept"))
                $root.p2p.ChannelAcceptance.encode(message.channelAccept, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.channelFundNonce != null && Object.hasOwnProperty.call(message, "channelFundNonce"))
                $root.p2p.ChannelNonce.encode(message.channelFundNonce, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.channelFundSig != null && Object.hasOwnProperty.call(message, "channelFundSig"))
                $root.p2p.ChannelPartialSig.encode(message.channelFundSig, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.channelPayPropose != null && Object.hasOwnProperty.call(message, "channelPayPropose"))
                $root.p2p.PaymentProposal.encode(message.channelPayPropose, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.channelPayAccept != null && Object.hasOwnProperty.call(message, "channelPayAccept"))
                $root.p2p.PaymentAcceptance.encode(message.channelPayAccept, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.channelCloseNonce != null && Object.hasOwnProperty.call(message, "channelCloseNonce"))
                $root.p2p.ChannelNonce.encode(message.channelCloseNonce, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.channelCloseSig != null && Object.hasOwnProperty.call(message, "channelCloseSig"))
                $root.p2p.ChannelPartialSig.encode(message.channelCloseSig, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified P2pMessage message, length delimited. Does not implicitly {@link p2p.P2pMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.P2pMessage
         * @static
         * @param {p2p.IP2pMessage} message P2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        P2pMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a P2pMessage message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.P2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.P2pMessage} P2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        P2pMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.P2pMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.block = $root.p2p.Block.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.transaction = $root.p2p.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.blockAnnouncement = $root.p2p.BlockAnnouncement.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.blockRequest = $root.p2p.BlockRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.getHashesRequest = $root.p2p.GetHashesRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.hashesResponse = $root.p2p.HashesResponse.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.syncMessage = $root.p2p.SyncMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.dandelionStem = $root.p2p.DandelionStem.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.swapPropose = $root.p2p.AtomicSwap.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.swapRespond = $root.p2p.AtomicSwap.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.swapAliceAdaptorSig = $root.p2p.SwapAliceAdaptorSig.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.channelPropose = $root.p2p.ChannelProposal.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.channelAccept = $root.p2p.ChannelAcceptance.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.channelFundNonce = $root.p2p.ChannelNonce.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.channelFundSig = $root.p2p.ChannelPartialSig.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.channelPayPropose = $root.p2p.PaymentProposal.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.channelPayAccept = $root.p2p.PaymentAcceptance.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.channelCloseNonce = $root.p2p.ChannelNonce.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.channelCloseSig = $root.p2p.ChannelPartialSig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a P2pMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.P2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.P2pMessage} P2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        P2pMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a P2pMessage message.
         * @function verify
         * @memberof p2p.P2pMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        P2pMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.block != null && message.hasOwnProperty("block")) {
                properties.payload = 1;
                {
                    var error = $root.p2p.Block.verify(message.block);
                    if (error)
                        return "block." + error;
                }
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.Transaction.verify(message.transaction);
                    if (error)
                        return "transaction." + error;
                }
            }
            if (message.blockAnnouncement != null && message.hasOwnProperty("blockAnnouncement")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.BlockAnnouncement.verify(message.blockAnnouncement);
                    if (error)
                        return "blockAnnouncement." + error;
                }
            }
            if (message.blockRequest != null && message.hasOwnProperty("blockRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.BlockRequest.verify(message.blockRequest);
                    if (error)
                        return "blockRequest." + error;
                }
            }
            if (message.getHashesRequest != null && message.hasOwnProperty("getHashesRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.GetHashesRequest.verify(message.getHashesRequest);
                    if (error)
                        return "getHashesRequest." + error;
                }
            }
            if (message.hashesResponse != null && message.hasOwnProperty("hashesResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.HashesResponse.verify(message.hashesResponse);
                    if (error)
                        return "hashesResponse." + error;
                }
            }
            if (message.syncMessage != null && message.hasOwnProperty("syncMessage")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.SyncMessage.verify(message.syncMessage);
                    if (error)
                        return "syncMessage." + error;
                }
            }
            if (message.dandelionStem != null && message.hasOwnProperty("dandelionStem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.DandelionStem.verify(message.dandelionStem);
                    if (error)
                        return "dandelionStem." + error;
                }
            }
            if (message.swapPropose != null && message.hasOwnProperty("swapPropose")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.AtomicSwap.verify(message.swapPropose);
                    if (error)
                        return "swapPropose." + error;
                }
            }
            if (message.swapRespond != null && message.hasOwnProperty("swapRespond")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.AtomicSwap.verify(message.swapRespond);
                    if (error)
                        return "swapRespond." + error;
                }
            }
            if (message.swapAliceAdaptorSig != null && message.hasOwnProperty("swapAliceAdaptorSig")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.SwapAliceAdaptorSig.verify(message.swapAliceAdaptorSig);
                    if (error)
                        return "swapAliceAdaptorSig." + error;
                }
            }
            if (message.channelPropose != null && message.hasOwnProperty("channelPropose")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelProposal.verify(message.channelPropose);
                    if (error)
                        return "channelPropose." + error;
                }
            }
            if (message.channelAccept != null && message.hasOwnProperty("channelAccept")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelAcceptance.verify(message.channelAccept);
                    if (error)
                        return "channelAccept." + error;
                }
            }
            if (message.channelFundNonce != null && message.hasOwnProperty("channelFundNonce")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelNonce.verify(message.channelFundNonce);
                    if (error)
                        return "channelFundNonce." + error;
                }
            }
            if (message.channelFundSig != null && message.hasOwnProperty("channelFundSig")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelPartialSig.verify(message.channelFundSig);
                    if (error)
                        return "channelFundSig." + error;
                }
            }
            if (message.channelPayPropose != null && message.hasOwnProperty("channelPayPropose")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.PaymentProposal.verify(message.channelPayPropose);
                    if (error)
                        return "channelPayPropose." + error;
                }
            }
            if (message.channelPayAccept != null && message.hasOwnProperty("channelPayAccept")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.PaymentAcceptance.verify(message.channelPayAccept);
                    if (error)
                        return "channelPayAccept." + error;
                }
            }
            if (message.channelCloseNonce != null && message.hasOwnProperty("channelCloseNonce")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelNonce.verify(message.channelCloseNonce);
                    if (error)
                        return "channelCloseNonce." + error;
                }
            }
            if (message.channelCloseSig != null && message.hasOwnProperty("channelCloseSig")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.p2p.ChannelPartialSig.verify(message.channelCloseSig);
                    if (error)
                        return "channelCloseSig." + error;
                }
            }
            return null;
        };

        /**
         * Creates a P2pMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.P2pMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.P2pMessage} P2pMessage
         */
        P2pMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.P2pMessage)
                return object;
            var message = new $root.p2p.P2pMessage();
            if (object.block != null) {
                if (typeof object.block !== "object")
                    throw TypeError(".p2p.P2pMessage.block: object expected");
                message.block = $root.p2p.Block.fromObject(object.block);
            }
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".p2p.P2pMessage.transaction: object expected");
                message.transaction = $root.p2p.Transaction.fromObject(object.transaction);
            }
            if (object.blockAnnouncement != null) {
                if (typeof object.blockAnnouncement !== "object")
                    throw TypeError(".p2p.P2pMessage.blockAnnouncement: object expected");
                message.blockAnnouncement = $root.p2p.BlockAnnouncement.fromObject(object.blockAnnouncement);
            }
            if (object.blockRequest != null) {
                if (typeof object.blockRequest !== "object")
                    throw TypeError(".p2p.P2pMessage.blockRequest: object expected");
                message.blockRequest = $root.p2p.BlockRequest.fromObject(object.blockRequest);
            }
            if (object.getHashesRequest != null) {
                if (typeof object.getHashesRequest !== "object")
                    throw TypeError(".p2p.P2pMessage.getHashesRequest: object expected");
                message.getHashesRequest = $root.p2p.GetHashesRequest.fromObject(object.getHashesRequest);
            }
            if (object.hashesResponse != null) {
                if (typeof object.hashesResponse !== "object")
                    throw TypeError(".p2p.P2pMessage.hashesResponse: object expected");
                message.hashesResponse = $root.p2p.HashesResponse.fromObject(object.hashesResponse);
            }
            if (object.syncMessage != null) {
                if (typeof object.syncMessage !== "object")
                    throw TypeError(".p2p.P2pMessage.syncMessage: object expected");
                message.syncMessage = $root.p2p.SyncMessage.fromObject(object.syncMessage);
            }
            if (object.dandelionStem != null) {
                if (typeof object.dandelionStem !== "object")
                    throw TypeError(".p2p.P2pMessage.dandelionStem: object expected");
                message.dandelionStem = $root.p2p.DandelionStem.fromObject(object.dandelionStem);
            }
            if (object.swapPropose != null) {
                if (typeof object.swapPropose !== "object")
                    throw TypeError(".p2p.P2pMessage.swapPropose: object expected");
                message.swapPropose = $root.p2p.AtomicSwap.fromObject(object.swapPropose);
            }
            if (object.swapRespond != null) {
                if (typeof object.swapRespond !== "object")
                    throw TypeError(".p2p.P2pMessage.swapRespond: object expected");
                message.swapRespond = $root.p2p.AtomicSwap.fromObject(object.swapRespond);
            }
            if (object.swapAliceAdaptorSig != null) {
                if (typeof object.swapAliceAdaptorSig !== "object")
                    throw TypeError(".p2p.P2pMessage.swapAliceAdaptorSig: object expected");
                message.swapAliceAdaptorSig = $root.p2p.SwapAliceAdaptorSig.fromObject(object.swapAliceAdaptorSig);
            }
            if (object.channelPropose != null) {
                if (typeof object.channelPropose !== "object")
                    throw TypeError(".p2p.P2pMessage.channelPropose: object expected");
                message.channelPropose = $root.p2p.ChannelProposal.fromObject(object.channelPropose);
            }
            if (object.channelAccept != null) {
                if (typeof object.channelAccept !== "object")
                    throw TypeError(".p2p.P2pMessage.channelAccept: object expected");
                message.channelAccept = $root.p2p.ChannelAcceptance.fromObject(object.channelAccept);
            }
            if (object.channelFundNonce != null) {
                if (typeof object.channelFundNonce !== "object")
                    throw TypeError(".p2p.P2pMessage.channelFundNonce: object expected");
                message.channelFundNonce = $root.p2p.ChannelNonce.fromObject(object.channelFundNonce);
            }
            if (object.channelFundSig != null) {
                if (typeof object.channelFundSig !== "object")
                    throw TypeError(".p2p.P2pMessage.channelFundSig: object expected");
                message.channelFundSig = $root.p2p.ChannelPartialSig.fromObject(object.channelFundSig);
            }
            if (object.channelPayPropose != null) {
                if (typeof object.channelPayPropose !== "object")
                    throw TypeError(".p2p.P2pMessage.channelPayPropose: object expected");
                message.channelPayPropose = $root.p2p.PaymentProposal.fromObject(object.channelPayPropose);
            }
            if (object.channelPayAccept != null) {
                if (typeof object.channelPayAccept !== "object")
                    throw TypeError(".p2p.P2pMessage.channelPayAccept: object expected");
                message.channelPayAccept = $root.p2p.PaymentAcceptance.fromObject(object.channelPayAccept);
            }
            if (object.channelCloseNonce != null) {
                if (typeof object.channelCloseNonce !== "object")
                    throw TypeError(".p2p.P2pMessage.channelCloseNonce: object expected");
                message.channelCloseNonce = $root.p2p.ChannelNonce.fromObject(object.channelCloseNonce);
            }
            if (object.channelCloseSig != null) {
                if (typeof object.channelCloseSig !== "object")
                    throw TypeError(".p2p.P2pMessage.channelCloseSig: object expected");
                message.channelCloseSig = $root.p2p.ChannelPartialSig.fromObject(object.channelCloseSig);
            }
            return message;
        };

        /**
         * Creates a plain object from a P2pMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.P2pMessage
         * @static
         * @param {p2p.P2pMessage} message P2pMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        P2pMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.block != null && message.hasOwnProperty("block")) {
                object.block = $root.p2p.Block.toObject(message.block, options);
                if (options.oneofs)
                    object.payload = "block";
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                object.transaction = $root.p2p.Transaction.toObject(message.transaction, options);
                if (options.oneofs)
                    object.payload = "transaction";
            }
            if (message.blockAnnouncement != null && message.hasOwnProperty("blockAnnouncement")) {
                object.blockAnnouncement = $root.p2p.BlockAnnouncement.toObject(message.blockAnnouncement, options);
                if (options.oneofs)
                    object.payload = "blockAnnouncement";
            }
            if (message.blockRequest != null && message.hasOwnProperty("blockRequest")) {
                object.blockRequest = $root.p2p.BlockRequest.toObject(message.blockRequest, options);
                if (options.oneofs)
                    object.payload = "blockRequest";
            }
            if (message.getHashesRequest != null && message.hasOwnProperty("getHashesRequest")) {
                object.getHashesRequest = $root.p2p.GetHashesRequest.toObject(message.getHashesRequest, options);
                if (options.oneofs)
                    object.payload = "getHashesRequest";
            }
            if (message.hashesResponse != null && message.hasOwnProperty("hashesResponse")) {
                object.hashesResponse = $root.p2p.HashesResponse.toObject(message.hashesResponse, options);
                if (options.oneofs)
                    object.payload = "hashesResponse";
            }
            if (message.syncMessage != null && message.hasOwnProperty("syncMessage")) {
                object.syncMessage = $root.p2p.SyncMessage.toObject(message.syncMessage, options);
                if (options.oneofs)
                    object.payload = "syncMessage";
            }
            if (message.dandelionStem != null && message.hasOwnProperty("dandelionStem")) {
                object.dandelionStem = $root.p2p.DandelionStem.toObject(message.dandelionStem, options);
                if (options.oneofs)
                    object.payload = "dandelionStem";
            }
            if (message.swapPropose != null && message.hasOwnProperty("swapPropose")) {
                object.swapPropose = $root.p2p.AtomicSwap.toObject(message.swapPropose, options);
                if (options.oneofs)
                    object.payload = "swapPropose";
            }
            if (message.swapRespond != null && message.hasOwnProperty("swapRespond")) {
                object.swapRespond = $root.p2p.AtomicSwap.toObject(message.swapRespond, options);
                if (options.oneofs)
                    object.payload = "swapRespond";
            }
            if (message.swapAliceAdaptorSig != null && message.hasOwnProperty("swapAliceAdaptorSig")) {
                object.swapAliceAdaptorSig = $root.p2p.SwapAliceAdaptorSig.toObject(message.swapAliceAdaptorSig, options);
                if (options.oneofs)
                    object.payload = "swapAliceAdaptorSig";
            }
            if (message.channelPropose != null && message.hasOwnProperty("channelPropose")) {
                object.channelPropose = $root.p2p.ChannelProposal.toObject(message.channelPropose, options);
                if (options.oneofs)
                    object.payload = "channelPropose";
            }
            if (message.channelAccept != null && message.hasOwnProperty("channelAccept")) {
                object.channelAccept = $root.p2p.ChannelAcceptance.toObject(message.channelAccept, options);
                if (options.oneofs)
                    object.payload = "channelAccept";
            }
            if (message.channelFundNonce != null && message.hasOwnProperty("channelFundNonce")) {
                object.channelFundNonce = $root.p2p.ChannelNonce.toObject(message.channelFundNonce, options);
                if (options.oneofs)
                    object.payload = "channelFundNonce";
            }
            if (message.channelFundSig != null && message.hasOwnProperty("channelFundSig")) {
                object.channelFundSig = $root.p2p.ChannelPartialSig.toObject(message.channelFundSig, options);
                if (options.oneofs)
                    object.payload = "channelFundSig";
            }
            if (message.channelPayPropose != null && message.hasOwnProperty("channelPayPropose")) {
                object.channelPayPropose = $root.p2p.PaymentProposal.toObject(message.channelPayPropose, options);
                if (options.oneofs)
                    object.payload = "channelPayPropose";
            }
            if (message.channelPayAccept != null && message.hasOwnProperty("channelPayAccept")) {
                object.channelPayAccept = $root.p2p.PaymentAcceptance.toObject(message.channelPayAccept, options);
                if (options.oneofs)
                    object.payload = "channelPayAccept";
            }
            if (message.channelCloseNonce != null && message.hasOwnProperty("channelCloseNonce")) {
                object.channelCloseNonce = $root.p2p.ChannelNonce.toObject(message.channelCloseNonce, options);
                if (options.oneofs)
                    object.payload = "channelCloseNonce";
            }
            if (message.channelCloseSig != null && message.hasOwnProperty("channelCloseSig")) {
                object.channelCloseSig = $root.p2p.ChannelPartialSig.toObject(message.channelCloseSig, options);
                if (options.oneofs)
                    object.payload = "channelCloseSig";
            }
            return object;
        };

        /**
         * Converts this P2pMessage to JSON.
         * @function toJSON
         * @memberof p2p.P2pMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        P2pMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for P2pMessage
         * @function getTypeUrl
         * @memberof p2p.P2pMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        P2pMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.P2pMessage";
        };

        return P2pMessage;
    })();

    p2p.JSToRust_Command = (function() {

        /**
         * Properties of a JSToRust_Command.
         * @memberof p2p
         * @interface IJSToRust_Command
         * @property {p2p.IInitializeRequest|null} [initialize] JSToRust_Command initialize
         * @property {p2p.ICreateWalletRequest|null} [createWallet] JSToRust_Command createWallet
         * @property {p2p.IRestoreWalletRequest|null} [restoreWallet] JSToRust_Command restoreWallet
         * @property {p2p.ILoadWalletRequest|null} [loadWallet] JSToRust_Command loadWallet
         * @property {p2p.IGetBalanceRequest|null} [getBalance] JSToRust_Command getBalance
         * @property {p2p.ICreateTransactionRequest|null} [createTransaction] JSToRust_Command createTransaction
         * @property {p2p.IToggleMinerRequest|null} [toggleMiner] JSToRust_Command toggleMiner
         * @property {p2p.IGetStatusRequest|null} [getStatus] JSToRust_Command getStatus
         * @property {p2p.IGetSupplyRequest|null} [getSupply] JSToRust_Command getSupply
         * @property {p2p.IGetPeersRequest|null} [getPeers] JSToRust_Command getPeers
         * @property {p2p.IConnectPeerRequest|null} [connectPeer] JSToRust_Command connectPeer
         * @property {p2p.ISyncTickRequest|null} [syncTick] JSToRust_Command syncTick
         * @property {p2p.ISwapInitiateRequest|null} [swapInitiate] JSToRust_Command swapInitiate
         * @property {p2p.ISwapListRequest|null} [swapList] JSToRust_Command swapList
         * @property {p2p.ISwapRespondRequest|null} [swapRespond] JSToRust_Command swapRespond
         * @property {p2p.ISwapClaimRequest|null} [swapClaim] JSToRust_Command swapClaim
         * @property {p2p.ISwapRefundRequest|null} [swapRefund] JSToRust_Command swapRefund
         * @property {p2p.IChannelOpenRequest|null} [channelOpen] JSToRust_Command channelOpen
         * @property {p2p.IChannelListRequest|null} [channelList] JSToRust_Command channelList
         * @property {p2p.IChannelAcceptRequest|null} [channelAccept] JSToRust_Command channelAccept
         * @property {p2p.IChannelFundRequest|null} [channelFund] JSToRust_Command channelFund
         * @property {p2p.IChannelPayRequest|null} [channelPay] JSToRust_Command channelPay
         * @property {p2p.IChannelCloseRequest|null} [channelClose] JSToRust_Command channelClose
         */

        /**
         * Constructs a new JSToRust_Command.
         * @memberof p2p
         * @classdesc Represents a JSToRust_Command.
         * @implements IJSToRust_Command
         * @constructor
         * @param {p2p.IJSToRust_Command=} [properties] Properties to set
         */
        function JSToRust_Command(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JSToRust_Command initialize.
         * @member {p2p.IInitializeRequest|null|undefined} initialize
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.initialize = null;

        /**
         * JSToRust_Command createWallet.
         * @member {p2p.ICreateWalletRequest|null|undefined} createWallet
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.createWallet = null;

        /**
         * JSToRust_Command restoreWallet.
         * @member {p2p.IRestoreWalletRequest|null|undefined} restoreWallet
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.restoreWallet = null;

        /**
         * JSToRust_Command loadWallet.
         * @member {p2p.ILoadWalletRequest|null|undefined} loadWallet
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.loadWallet = null;

        /**
         * JSToRust_Command getBalance.
         * @member {p2p.IGetBalanceRequest|null|undefined} getBalance
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.getBalance = null;

        /**
         * JSToRust_Command createTransaction.
         * @member {p2p.ICreateTransactionRequest|null|undefined} createTransaction
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.createTransaction = null;

        /**
         * JSToRust_Command toggleMiner.
         * @member {p2p.IToggleMinerRequest|null|undefined} toggleMiner
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.toggleMiner = null;

        /**
         * JSToRust_Command getStatus.
         * @member {p2p.IGetStatusRequest|null|undefined} getStatus
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.getStatus = null;

        /**
         * JSToRust_Command getSupply.
         * @member {p2p.IGetSupplyRequest|null|undefined} getSupply
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.getSupply = null;

        /**
         * JSToRust_Command getPeers.
         * @member {p2p.IGetPeersRequest|null|undefined} getPeers
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.getPeers = null;

        /**
         * JSToRust_Command connectPeer.
         * @member {p2p.IConnectPeerRequest|null|undefined} connectPeer
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.connectPeer = null;

        /**
         * JSToRust_Command syncTick.
         * @member {p2p.ISyncTickRequest|null|undefined} syncTick
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.syncTick = null;

        /**
         * JSToRust_Command swapInitiate.
         * @member {p2p.ISwapInitiateRequest|null|undefined} swapInitiate
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.swapInitiate = null;

        /**
         * JSToRust_Command swapList.
         * @member {p2p.ISwapListRequest|null|undefined} swapList
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.swapList = null;

        /**
         * JSToRust_Command swapRespond.
         * @member {p2p.ISwapRespondRequest|null|undefined} swapRespond
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.swapRespond = null;

        /**
         * JSToRust_Command swapClaim.
         * @member {p2p.ISwapClaimRequest|null|undefined} swapClaim
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.swapClaim = null;

        /**
         * JSToRust_Command swapRefund.
         * @member {p2p.ISwapRefundRequest|null|undefined} swapRefund
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.swapRefund = null;

        /**
         * JSToRust_Command channelOpen.
         * @member {p2p.IChannelOpenRequest|null|undefined} channelOpen
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelOpen = null;

        /**
         * JSToRust_Command channelList.
         * @member {p2p.IChannelListRequest|null|undefined} channelList
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelList = null;

        /**
         * JSToRust_Command channelAccept.
         * @member {p2p.IChannelAcceptRequest|null|undefined} channelAccept
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelAccept = null;

        /**
         * JSToRust_Command channelFund.
         * @member {p2p.IChannelFundRequest|null|undefined} channelFund
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelFund = null;

        /**
         * JSToRust_Command channelPay.
         * @member {p2p.IChannelPayRequest|null|undefined} channelPay
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelPay = null;

        /**
         * JSToRust_Command channelClose.
         * @member {p2p.IChannelCloseRequest|null|undefined} channelClose
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        JSToRust_Command.prototype.channelClose = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * JSToRust_Command command.
         * @member {"initialize"|"createWallet"|"restoreWallet"|"loadWallet"|"getBalance"|"createTransaction"|"toggleMiner"|"getStatus"|"getSupply"|"getPeers"|"connectPeer"|"syncTick"|"swapInitiate"|"swapList"|"swapRespond"|"swapClaim"|"swapRefund"|"channelOpen"|"channelList"|"channelAccept"|"channelFund"|"channelPay"|"channelClose"|undefined} command
         * @memberof p2p.JSToRust_Command
         * @instance
         */
        Object.defineProperty(JSToRust_Command.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["initialize", "createWallet", "restoreWallet", "loadWallet", "getBalance", "createTransaction", "toggleMiner", "getStatus", "getSupply", "getPeers", "connectPeer", "syncTick", "swapInitiate", "swapList", "swapRespond", "swapClaim", "swapRefund", "channelOpen", "channelList", "channelAccept", "channelFund", "channelPay", "channelClose"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new JSToRust_Command instance using the specified properties.
         * @function create
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {p2p.IJSToRust_Command=} [properties] Properties to set
         * @returns {p2p.JSToRust_Command} JSToRust_Command instance
         */
        JSToRust_Command.create = function create(properties) {
            return new JSToRust_Command(properties);
        };

        /**
         * Encodes the specified JSToRust_Command message. Does not implicitly {@link p2p.JSToRust_Command.verify|verify} messages.
         * @function encode
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {p2p.IJSToRust_Command} message JSToRust_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JSToRust_Command.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.initialize != null && Object.hasOwnProperty.call(message, "initialize"))
                $root.p2p.InitializeRequest.encode(message.initialize, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.createWallet != null && Object.hasOwnProperty.call(message, "createWallet"))
                $root.p2p.CreateWalletRequest.encode(message.createWallet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.restoreWallet != null && Object.hasOwnProperty.call(message, "restoreWallet"))
                $root.p2p.RestoreWalletRequest.encode(message.restoreWallet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.loadWallet != null && Object.hasOwnProperty.call(message, "loadWallet"))
                $root.p2p.LoadWalletRequest.encode(message.loadWallet, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.getBalance != null && Object.hasOwnProperty.call(message, "getBalance"))
                $root.p2p.GetBalanceRequest.encode(message.getBalance, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.createTransaction != null && Object.hasOwnProperty.call(message, "createTransaction"))
                $root.p2p.CreateTransactionRequest.encode(message.createTransaction, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.toggleMiner != null && Object.hasOwnProperty.call(message, "toggleMiner"))
                $root.p2p.ToggleMinerRequest.encode(message.toggleMiner, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.getStatus != null && Object.hasOwnProperty.call(message, "getStatus"))
                $root.p2p.GetStatusRequest.encode(message.getStatus, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.getSupply != null && Object.hasOwnProperty.call(message, "getSupply"))
                $root.p2p.GetSupplyRequest.encode(message.getSupply, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.getPeers != null && Object.hasOwnProperty.call(message, "getPeers"))
                $root.p2p.GetPeersRequest.encode(message.getPeers, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.connectPeer != null && Object.hasOwnProperty.call(message, "connectPeer"))
                $root.p2p.ConnectPeerRequest.encode(message.connectPeer, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.syncTick != null && Object.hasOwnProperty.call(message, "syncTick"))
                $root.p2p.SyncTickRequest.encode(message.syncTick, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.swapInitiate != null && Object.hasOwnProperty.call(message, "swapInitiate"))
                $root.p2p.SwapInitiateRequest.encode(message.swapInitiate, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.swapList != null && Object.hasOwnProperty.call(message, "swapList"))
                $root.p2p.SwapListRequest.encode(message.swapList, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.swapRespond != null && Object.hasOwnProperty.call(message, "swapRespond"))
                $root.p2p.SwapRespondRequest.encode(message.swapRespond, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.swapClaim != null && Object.hasOwnProperty.call(message, "swapClaim"))
                $root.p2p.SwapClaimRequest.encode(message.swapClaim, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.swapRefund != null && Object.hasOwnProperty.call(message, "swapRefund"))
                $root.p2p.SwapRefundRequest.encode(message.swapRefund, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.channelOpen != null && Object.hasOwnProperty.call(message, "channelOpen"))
                $root.p2p.ChannelOpenRequest.encode(message.channelOpen, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.channelList != null && Object.hasOwnProperty.call(message, "channelList"))
                $root.p2p.ChannelListRequest.encode(message.channelList, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.channelAccept != null && Object.hasOwnProperty.call(message, "channelAccept"))
                $root.p2p.ChannelAcceptRequest.encode(message.channelAccept, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.channelFund != null && Object.hasOwnProperty.call(message, "channelFund"))
                $root.p2p.ChannelFundRequest.encode(message.channelFund, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.channelPay != null && Object.hasOwnProperty.call(message, "channelPay"))
                $root.p2p.ChannelPayRequest.encode(message.channelPay, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.channelClose != null && Object.hasOwnProperty.call(message, "channelClose"))
                $root.p2p.ChannelCloseRequest.encode(message.channelClose, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JSToRust_Command message, length delimited. Does not implicitly {@link p2p.JSToRust_Command.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {p2p.IJSToRust_Command} message JSToRust_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JSToRust_Command.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JSToRust_Command message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.JSToRust_Command} JSToRust_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JSToRust_Command.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.JSToRust_Command();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.initialize = $root.p2p.InitializeRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.createWallet = $root.p2p.CreateWalletRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.restoreWallet = $root.p2p.RestoreWalletRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.loadWallet = $root.p2p.LoadWalletRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.getBalance = $root.p2p.GetBalanceRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.createTransaction = $root.p2p.CreateTransactionRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.toggleMiner = $root.p2p.ToggleMinerRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.getStatus = $root.p2p.GetStatusRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.getSupply = $root.p2p.GetSupplyRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.getPeers = $root.p2p.GetPeersRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.connectPeer = $root.p2p.ConnectPeerRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.syncTick = $root.p2p.SyncTickRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.swapInitiate = $root.p2p.SwapInitiateRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.swapList = $root.p2p.SwapListRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.swapRespond = $root.p2p.SwapRespondRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.swapClaim = $root.p2p.SwapClaimRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.swapRefund = $root.p2p.SwapRefundRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.channelOpen = $root.p2p.ChannelOpenRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.channelList = $root.p2p.ChannelListRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.channelAccept = $root.p2p.ChannelAcceptRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.channelFund = $root.p2p.ChannelFundRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.channelPay = $root.p2p.ChannelPayRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.channelClose = $root.p2p.ChannelCloseRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JSToRust_Command message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.JSToRust_Command} JSToRust_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JSToRust_Command.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JSToRust_Command message.
         * @function verify
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JSToRust_Command.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.initialize != null && message.hasOwnProperty("initialize")) {
                properties.command = 1;
                {
                    var error = $root.p2p.InitializeRequest.verify(message.initialize);
                    if (error)
                        return "initialize." + error;
                }
            }
            if (message.createWallet != null && message.hasOwnProperty("createWallet")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.CreateWalletRequest.verify(message.createWallet);
                    if (error)
                        return "createWallet." + error;
                }
            }
            if (message.restoreWallet != null && message.hasOwnProperty("restoreWallet")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.RestoreWalletRequest.verify(message.restoreWallet);
                    if (error)
                        return "restoreWallet." + error;
                }
            }
            if (message.loadWallet != null && message.hasOwnProperty("loadWallet")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.LoadWalletRequest.verify(message.loadWallet);
                    if (error)
                        return "loadWallet." + error;
                }
            }
            if (message.getBalance != null && message.hasOwnProperty("getBalance")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.GetBalanceRequest.verify(message.getBalance);
                    if (error)
                        return "getBalance." + error;
                }
            }
            if (message.createTransaction != null && message.hasOwnProperty("createTransaction")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.CreateTransactionRequest.verify(message.createTransaction);
                    if (error)
                        return "createTransaction." + error;
                }
            }
            if (message.toggleMiner != null && message.hasOwnProperty("toggleMiner")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ToggleMinerRequest.verify(message.toggleMiner);
                    if (error)
                        return "toggleMiner." + error;
                }
            }
            if (message.getStatus != null && message.hasOwnProperty("getStatus")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.GetStatusRequest.verify(message.getStatus);
                    if (error)
                        return "getStatus." + error;
                }
            }
            if (message.getSupply != null && message.hasOwnProperty("getSupply")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.GetSupplyRequest.verify(message.getSupply);
                    if (error)
                        return "getSupply." + error;
                }
            }
            if (message.getPeers != null && message.hasOwnProperty("getPeers")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.GetPeersRequest.verify(message.getPeers);
                    if (error)
                        return "getPeers." + error;
                }
            }
            if (message.connectPeer != null && message.hasOwnProperty("connectPeer")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ConnectPeerRequest.verify(message.connectPeer);
                    if (error)
                        return "connectPeer." + error;
                }
            }
            if (message.syncTick != null && message.hasOwnProperty("syncTick")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SyncTickRequest.verify(message.syncTick);
                    if (error)
                        return "syncTick." + error;
                }
            }
            if (message.swapInitiate != null && message.hasOwnProperty("swapInitiate")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SwapInitiateRequest.verify(message.swapInitiate);
                    if (error)
                        return "swapInitiate." + error;
                }
            }
            if (message.swapList != null && message.hasOwnProperty("swapList")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SwapListRequest.verify(message.swapList);
                    if (error)
                        return "swapList." + error;
                }
            }
            if (message.swapRespond != null && message.hasOwnProperty("swapRespond")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SwapRespondRequest.verify(message.swapRespond);
                    if (error)
                        return "swapRespond." + error;
                }
            }
            if (message.swapClaim != null && message.hasOwnProperty("swapClaim")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SwapClaimRequest.verify(message.swapClaim);
                    if (error)
                        return "swapClaim." + error;
                }
            }
            if (message.swapRefund != null && message.hasOwnProperty("swapRefund")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SwapRefundRequest.verify(message.swapRefund);
                    if (error)
                        return "swapRefund." + error;
                }
            }
            if (message.channelOpen != null && message.hasOwnProperty("channelOpen")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelOpenRequest.verify(message.channelOpen);
                    if (error)
                        return "channelOpen." + error;
                }
            }
            if (message.channelList != null && message.hasOwnProperty("channelList")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelListRequest.verify(message.channelList);
                    if (error)
                        return "channelList." + error;
                }
            }
            if (message.channelAccept != null && message.hasOwnProperty("channelAccept")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelAcceptRequest.verify(message.channelAccept);
                    if (error)
                        return "channelAccept." + error;
                }
            }
            if (message.channelFund != null && message.hasOwnProperty("channelFund")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelFundRequest.verify(message.channelFund);
                    if (error)
                        return "channelFund." + error;
                }
            }
            if (message.channelPay != null && message.hasOwnProperty("channelPay")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelPayRequest.verify(message.channelPay);
                    if (error)
                        return "channelPay." + error;
                }
            }
            if (message.channelClose != null && message.hasOwnProperty("channelClose")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.ChannelCloseRequest.verify(message.channelClose);
                    if (error)
                        return "channelClose." + error;
                }
            }
            return null;
        };

        /**
         * Creates a JSToRust_Command message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.JSToRust_Command} JSToRust_Command
         */
        JSToRust_Command.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.JSToRust_Command)
                return object;
            var message = new $root.p2p.JSToRust_Command();
            if (object.initialize != null) {
                if (typeof object.initialize !== "object")
                    throw TypeError(".p2p.JSToRust_Command.initialize: object expected");
                message.initialize = $root.p2p.InitializeRequest.fromObject(object.initialize);
            }
            if (object.createWallet != null) {
                if (typeof object.createWallet !== "object")
                    throw TypeError(".p2p.JSToRust_Command.createWallet: object expected");
                message.createWallet = $root.p2p.CreateWalletRequest.fromObject(object.createWallet);
            }
            if (object.restoreWallet != null) {
                if (typeof object.restoreWallet !== "object")
                    throw TypeError(".p2p.JSToRust_Command.restoreWallet: object expected");
                message.restoreWallet = $root.p2p.RestoreWalletRequest.fromObject(object.restoreWallet);
            }
            if (object.loadWallet != null) {
                if (typeof object.loadWallet !== "object")
                    throw TypeError(".p2p.JSToRust_Command.loadWallet: object expected");
                message.loadWallet = $root.p2p.LoadWalletRequest.fromObject(object.loadWallet);
            }
            if (object.getBalance != null) {
                if (typeof object.getBalance !== "object")
                    throw TypeError(".p2p.JSToRust_Command.getBalance: object expected");
                message.getBalance = $root.p2p.GetBalanceRequest.fromObject(object.getBalance);
            }
            if (object.createTransaction != null) {
                if (typeof object.createTransaction !== "object")
                    throw TypeError(".p2p.JSToRust_Command.createTransaction: object expected");
                message.createTransaction = $root.p2p.CreateTransactionRequest.fromObject(object.createTransaction);
            }
            if (object.toggleMiner != null) {
                if (typeof object.toggleMiner !== "object")
                    throw TypeError(".p2p.JSToRust_Command.toggleMiner: object expected");
                message.toggleMiner = $root.p2p.ToggleMinerRequest.fromObject(object.toggleMiner);
            }
            if (object.getStatus != null) {
                if (typeof object.getStatus !== "object")
                    throw TypeError(".p2p.JSToRust_Command.getStatus: object expected");
                message.getStatus = $root.p2p.GetStatusRequest.fromObject(object.getStatus);
            }
            if (object.getSupply != null) {
                if (typeof object.getSupply !== "object")
                    throw TypeError(".p2p.JSToRust_Command.getSupply: object expected");
                message.getSupply = $root.p2p.GetSupplyRequest.fromObject(object.getSupply);
            }
            if (object.getPeers != null) {
                if (typeof object.getPeers !== "object")
                    throw TypeError(".p2p.JSToRust_Command.getPeers: object expected");
                message.getPeers = $root.p2p.GetPeersRequest.fromObject(object.getPeers);
            }
            if (object.connectPeer != null) {
                if (typeof object.connectPeer !== "object")
                    throw TypeError(".p2p.JSToRust_Command.connectPeer: object expected");
                message.connectPeer = $root.p2p.ConnectPeerRequest.fromObject(object.connectPeer);
            }
            if (object.syncTick != null) {
                if (typeof object.syncTick !== "object")
                    throw TypeError(".p2p.JSToRust_Command.syncTick: object expected");
                message.syncTick = $root.p2p.SyncTickRequest.fromObject(object.syncTick);
            }
            if (object.swapInitiate != null) {
                if (typeof object.swapInitiate !== "object")
                    throw TypeError(".p2p.JSToRust_Command.swapInitiate: object expected");
                message.swapInitiate = $root.p2p.SwapInitiateRequest.fromObject(object.swapInitiate);
            }
            if (object.swapList != null) {
                if (typeof object.swapList !== "object")
                    throw TypeError(".p2p.JSToRust_Command.swapList: object expected");
                message.swapList = $root.p2p.SwapListRequest.fromObject(object.swapList);
            }
            if (object.swapRespond != null) {
                if (typeof object.swapRespond !== "object")
                    throw TypeError(".p2p.JSToRust_Command.swapRespond: object expected");
                message.swapRespond = $root.p2p.SwapRespondRequest.fromObject(object.swapRespond);
            }
            if (object.swapClaim != null) {
                if (typeof object.swapClaim !== "object")
                    throw TypeError(".p2p.JSToRust_Command.swapClaim: object expected");
                message.swapClaim = $root.p2p.SwapClaimRequest.fromObject(object.swapClaim);
            }
            if (object.swapRefund != null) {
                if (typeof object.swapRefund !== "object")
                    throw TypeError(".p2p.JSToRust_Command.swapRefund: object expected");
                message.swapRefund = $root.p2p.SwapRefundRequest.fromObject(object.swapRefund);
            }
            if (object.channelOpen != null) {
                if (typeof object.channelOpen !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelOpen: object expected");
                message.channelOpen = $root.p2p.ChannelOpenRequest.fromObject(object.channelOpen);
            }
            if (object.channelList != null) {
                if (typeof object.channelList !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelList: object expected");
                message.channelList = $root.p2p.ChannelListRequest.fromObject(object.channelList);
            }
            if (object.channelAccept != null) {
                if (typeof object.channelAccept !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelAccept: object expected");
                message.channelAccept = $root.p2p.ChannelAcceptRequest.fromObject(object.channelAccept);
            }
            if (object.channelFund != null) {
                if (typeof object.channelFund !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelFund: object expected");
                message.channelFund = $root.p2p.ChannelFundRequest.fromObject(object.channelFund);
            }
            if (object.channelPay != null) {
                if (typeof object.channelPay !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelPay: object expected");
                message.channelPay = $root.p2p.ChannelPayRequest.fromObject(object.channelPay);
            }
            if (object.channelClose != null) {
                if (typeof object.channelClose !== "object")
                    throw TypeError(".p2p.JSToRust_Command.channelClose: object expected");
                message.channelClose = $root.p2p.ChannelCloseRequest.fromObject(object.channelClose);
            }
            return message;
        };

        /**
         * Creates a plain object from a JSToRust_Command message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {p2p.JSToRust_Command} message JSToRust_Command
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JSToRust_Command.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.initialize != null && message.hasOwnProperty("initialize")) {
                object.initialize = $root.p2p.InitializeRequest.toObject(message.initialize, options);
                if (options.oneofs)
                    object.command = "initialize";
            }
            if (message.createWallet != null && message.hasOwnProperty("createWallet")) {
                object.createWallet = $root.p2p.CreateWalletRequest.toObject(message.createWallet, options);
                if (options.oneofs)
                    object.command = "createWallet";
            }
            if (message.restoreWallet != null && message.hasOwnProperty("restoreWallet")) {
                object.restoreWallet = $root.p2p.RestoreWalletRequest.toObject(message.restoreWallet, options);
                if (options.oneofs)
                    object.command = "restoreWallet";
            }
            if (message.loadWallet != null && message.hasOwnProperty("loadWallet")) {
                object.loadWallet = $root.p2p.LoadWalletRequest.toObject(message.loadWallet, options);
                if (options.oneofs)
                    object.command = "loadWallet";
            }
            if (message.getBalance != null && message.hasOwnProperty("getBalance")) {
                object.getBalance = $root.p2p.GetBalanceRequest.toObject(message.getBalance, options);
                if (options.oneofs)
                    object.command = "getBalance";
            }
            if (message.createTransaction != null && message.hasOwnProperty("createTransaction")) {
                object.createTransaction = $root.p2p.CreateTransactionRequest.toObject(message.createTransaction, options);
                if (options.oneofs)
                    object.command = "createTransaction";
            }
            if (message.toggleMiner != null && message.hasOwnProperty("toggleMiner")) {
                object.toggleMiner = $root.p2p.ToggleMinerRequest.toObject(message.toggleMiner, options);
                if (options.oneofs)
                    object.command = "toggleMiner";
            }
            if (message.getStatus != null && message.hasOwnProperty("getStatus")) {
                object.getStatus = $root.p2p.GetStatusRequest.toObject(message.getStatus, options);
                if (options.oneofs)
                    object.command = "getStatus";
            }
            if (message.getSupply != null && message.hasOwnProperty("getSupply")) {
                object.getSupply = $root.p2p.GetSupplyRequest.toObject(message.getSupply, options);
                if (options.oneofs)
                    object.command = "getSupply";
            }
            if (message.getPeers != null && message.hasOwnProperty("getPeers")) {
                object.getPeers = $root.p2p.GetPeersRequest.toObject(message.getPeers, options);
                if (options.oneofs)
                    object.command = "getPeers";
            }
            if (message.connectPeer != null && message.hasOwnProperty("connectPeer")) {
                object.connectPeer = $root.p2p.ConnectPeerRequest.toObject(message.connectPeer, options);
                if (options.oneofs)
                    object.command = "connectPeer";
            }
            if (message.syncTick != null && message.hasOwnProperty("syncTick")) {
                object.syncTick = $root.p2p.SyncTickRequest.toObject(message.syncTick, options);
                if (options.oneofs)
                    object.command = "syncTick";
            }
            if (message.swapInitiate != null && message.hasOwnProperty("swapInitiate")) {
                object.swapInitiate = $root.p2p.SwapInitiateRequest.toObject(message.swapInitiate, options);
                if (options.oneofs)
                    object.command = "swapInitiate";
            }
            if (message.swapList != null && message.hasOwnProperty("swapList")) {
                object.swapList = $root.p2p.SwapListRequest.toObject(message.swapList, options);
                if (options.oneofs)
                    object.command = "swapList";
            }
            if (message.swapRespond != null && message.hasOwnProperty("swapRespond")) {
                object.swapRespond = $root.p2p.SwapRespondRequest.toObject(message.swapRespond, options);
                if (options.oneofs)
                    object.command = "swapRespond";
            }
            if (message.swapClaim != null && message.hasOwnProperty("swapClaim")) {
                object.swapClaim = $root.p2p.SwapClaimRequest.toObject(message.swapClaim, options);
                if (options.oneofs)
                    object.command = "swapClaim";
            }
            if (message.swapRefund != null && message.hasOwnProperty("swapRefund")) {
                object.swapRefund = $root.p2p.SwapRefundRequest.toObject(message.swapRefund, options);
                if (options.oneofs)
                    object.command = "swapRefund";
            }
            if (message.channelOpen != null && message.hasOwnProperty("channelOpen")) {
                object.channelOpen = $root.p2p.ChannelOpenRequest.toObject(message.channelOpen, options);
                if (options.oneofs)
                    object.command = "channelOpen";
            }
            if (message.channelList != null && message.hasOwnProperty("channelList")) {
                object.channelList = $root.p2p.ChannelListRequest.toObject(message.channelList, options);
                if (options.oneofs)
                    object.command = "channelList";
            }
            if (message.channelAccept != null && message.hasOwnProperty("channelAccept")) {
                object.channelAccept = $root.p2p.ChannelAcceptRequest.toObject(message.channelAccept, options);
                if (options.oneofs)
                    object.command = "channelAccept";
            }
            if (message.channelFund != null && message.hasOwnProperty("channelFund")) {
                object.channelFund = $root.p2p.ChannelFundRequest.toObject(message.channelFund, options);
                if (options.oneofs)
                    object.command = "channelFund";
            }
            if (message.channelPay != null && message.hasOwnProperty("channelPay")) {
                object.channelPay = $root.p2p.ChannelPayRequest.toObject(message.channelPay, options);
                if (options.oneofs)
                    object.command = "channelPay";
            }
            if (message.channelClose != null && message.hasOwnProperty("channelClose")) {
                object.channelClose = $root.p2p.ChannelCloseRequest.toObject(message.channelClose, options);
                if (options.oneofs)
                    object.command = "channelClose";
            }
            return object;
        };

        /**
         * Converts this JSToRust_Command to JSON.
         * @function toJSON
         * @memberof p2p.JSToRust_Command
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JSToRust_Command.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for JSToRust_Command
         * @function getTypeUrl
         * @memberof p2p.JSToRust_Command
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        JSToRust_Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.JSToRust_Command";
        };

        return JSToRust_Command;
    })();

    p2p.JSToRust_NetworkEvent = (function() {

        /**
         * Properties of a JSToRust_NetworkEvent.
         * @memberof p2p
         * @interface IJSToRust_NetworkEvent
         * @property {p2p.IP2pMessageReceived|null} [p2pMessage] JSToRust_NetworkEvent p2pMessage
         * @property {p2p.IPeerConnected|null} [peerConnected] JSToRust_NetworkEvent peerConnected
         * @property {p2p.IPeerDisconnected|null} [peerDisconnected] JSToRust_NetworkEvent peerDisconnected
         * @property {p2p.IPeerVerified|null} [peerVerified] JSToRust_NetworkEvent peerVerified
         */

        /**
         * Constructs a new JSToRust_NetworkEvent.
         * @memberof p2p
         * @classdesc Represents a JSToRust_NetworkEvent.
         * @implements IJSToRust_NetworkEvent
         * @constructor
         * @param {p2p.IJSToRust_NetworkEvent=} [properties] Properties to set
         */
        function JSToRust_NetworkEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JSToRust_NetworkEvent p2pMessage.
         * @member {p2p.IP2pMessageReceived|null|undefined} p2pMessage
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         */
        JSToRust_NetworkEvent.prototype.p2pMessage = null;

        /**
         * JSToRust_NetworkEvent peerConnected.
         * @member {p2p.IPeerConnected|null|undefined} peerConnected
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         */
        JSToRust_NetworkEvent.prototype.peerConnected = null;

        /**
         * JSToRust_NetworkEvent peerDisconnected.
         * @member {p2p.IPeerDisconnected|null|undefined} peerDisconnected
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         */
        JSToRust_NetworkEvent.prototype.peerDisconnected = null;

        /**
         * JSToRust_NetworkEvent peerVerified.
         * @member {p2p.IPeerVerified|null|undefined} peerVerified
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         */
        JSToRust_NetworkEvent.prototype.peerVerified = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * JSToRust_NetworkEvent event.
         * @member {"p2pMessage"|"peerConnected"|"peerDisconnected"|"peerVerified"|undefined} event
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         */
        Object.defineProperty(JSToRust_NetworkEvent.prototype, "event", {
            get: $util.oneOfGetter($oneOfFields = ["p2pMessage", "peerConnected", "peerDisconnected", "peerVerified"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new JSToRust_NetworkEvent instance using the specified properties.
         * @function create
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {p2p.IJSToRust_NetworkEvent=} [properties] Properties to set
         * @returns {p2p.JSToRust_NetworkEvent} JSToRust_NetworkEvent instance
         */
        JSToRust_NetworkEvent.create = function create(properties) {
            return new JSToRust_NetworkEvent(properties);
        };

        /**
         * Encodes the specified JSToRust_NetworkEvent message. Does not implicitly {@link p2p.JSToRust_NetworkEvent.verify|verify} messages.
         * @function encode
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {p2p.IJSToRust_NetworkEvent} message JSToRust_NetworkEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JSToRust_NetworkEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p2pMessage != null && Object.hasOwnProperty.call(message, "p2pMessage"))
                $root.p2p.P2pMessageReceived.encode(message.p2pMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.peerConnected != null && Object.hasOwnProperty.call(message, "peerConnected"))
                $root.p2p.PeerConnected.encode(message.peerConnected, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.peerDisconnected != null && Object.hasOwnProperty.call(message, "peerDisconnected"))
                $root.p2p.PeerDisconnected.encode(message.peerDisconnected, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.peerVerified != null && Object.hasOwnProperty.call(message, "peerVerified"))
                $root.p2p.PeerVerified.encode(message.peerVerified, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JSToRust_NetworkEvent message, length delimited. Does not implicitly {@link p2p.JSToRust_NetworkEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {p2p.IJSToRust_NetworkEvent} message JSToRust_NetworkEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JSToRust_NetworkEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JSToRust_NetworkEvent message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.JSToRust_NetworkEvent} JSToRust_NetworkEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JSToRust_NetworkEvent.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.JSToRust_NetworkEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.p2pMessage = $root.p2p.P2pMessageReceived.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.peerConnected = $root.p2p.PeerConnected.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.peerDisconnected = $root.p2p.PeerDisconnected.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.peerVerified = $root.p2p.PeerVerified.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JSToRust_NetworkEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.JSToRust_NetworkEvent} JSToRust_NetworkEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JSToRust_NetworkEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JSToRust_NetworkEvent message.
         * @function verify
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JSToRust_NetworkEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.p2pMessage != null && message.hasOwnProperty("p2pMessage")) {
                properties.event = 1;
                {
                    var error = $root.p2p.P2pMessageReceived.verify(message.p2pMessage);
                    if (error)
                        return "p2pMessage." + error;
                }
            }
            if (message.peerConnected != null && message.hasOwnProperty("peerConnected")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    var error = $root.p2p.PeerConnected.verify(message.peerConnected);
                    if (error)
                        return "peerConnected." + error;
                }
            }
            if (message.peerDisconnected != null && message.hasOwnProperty("peerDisconnected")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    var error = $root.p2p.PeerDisconnected.verify(message.peerDisconnected);
                    if (error)
                        return "peerDisconnected." + error;
                }
            }
            if (message.peerVerified != null && message.hasOwnProperty("peerVerified")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    var error = $root.p2p.PeerVerified.verify(message.peerVerified);
                    if (error)
                        return "peerVerified." + error;
                }
            }
            return null;
        };

        /**
         * Creates a JSToRust_NetworkEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.JSToRust_NetworkEvent} JSToRust_NetworkEvent
         */
        JSToRust_NetworkEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.JSToRust_NetworkEvent)
                return object;
            var message = new $root.p2p.JSToRust_NetworkEvent();
            if (object.p2pMessage != null) {
                if (typeof object.p2pMessage !== "object")
                    throw TypeError(".p2p.JSToRust_NetworkEvent.p2pMessage: object expected");
                message.p2pMessage = $root.p2p.P2pMessageReceived.fromObject(object.p2pMessage);
            }
            if (object.peerConnected != null) {
                if (typeof object.peerConnected !== "object")
                    throw TypeError(".p2p.JSToRust_NetworkEvent.peerConnected: object expected");
                message.peerConnected = $root.p2p.PeerConnected.fromObject(object.peerConnected);
            }
            if (object.peerDisconnected != null) {
                if (typeof object.peerDisconnected !== "object")
                    throw TypeError(".p2p.JSToRust_NetworkEvent.peerDisconnected: object expected");
                message.peerDisconnected = $root.p2p.PeerDisconnected.fromObject(object.peerDisconnected);
            }
            if (object.peerVerified != null) {
                if (typeof object.peerVerified !== "object")
                    throw TypeError(".p2p.JSToRust_NetworkEvent.peerVerified: object expected");
                message.peerVerified = $root.p2p.PeerVerified.fromObject(object.peerVerified);
            }
            return message;
        };

        /**
         * Creates a plain object from a JSToRust_NetworkEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {p2p.JSToRust_NetworkEvent} message JSToRust_NetworkEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JSToRust_NetworkEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.p2pMessage != null && message.hasOwnProperty("p2pMessage")) {
                object.p2pMessage = $root.p2p.P2pMessageReceived.toObject(message.p2pMessage, options);
                if (options.oneofs)
                    object.event = "p2pMessage";
            }
            if (message.peerConnected != null && message.hasOwnProperty("peerConnected")) {
                object.peerConnected = $root.p2p.PeerConnected.toObject(message.peerConnected, options);
                if (options.oneofs)
                    object.event = "peerConnected";
            }
            if (message.peerDisconnected != null && message.hasOwnProperty("peerDisconnected")) {
                object.peerDisconnected = $root.p2p.PeerDisconnected.toObject(message.peerDisconnected, options);
                if (options.oneofs)
                    object.event = "peerDisconnected";
            }
            if (message.peerVerified != null && message.hasOwnProperty("peerVerified")) {
                object.peerVerified = $root.p2p.PeerVerified.toObject(message.peerVerified, options);
                if (options.oneofs)
                    object.event = "peerVerified";
            }
            return object;
        };

        /**
         * Converts this JSToRust_NetworkEvent to JSON.
         * @function toJSON
         * @memberof p2p.JSToRust_NetworkEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JSToRust_NetworkEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for JSToRust_NetworkEvent
         * @function getTypeUrl
         * @memberof p2p.JSToRust_NetworkEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        JSToRust_NetworkEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.JSToRust_NetworkEvent";
        };

        return JSToRust_NetworkEvent;
    })();

    p2p.RustToJs_CommandBatch = (function() {

        /**
         * Properties of a RustToJs_CommandBatch.
         * @memberof p2p
         * @interface IRustToJs_CommandBatch
         * @property {Array.<p2p.IRustCommand>|null} [commands] RustToJs_CommandBatch commands
         */

        /**
         * Constructs a new RustToJs_CommandBatch.
         * @memberof p2p
         * @classdesc Represents a RustToJs_CommandBatch.
         * @implements IRustToJs_CommandBatch
         * @constructor
         * @param {p2p.IRustToJs_CommandBatch=} [properties] Properties to set
         */
        function RustToJs_CommandBatch(properties) {
            this.commands = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RustToJs_CommandBatch commands.
         * @member {Array.<p2p.IRustCommand>} commands
         * @memberof p2p.RustToJs_CommandBatch
         * @instance
         */
        RustToJs_CommandBatch.prototype.commands = $util.emptyArray;

        /**
         * Creates a new RustToJs_CommandBatch instance using the specified properties.
         * @function create
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {p2p.IRustToJs_CommandBatch=} [properties] Properties to set
         * @returns {p2p.RustToJs_CommandBatch} RustToJs_CommandBatch instance
         */
        RustToJs_CommandBatch.create = function create(properties) {
            return new RustToJs_CommandBatch(properties);
        };

        /**
         * Encodes the specified RustToJs_CommandBatch message. Does not implicitly {@link p2p.RustToJs_CommandBatch.verify|verify} messages.
         * @function encode
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {p2p.IRustToJs_CommandBatch} message RustToJs_CommandBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RustToJs_CommandBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commands != null && message.commands.length)
                for (var i = 0; i < message.commands.length; ++i)
                    $root.p2p.RustCommand.encode(message.commands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RustToJs_CommandBatch message, length delimited. Does not implicitly {@link p2p.RustToJs_CommandBatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {p2p.IRustToJs_CommandBatch} message RustToJs_CommandBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RustToJs_CommandBatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RustToJs_CommandBatch message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.RustToJs_CommandBatch} RustToJs_CommandBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RustToJs_CommandBatch.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.RustToJs_CommandBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.commands && message.commands.length))
                            message.commands = [];
                        message.commands.push($root.p2p.RustCommand.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RustToJs_CommandBatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.RustToJs_CommandBatch} RustToJs_CommandBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RustToJs_CommandBatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RustToJs_CommandBatch message.
         * @function verify
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RustToJs_CommandBatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.commands != null && message.hasOwnProperty("commands")) {
                if (!Array.isArray(message.commands))
                    return "commands: array expected";
                for (var i = 0; i < message.commands.length; ++i) {
                    var error = $root.p2p.RustCommand.verify(message.commands[i]);
                    if (error)
                        return "commands." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RustToJs_CommandBatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.RustToJs_CommandBatch} RustToJs_CommandBatch
         */
        RustToJs_CommandBatch.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.RustToJs_CommandBatch)
                return object;
            var message = new $root.p2p.RustToJs_CommandBatch();
            if (object.commands) {
                if (!Array.isArray(object.commands))
                    throw TypeError(".p2p.RustToJs_CommandBatch.commands: array expected");
                message.commands = [];
                for (var i = 0; i < object.commands.length; ++i) {
                    if (typeof object.commands[i] !== "object")
                        throw TypeError(".p2p.RustToJs_CommandBatch.commands: object expected");
                    message.commands[i] = $root.p2p.RustCommand.fromObject(object.commands[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RustToJs_CommandBatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {p2p.RustToJs_CommandBatch} message RustToJs_CommandBatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RustToJs_CommandBatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.commands = [];
            if (message.commands && message.commands.length) {
                object.commands = [];
                for (var j = 0; j < message.commands.length; ++j)
                    object.commands[j] = $root.p2p.RustCommand.toObject(message.commands[j], options);
            }
            return object;
        };

        /**
         * Converts this RustToJs_CommandBatch to JSON.
         * @function toJSON
         * @memberof p2p.RustToJs_CommandBatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RustToJs_CommandBatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RustToJs_CommandBatch
         * @function getTypeUrl
         * @memberof p2p.RustToJs_CommandBatch
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RustToJs_CommandBatch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.RustToJs_CommandBatch";
        };

        return RustToJs_CommandBatch;
    })();

    p2p.RustCommand = (function() {

        /**
         * Properties of a RustCommand.
         * @memberof p2p
         * @interface IRustCommand
         * @property {p2p.ILogMessage|null} [logMessage] RustCommand logMessage
         * @property {p2p.IPublishP2pMessage|null} [p2pPublish] RustCommand p2pPublish
         * @property {p2p.ISendDirectP2pMessage|null} [p2pSendDirect] RustCommand p2pSendDirect
         * @property {p2p.IHangUpPeer|null} [p2pHangUp] RustCommand p2pHangUp
         * @property {p2p.IUpdateUiBalance|null} [updateUiBalance] RustCommand updateUiBalance
         * @property {p2p.IUpdateUiMinerStatus|null} [updateUiMinerStatus] RustCommand updateUiMinerStatus
         * @property {p2p.IUpdateUiSyncProgress|null} [updateUiSyncProgress] RustCommand updateUiSyncProgress
         * @property {p2p.IUiNetworkInitialized|null} [uiNetworkInitialized] RustCommand uiNetworkInitialized
         * @property {p2p.IUiWalletLoaded|null} [uiWalletLoaded] RustCommand uiWalletLoaded
         * @property {p2p.IUiPeerList|null} [uiPeerList] RustCommand uiPeerList
         * @property {p2p.IUiTotalSupply|null} [uiTotalSupply] RustCommand uiTotalSupply
         */

        /**
         * Constructs a new RustCommand.
         * @memberof p2p
         * @classdesc Represents a RustCommand.
         * @implements IRustCommand
         * @constructor
         * @param {p2p.IRustCommand=} [properties] Properties to set
         */
        function RustCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RustCommand logMessage.
         * @member {p2p.ILogMessage|null|undefined} logMessage
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.logMessage = null;

        /**
         * RustCommand p2pPublish.
         * @member {p2p.IPublishP2pMessage|null|undefined} p2pPublish
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.p2pPublish = null;

        /**
         * RustCommand p2pSendDirect.
         * @member {p2p.ISendDirectP2pMessage|null|undefined} p2pSendDirect
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.p2pSendDirect = null;

        /**
         * RustCommand p2pHangUp.
         * @member {p2p.IHangUpPeer|null|undefined} p2pHangUp
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.p2pHangUp = null;

        /**
         * RustCommand updateUiBalance.
         * @member {p2p.IUpdateUiBalance|null|undefined} updateUiBalance
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.updateUiBalance = null;

        /**
         * RustCommand updateUiMinerStatus.
         * @member {p2p.IUpdateUiMinerStatus|null|undefined} updateUiMinerStatus
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.updateUiMinerStatus = null;

        /**
         * RustCommand updateUiSyncProgress.
         * @member {p2p.IUpdateUiSyncProgress|null|undefined} updateUiSyncProgress
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.updateUiSyncProgress = null;

        /**
         * RustCommand uiNetworkInitialized.
         * @member {p2p.IUiNetworkInitialized|null|undefined} uiNetworkInitialized
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.uiNetworkInitialized = null;

        /**
         * RustCommand uiWalletLoaded.
         * @member {p2p.IUiWalletLoaded|null|undefined} uiWalletLoaded
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.uiWalletLoaded = null;

        /**
         * RustCommand uiPeerList.
         * @member {p2p.IUiPeerList|null|undefined} uiPeerList
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.uiPeerList = null;

        /**
         * RustCommand uiTotalSupply.
         * @member {p2p.IUiTotalSupply|null|undefined} uiTotalSupply
         * @memberof p2p.RustCommand
         * @instance
         */
        RustCommand.prototype.uiTotalSupply = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * RustCommand command.
         * @member {"logMessage"|"p2pPublish"|"p2pSendDirect"|"p2pHangUp"|"updateUiBalance"|"updateUiMinerStatus"|"updateUiSyncProgress"|"uiNetworkInitialized"|"uiWalletLoaded"|"uiPeerList"|"uiTotalSupply"|undefined} command
         * @memberof p2p.RustCommand
         * @instance
         */
        Object.defineProperty(RustCommand.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["logMessage", "p2pPublish", "p2pSendDirect", "p2pHangUp", "updateUiBalance", "updateUiMinerStatus", "updateUiSyncProgress", "uiNetworkInitialized", "uiWalletLoaded", "uiPeerList", "uiTotalSupply"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RustCommand instance using the specified properties.
         * @function create
         * @memberof p2p.RustCommand
         * @static
         * @param {p2p.IRustCommand=} [properties] Properties to set
         * @returns {p2p.RustCommand} RustCommand instance
         */
        RustCommand.create = function create(properties) {
            return new RustCommand(properties);
        };

        /**
         * Encodes the specified RustCommand message. Does not implicitly {@link p2p.RustCommand.verify|verify} messages.
         * @function encode
         * @memberof p2p.RustCommand
         * @static
         * @param {p2p.IRustCommand} message RustCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RustCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logMessage != null && Object.hasOwnProperty.call(message, "logMessage"))
                $root.p2p.LogMessage.encode(message.logMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.p2pPublish != null && Object.hasOwnProperty.call(message, "p2pPublish"))
                $root.p2p.PublishP2pMessage.encode(message.p2pPublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p2pSendDirect != null && Object.hasOwnProperty.call(message, "p2pSendDirect"))
                $root.p2p.SendDirectP2pMessage.encode(message.p2pSendDirect, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.p2pHangUp != null && Object.hasOwnProperty.call(message, "p2pHangUp"))
                $root.p2p.HangUpPeer.encode(message.p2pHangUp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.updateUiBalance != null && Object.hasOwnProperty.call(message, "updateUiBalance"))
                $root.p2p.UpdateUiBalance.encode(message.updateUiBalance, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.updateUiMinerStatus != null && Object.hasOwnProperty.call(message, "updateUiMinerStatus"))
                $root.p2p.UpdateUiMinerStatus.encode(message.updateUiMinerStatus, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.updateUiSyncProgress != null && Object.hasOwnProperty.call(message, "updateUiSyncProgress"))
                $root.p2p.UpdateUiSyncProgress.encode(message.updateUiSyncProgress, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.uiNetworkInitialized != null && Object.hasOwnProperty.call(message, "uiNetworkInitialized"))
                $root.p2p.UiNetworkInitialized.encode(message.uiNetworkInitialized, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.uiWalletLoaded != null && Object.hasOwnProperty.call(message, "uiWalletLoaded"))
                $root.p2p.UiWalletLoaded.encode(message.uiWalletLoaded, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.uiPeerList != null && Object.hasOwnProperty.call(message, "uiPeerList"))
                $root.p2p.UiPeerList.encode(message.uiPeerList, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.uiTotalSupply != null && Object.hasOwnProperty.call(message, "uiTotalSupply"))
                $root.p2p.UiTotalSupply.encode(message.uiTotalSupply, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RustCommand message, length delimited. Does not implicitly {@link p2p.RustCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.RustCommand
         * @static
         * @param {p2p.IRustCommand} message RustCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RustCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RustCommand message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.RustCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.RustCommand} RustCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RustCommand.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.RustCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.logMessage = $root.p2p.LogMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.p2pPublish = $root.p2p.PublishP2pMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.p2pSendDirect = $root.p2p.SendDirectP2pMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.p2pHangUp = $root.p2p.HangUpPeer.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.updateUiBalance = $root.p2p.UpdateUiBalance.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.updateUiMinerStatus = $root.p2p.UpdateUiMinerStatus.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.updateUiSyncProgress = $root.p2p.UpdateUiSyncProgress.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.uiNetworkInitialized = $root.p2p.UiNetworkInitialized.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.uiWalletLoaded = $root.p2p.UiWalletLoaded.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.uiPeerList = $root.p2p.UiPeerList.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.uiTotalSupply = $root.p2p.UiTotalSupply.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RustCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.RustCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.RustCommand} RustCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RustCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RustCommand message.
         * @function verify
         * @memberof p2p.RustCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RustCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.logMessage != null && message.hasOwnProperty("logMessage")) {
                properties.command = 1;
                {
                    var error = $root.p2p.LogMessage.verify(message.logMessage);
                    if (error)
                        return "logMessage." + error;
                }
            }
            if (message.p2pPublish != null && message.hasOwnProperty("p2pPublish")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.PublishP2pMessage.verify(message.p2pPublish);
                    if (error)
                        return "p2pPublish." + error;
                }
            }
            if (message.p2pSendDirect != null && message.hasOwnProperty("p2pSendDirect")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.SendDirectP2pMessage.verify(message.p2pSendDirect);
                    if (error)
                        return "p2pSendDirect." + error;
                }
            }
            if (message.p2pHangUp != null && message.hasOwnProperty("p2pHangUp")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.HangUpPeer.verify(message.p2pHangUp);
                    if (error)
                        return "p2pHangUp." + error;
                }
            }
            if (message.updateUiBalance != null && message.hasOwnProperty("updateUiBalance")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UpdateUiBalance.verify(message.updateUiBalance);
                    if (error)
                        return "updateUiBalance." + error;
                }
            }
            if (message.updateUiMinerStatus != null && message.hasOwnProperty("updateUiMinerStatus")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UpdateUiMinerStatus.verify(message.updateUiMinerStatus);
                    if (error)
                        return "updateUiMinerStatus." + error;
                }
            }
            if (message.updateUiSyncProgress != null && message.hasOwnProperty("updateUiSyncProgress")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UpdateUiSyncProgress.verify(message.updateUiSyncProgress);
                    if (error)
                        return "updateUiSyncProgress." + error;
                }
            }
            if (message.uiNetworkInitialized != null && message.hasOwnProperty("uiNetworkInitialized")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UiNetworkInitialized.verify(message.uiNetworkInitialized);
                    if (error)
                        return "uiNetworkInitialized." + error;
                }
            }
            if (message.uiWalletLoaded != null && message.hasOwnProperty("uiWalletLoaded")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UiWalletLoaded.verify(message.uiWalletLoaded);
                    if (error)
                        return "uiWalletLoaded." + error;
                }
            }
            if (message.uiPeerList != null && message.hasOwnProperty("uiPeerList")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UiPeerList.verify(message.uiPeerList);
                    if (error)
                        return "uiPeerList." + error;
                }
            }
            if (message.uiTotalSupply != null && message.hasOwnProperty("uiTotalSupply")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                {
                    var error = $root.p2p.UiTotalSupply.verify(message.uiTotalSupply);
                    if (error)
                        return "uiTotalSupply." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RustCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.RustCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.RustCommand} RustCommand
         */
        RustCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.RustCommand)
                return object;
            var message = new $root.p2p.RustCommand();
            if (object.logMessage != null) {
                if (typeof object.logMessage !== "object")
                    throw TypeError(".p2p.RustCommand.logMessage: object expected");
                message.logMessage = $root.p2p.LogMessage.fromObject(object.logMessage);
            }
            if (object.p2pPublish != null) {
                if (typeof object.p2pPublish !== "object")
                    throw TypeError(".p2p.RustCommand.p2pPublish: object expected");
                message.p2pPublish = $root.p2p.PublishP2pMessage.fromObject(object.p2pPublish);
            }
            if (object.p2pSendDirect != null) {
                if (typeof object.p2pSendDirect !== "object")
                    throw TypeError(".p2p.RustCommand.p2pSendDirect: object expected");
                message.p2pSendDirect = $root.p2p.SendDirectP2pMessage.fromObject(object.p2pSendDirect);
            }
            if (object.p2pHangUp != null) {
                if (typeof object.p2pHangUp !== "object")
                    throw TypeError(".p2p.RustCommand.p2pHangUp: object expected");
                message.p2pHangUp = $root.p2p.HangUpPeer.fromObject(object.p2pHangUp);
            }
            if (object.updateUiBalance != null) {
                if (typeof object.updateUiBalance !== "object")
                    throw TypeError(".p2p.RustCommand.updateUiBalance: object expected");
                message.updateUiBalance = $root.p2p.UpdateUiBalance.fromObject(object.updateUiBalance);
            }
            if (object.updateUiMinerStatus != null) {
                if (typeof object.updateUiMinerStatus !== "object")
                    throw TypeError(".p2p.RustCommand.updateUiMinerStatus: object expected");
                message.updateUiMinerStatus = $root.p2p.UpdateUiMinerStatus.fromObject(object.updateUiMinerStatus);
            }
            if (object.updateUiSyncProgress != null) {
                if (typeof object.updateUiSyncProgress !== "object")
                    throw TypeError(".p2p.RustCommand.updateUiSyncProgress: object expected");
                message.updateUiSyncProgress = $root.p2p.UpdateUiSyncProgress.fromObject(object.updateUiSyncProgress);
            }
            if (object.uiNetworkInitialized != null) {
                if (typeof object.uiNetworkInitialized !== "object")
                    throw TypeError(".p2p.RustCommand.uiNetworkInitialized: object expected");
                message.uiNetworkInitialized = $root.p2p.UiNetworkInitialized.fromObject(object.uiNetworkInitialized);
            }
            if (object.uiWalletLoaded != null) {
                if (typeof object.uiWalletLoaded !== "object")
                    throw TypeError(".p2p.RustCommand.uiWalletLoaded: object expected");
                message.uiWalletLoaded = $root.p2p.UiWalletLoaded.fromObject(object.uiWalletLoaded);
            }
            if (object.uiPeerList != null) {
                if (typeof object.uiPeerList !== "object")
                    throw TypeError(".p2p.RustCommand.uiPeerList: object expected");
                message.uiPeerList = $root.p2p.UiPeerList.fromObject(object.uiPeerList);
            }
            if (object.uiTotalSupply != null) {
                if (typeof object.uiTotalSupply !== "object")
                    throw TypeError(".p2p.RustCommand.uiTotalSupply: object expected");
                message.uiTotalSupply = $root.p2p.UiTotalSupply.fromObject(object.uiTotalSupply);
            }
            return message;
        };

        /**
         * Creates a plain object from a RustCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.RustCommand
         * @static
         * @param {p2p.RustCommand} message RustCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RustCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.logMessage != null && message.hasOwnProperty("logMessage")) {
                object.logMessage = $root.p2p.LogMessage.toObject(message.logMessage, options);
                if (options.oneofs)
                    object.command = "logMessage";
            }
            if (message.p2pPublish != null && message.hasOwnProperty("p2pPublish")) {
                object.p2pPublish = $root.p2p.PublishP2pMessage.toObject(message.p2pPublish, options);
                if (options.oneofs)
                    object.command = "p2pPublish";
            }
            if (message.p2pSendDirect != null && message.hasOwnProperty("p2pSendDirect")) {
                object.p2pSendDirect = $root.p2p.SendDirectP2pMessage.toObject(message.p2pSendDirect, options);
                if (options.oneofs)
                    object.command = "p2pSendDirect";
            }
            if (message.p2pHangUp != null && message.hasOwnProperty("p2pHangUp")) {
                object.p2pHangUp = $root.p2p.HangUpPeer.toObject(message.p2pHangUp, options);
                if (options.oneofs)
                    object.command = "p2pHangUp";
            }
            if (message.updateUiBalance != null && message.hasOwnProperty("updateUiBalance")) {
                object.updateUiBalance = $root.p2p.UpdateUiBalance.toObject(message.updateUiBalance, options);
                if (options.oneofs)
                    object.command = "updateUiBalance";
            }
            if (message.updateUiMinerStatus != null && message.hasOwnProperty("updateUiMinerStatus")) {
                object.updateUiMinerStatus = $root.p2p.UpdateUiMinerStatus.toObject(message.updateUiMinerStatus, options);
                if (options.oneofs)
                    object.command = "updateUiMinerStatus";
            }
            if (message.updateUiSyncProgress != null && message.hasOwnProperty("updateUiSyncProgress")) {
                object.updateUiSyncProgress = $root.p2p.UpdateUiSyncProgress.toObject(message.updateUiSyncProgress, options);
                if (options.oneofs)
                    object.command = "updateUiSyncProgress";
            }
            if (message.uiNetworkInitialized != null && message.hasOwnProperty("uiNetworkInitialized")) {
                object.uiNetworkInitialized = $root.p2p.UiNetworkInitialized.toObject(message.uiNetworkInitialized, options);
                if (options.oneofs)
                    object.command = "uiNetworkInitialized";
            }
            if (message.uiWalletLoaded != null && message.hasOwnProperty("uiWalletLoaded")) {
                object.uiWalletLoaded = $root.p2p.UiWalletLoaded.toObject(message.uiWalletLoaded, options);
                if (options.oneofs)
                    object.command = "uiWalletLoaded";
            }
            if (message.uiPeerList != null && message.hasOwnProperty("uiPeerList")) {
                object.uiPeerList = $root.p2p.UiPeerList.toObject(message.uiPeerList, options);
                if (options.oneofs)
                    object.command = "uiPeerList";
            }
            if (message.uiTotalSupply != null && message.hasOwnProperty("uiTotalSupply")) {
                object.uiTotalSupply = $root.p2p.UiTotalSupply.toObject(message.uiTotalSupply, options);
                if (options.oneofs)
                    object.command = "uiTotalSupply";
            }
            return object;
        };

        /**
         * Converts this RustCommand to JSON.
         * @function toJSON
         * @memberof p2p.RustCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RustCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RustCommand
         * @function getTypeUrl
         * @memberof p2p.RustCommand
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RustCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.RustCommand";
        };

        return RustCommand;
    })();

    p2p.InitializeRequest = (function() {

        /**
         * Properties of an InitializeRequest.
         * @memberof p2p
         * @interface IInitializeRequest
         */

        /**
         * Constructs a new InitializeRequest.
         * @memberof p2p
         * @classdesc Represents an InitializeRequest.
         * @implements IInitializeRequest
         * @constructor
         * @param {p2p.IInitializeRequest=} [properties] Properties to set
         */
        function InitializeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InitializeRequest instance using the specified properties.
         * @function create
         * @memberof p2p.InitializeRequest
         * @static
         * @param {p2p.IInitializeRequest=} [properties] Properties to set
         * @returns {p2p.InitializeRequest} InitializeRequest instance
         */
        InitializeRequest.create = function create(properties) {
            return new InitializeRequest(properties);
        };

        /**
         * Encodes the specified InitializeRequest message. Does not implicitly {@link p2p.InitializeRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.InitializeRequest
         * @static
         * @param {p2p.IInitializeRequest} message InitializeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitializeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InitializeRequest message, length delimited. Does not implicitly {@link p2p.InitializeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.InitializeRequest
         * @static
         * @param {p2p.IInitializeRequest} message InitializeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitializeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitializeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.InitializeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.InitializeRequest} InitializeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitializeRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.InitializeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitializeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.InitializeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.InitializeRequest} InitializeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitializeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitializeRequest message.
         * @function verify
         * @memberof p2p.InitializeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitializeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InitializeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.InitializeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.InitializeRequest} InitializeRequest
         */
        InitializeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.InitializeRequest)
                return object;
            return new $root.p2p.InitializeRequest();
        };

        /**
         * Creates a plain object from an InitializeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.InitializeRequest
         * @static
         * @param {p2p.InitializeRequest} message InitializeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitializeRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InitializeRequest to JSON.
         * @function toJSON
         * @memberof p2p.InitializeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitializeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InitializeRequest
         * @function getTypeUrl
         * @memberof p2p.InitializeRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InitializeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.InitializeRequest";
        };

        return InitializeRequest;
    })();

    p2p.CreateWalletRequest = (function() {

        /**
         * Properties of a CreateWalletRequest.
         * @memberof p2p
         * @interface ICreateWalletRequest
         * @property {string|null} [walletId] CreateWalletRequest walletId
         */

        /**
         * Constructs a new CreateWalletRequest.
         * @memberof p2p
         * @classdesc Represents a CreateWalletRequest.
         * @implements ICreateWalletRequest
         * @constructor
         * @param {p2p.ICreateWalletRequest=} [properties] Properties to set
         */
        function CreateWalletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateWalletRequest walletId.
         * @member {string} walletId
         * @memberof p2p.CreateWalletRequest
         * @instance
         */
        CreateWalletRequest.prototype.walletId = "";

        /**
         * Creates a new CreateWalletRequest instance using the specified properties.
         * @function create
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {p2p.ICreateWalletRequest=} [properties] Properties to set
         * @returns {p2p.CreateWalletRequest} CreateWalletRequest instance
         */
        CreateWalletRequest.create = function create(properties) {
            return new CreateWalletRequest(properties);
        };

        /**
         * Encodes the specified CreateWalletRequest message. Does not implicitly {@link p2p.CreateWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {p2p.ICreateWalletRequest} message CreateWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            return writer;
        };

        /**
         * Encodes the specified CreateWalletRequest message, length delimited. Does not implicitly {@link p2p.CreateWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {p2p.ICreateWalletRequest} message CreateWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.CreateWalletRequest} CreateWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateWalletRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.CreateWalletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.CreateWalletRequest} CreateWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateWalletRequest message.
         * @function verify
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            return null;
        };

        /**
         * Creates a CreateWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.CreateWalletRequest} CreateWalletRequest
         */
        CreateWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.CreateWalletRequest)
                return object;
            var message = new $root.p2p.CreateWalletRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            return message;
        };

        /**
         * Creates a plain object from a CreateWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {p2p.CreateWalletRequest} message CreateWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.walletId = "";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            return object;
        };

        /**
         * Converts this CreateWalletRequest to JSON.
         * @function toJSON
         * @memberof p2p.CreateWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateWalletRequest
         * @function getTypeUrl
         * @memberof p2p.CreateWalletRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateWalletRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.CreateWalletRequest";
        };

        return CreateWalletRequest;
    })();

    p2p.RestoreWalletRequest = (function() {

        /**
         * Properties of a RestoreWalletRequest.
         * @memberof p2p
         * @interface IRestoreWalletRequest
         * @property {string|null} [walletId] RestoreWalletRequest walletId
         * @property {string|null} [phrase] RestoreWalletRequest phrase
         */

        /**
         * Constructs a new RestoreWalletRequest.
         * @memberof p2p
         * @classdesc Represents a RestoreWalletRequest.
         * @implements IRestoreWalletRequest
         * @constructor
         * @param {p2p.IRestoreWalletRequest=} [properties] Properties to set
         */
        function RestoreWalletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RestoreWalletRequest walletId.
         * @member {string} walletId
         * @memberof p2p.RestoreWalletRequest
         * @instance
         */
        RestoreWalletRequest.prototype.walletId = "";

        /**
         * RestoreWalletRequest phrase.
         * @member {string} phrase
         * @memberof p2p.RestoreWalletRequest
         * @instance
         */
        RestoreWalletRequest.prototype.phrase = "";

        /**
         * Creates a new RestoreWalletRequest instance using the specified properties.
         * @function create
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {p2p.IRestoreWalletRequest=} [properties] Properties to set
         * @returns {p2p.RestoreWalletRequest} RestoreWalletRequest instance
         */
        RestoreWalletRequest.create = function create(properties) {
            return new RestoreWalletRequest(properties);
        };

        /**
         * Encodes the specified RestoreWalletRequest message. Does not implicitly {@link p2p.RestoreWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {p2p.IRestoreWalletRequest} message RestoreWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.phrase != null && Object.hasOwnProperty.call(message, "phrase"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phrase);
            return writer;
        };

        /**
         * Encodes the specified RestoreWalletRequest message, length delimited. Does not implicitly {@link p2p.RestoreWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {p2p.IRestoreWalletRequest} message RestoreWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.RestoreWalletRequest} RestoreWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreWalletRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.RestoreWalletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.phrase = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.RestoreWalletRequest} RestoreWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreWalletRequest message.
         * @function verify
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.phrase != null && message.hasOwnProperty("phrase"))
                if (!$util.isString(message.phrase))
                    return "phrase: string expected";
            return null;
        };

        /**
         * Creates a RestoreWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.RestoreWalletRequest} RestoreWalletRequest
         */
        RestoreWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.RestoreWalletRequest)
                return object;
            var message = new $root.p2p.RestoreWalletRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.phrase != null)
                message.phrase = String(object.phrase);
            return message;
        };

        /**
         * Creates a plain object from a RestoreWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {p2p.RestoreWalletRequest} message RestoreWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.phrase = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.phrase != null && message.hasOwnProperty("phrase"))
                object.phrase = message.phrase;
            return object;
        };

        /**
         * Converts this RestoreWalletRequest to JSON.
         * @function toJSON
         * @memberof p2p.RestoreWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RestoreWalletRequest
         * @function getTypeUrl
         * @memberof p2p.RestoreWalletRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RestoreWalletRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.RestoreWalletRequest";
        };

        return RestoreWalletRequest;
    })();

    p2p.LoadWalletRequest = (function() {

        /**
         * Properties of a LoadWalletRequest.
         * @memberof p2p
         * @interface ILoadWalletRequest
         * @property {string|null} [walletId] LoadWalletRequest walletId
         */

        /**
         * Constructs a new LoadWalletRequest.
         * @memberof p2p
         * @classdesc Represents a LoadWalletRequest.
         * @implements ILoadWalletRequest
         * @constructor
         * @param {p2p.ILoadWalletRequest=} [properties] Properties to set
         */
        function LoadWalletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoadWalletRequest walletId.
         * @member {string} walletId
         * @memberof p2p.LoadWalletRequest
         * @instance
         */
        LoadWalletRequest.prototype.walletId = "";

        /**
         * Creates a new LoadWalletRequest instance using the specified properties.
         * @function create
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {p2p.ILoadWalletRequest=} [properties] Properties to set
         * @returns {p2p.LoadWalletRequest} LoadWalletRequest instance
         */
        LoadWalletRequest.create = function create(properties) {
            return new LoadWalletRequest(properties);
        };

        /**
         * Encodes the specified LoadWalletRequest message. Does not implicitly {@link p2p.LoadWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {p2p.ILoadWalletRequest} message LoadWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            return writer;
        };

        /**
         * Encodes the specified LoadWalletRequest message, length delimited. Does not implicitly {@link p2p.LoadWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {p2p.ILoadWalletRequest} message LoadWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoadWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.LoadWalletRequest} LoadWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadWalletRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.LoadWalletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoadWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.LoadWalletRequest} LoadWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoadWalletRequest message.
         * @function verify
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoadWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            return null;
        };

        /**
         * Creates a LoadWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.LoadWalletRequest} LoadWalletRequest
         */
        LoadWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.LoadWalletRequest)
                return object;
            var message = new $root.p2p.LoadWalletRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            return message;
        };

        /**
         * Creates a plain object from a LoadWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {p2p.LoadWalletRequest} message LoadWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoadWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.walletId = "";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            return object;
        };

        /**
         * Converts this LoadWalletRequest to JSON.
         * @function toJSON
         * @memberof p2p.LoadWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoadWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LoadWalletRequest
         * @function getTypeUrl
         * @memberof p2p.LoadWalletRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LoadWalletRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.LoadWalletRequest";
        };

        return LoadWalletRequest;
    })();

    p2p.GetBalanceRequest = (function() {

        /**
         * Properties of a GetBalanceRequest.
         * @memberof p2p
         * @interface IGetBalanceRequest
         * @property {string|null} [walletId] GetBalanceRequest walletId
         */

        /**
         * Constructs a new GetBalanceRequest.
         * @memberof p2p
         * @classdesc Represents a GetBalanceRequest.
         * @implements IGetBalanceRequest
         * @constructor
         * @param {p2p.IGetBalanceRequest=} [properties] Properties to set
         */
        function GetBalanceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBalanceRequest walletId.
         * @member {string} walletId
         * @memberof p2p.GetBalanceRequest
         * @instance
         */
        GetBalanceRequest.prototype.walletId = "";

        /**
         * Creates a new GetBalanceRequest instance using the specified properties.
         * @function create
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {p2p.IGetBalanceRequest=} [properties] Properties to set
         * @returns {p2p.GetBalanceRequest} GetBalanceRequest instance
         */
        GetBalanceRequest.create = function create(properties) {
            return new GetBalanceRequest(properties);
        };

        /**
         * Encodes the specified GetBalanceRequest message. Does not implicitly {@link p2p.GetBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {p2p.IGetBalanceRequest} message GetBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            return writer;
        };

        /**
         * Encodes the specified GetBalanceRequest message, length delimited. Does not implicitly {@link p2p.GetBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {p2p.IGetBalanceRequest} message GetBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.GetBalanceRequest} GetBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBalanceRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.GetBalanceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.GetBalanceRequest} GetBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBalanceRequest message.
         * @function verify
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            return null;
        };

        /**
         * Creates a GetBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.GetBalanceRequest} GetBalanceRequest
         */
        GetBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.GetBalanceRequest)
                return object;
            var message = new $root.p2p.GetBalanceRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            return message;
        };

        /**
         * Creates a plain object from a GetBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {p2p.GetBalanceRequest} message GetBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBalanceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.walletId = "";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            return object;
        };

        /**
         * Converts this GetBalanceRequest to JSON.
         * @function toJSON
         * @memberof p2p.GetBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetBalanceRequest
         * @function getTypeUrl
         * @memberof p2p.GetBalanceRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBalanceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.GetBalanceRequest";
        };

        return GetBalanceRequest;
    })();

    p2p.CreateTransactionRequest = (function() {

        /**
         * Properties of a CreateTransactionRequest.
         * @memberof p2p
         * @interface ICreateTransactionRequest
         * @property {string|null} [fromWalletId] CreateTransactionRequest fromWalletId
         * @property {string|null} [toAddress] CreateTransactionRequest toAddress
         * @property {number|Long|null} [amount] CreateTransactionRequest amount
         * @property {number|Long|null} [fee] CreateTransactionRequest fee
         */

        /**
         * Constructs a new CreateTransactionRequest.
         * @memberof p2p
         * @classdesc Represents a CreateTransactionRequest.
         * @implements ICreateTransactionRequest
         * @constructor
         * @param {p2p.ICreateTransactionRequest=} [properties] Properties to set
         */
        function CreateTransactionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTransactionRequest fromWalletId.
         * @member {string} fromWalletId
         * @memberof p2p.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.fromWalletId = "";

        /**
         * CreateTransactionRequest toAddress.
         * @member {string} toAddress
         * @memberof p2p.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.toAddress = "";

        /**
         * CreateTransactionRequest amount.
         * @member {number|Long} amount
         * @memberof p2p.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CreateTransactionRequest fee.
         * @member {number|Long} fee
         * @memberof p2p.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new CreateTransactionRequest instance using the specified properties.
         * @function create
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {p2p.ICreateTransactionRequest=} [properties] Properties to set
         * @returns {p2p.CreateTransactionRequest} CreateTransactionRequest instance
         */
        CreateTransactionRequest.create = function create(properties) {
            return new CreateTransactionRequest(properties);
        };

        /**
         * Encodes the specified CreateTransactionRequest message. Does not implicitly {@link p2p.CreateTransactionRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {p2p.ICreateTransactionRequest} message CreateTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fromWalletId != null && Object.hasOwnProperty.call(message, "fromWalletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromWalletId);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fee);
            return writer;
        };

        /**
         * Encodes the specified CreateTransactionRequest message, length delimited. Does not implicitly {@link p2p.CreateTransactionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {p2p.ICreateTransactionRequest} message CreateTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTransactionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.CreateTransactionRequest} CreateTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.CreateTransactionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fromWalletId = reader.string();
                        break;
                    }
                case 2: {
                        message.toAddress = reader.string();
                        break;
                    }
                case 3: {
                        message.amount = reader.uint64();
                        break;
                    }
                case 4: {
                        message.fee = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTransactionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.CreateTransactionRequest} CreateTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTransactionRequest message.
         * @function verify
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTransactionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fromWalletId != null && message.hasOwnProperty("fromWalletId"))
                if (!$util.isString(message.fromWalletId))
                    return "fromWalletId: string expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!$util.isString(message.toAddress))
                    return "toAddress: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            return null;
        };

        /**
         * Creates a CreateTransactionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.CreateTransactionRequest} CreateTransactionRequest
         */
        CreateTransactionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.CreateTransactionRequest)
                return object;
            var message = new $root.p2p.CreateTransactionRequest();
            if (object.fromWalletId != null)
                message.fromWalletId = String(object.fromWalletId);
            if (object.toAddress != null)
                message.toAddress = String(object.toAddress);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a CreateTransactionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {p2p.CreateTransactionRequest} message CreateTransactionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTransactionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fromWalletId = "";
                object.toAddress = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
            }
            if (message.fromWalletId != null && message.hasOwnProperty("fromWalletId"))
                object.fromWalletId = message.fromWalletId;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = message.toAddress;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
            return object;
        };

        /**
         * Converts this CreateTransactionRequest to JSON.
         * @function toJSON
         * @memberof p2p.CreateTransactionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTransactionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CreateTransactionRequest
         * @function getTypeUrl
         * @memberof p2p.CreateTransactionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CreateTransactionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.CreateTransactionRequest";
        };

        return CreateTransactionRequest;
    })();

    p2p.ToggleMinerRequest = (function() {

        /**
         * Properties of a ToggleMinerRequest.
         * @memberof p2p
         * @interface IToggleMinerRequest
         * @property {string|null} [minerId] ToggleMinerRequest minerId
         */

        /**
         * Constructs a new ToggleMinerRequest.
         * @memberof p2p
         * @classdesc Represents a ToggleMinerRequest.
         * @implements IToggleMinerRequest
         * @constructor
         * @param {p2p.IToggleMinerRequest=} [properties] Properties to set
         */
        function ToggleMinerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ToggleMinerRequest minerId.
         * @member {string} minerId
         * @memberof p2p.ToggleMinerRequest
         * @instance
         */
        ToggleMinerRequest.prototype.minerId = "";

        /**
         * Creates a new ToggleMinerRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {p2p.IToggleMinerRequest=} [properties] Properties to set
         * @returns {p2p.ToggleMinerRequest} ToggleMinerRequest instance
         */
        ToggleMinerRequest.create = function create(properties) {
            return new ToggleMinerRequest(properties);
        };

        /**
         * Encodes the specified ToggleMinerRequest message. Does not implicitly {@link p2p.ToggleMinerRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {p2p.IToggleMinerRequest} message ToggleMinerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleMinerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minerId != null && Object.hasOwnProperty.call(message, "minerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.minerId);
            return writer;
        };

        /**
         * Encodes the specified ToggleMinerRequest message, length delimited. Does not implicitly {@link p2p.ToggleMinerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {p2p.IToggleMinerRequest} message ToggleMinerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToggleMinerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ToggleMinerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ToggleMinerRequest} ToggleMinerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleMinerRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ToggleMinerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.minerId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ToggleMinerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ToggleMinerRequest} ToggleMinerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToggleMinerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ToggleMinerRequest message.
         * @function verify
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ToggleMinerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minerId != null && message.hasOwnProperty("minerId"))
                if (!$util.isString(message.minerId))
                    return "minerId: string expected";
            return null;
        };

        /**
         * Creates a ToggleMinerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ToggleMinerRequest} ToggleMinerRequest
         */
        ToggleMinerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ToggleMinerRequest)
                return object;
            var message = new $root.p2p.ToggleMinerRequest();
            if (object.minerId != null)
                message.minerId = String(object.minerId);
            return message;
        };

        /**
         * Creates a plain object from a ToggleMinerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {p2p.ToggleMinerRequest} message ToggleMinerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ToggleMinerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.minerId = "";
            if (message.minerId != null && message.hasOwnProperty("minerId"))
                object.minerId = message.minerId;
            return object;
        };

        /**
         * Converts this ToggleMinerRequest to JSON.
         * @function toJSON
         * @memberof p2p.ToggleMinerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ToggleMinerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ToggleMinerRequest
         * @function getTypeUrl
         * @memberof p2p.ToggleMinerRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ToggleMinerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ToggleMinerRequest";
        };

        return ToggleMinerRequest;
    })();

    p2p.GetStatusRequest = (function() {

        /**
         * Properties of a GetStatusRequest.
         * @memberof p2p
         * @interface IGetStatusRequest
         */

        /**
         * Constructs a new GetStatusRequest.
         * @memberof p2p
         * @classdesc Represents a GetStatusRequest.
         * @implements IGetStatusRequest
         * @constructor
         * @param {p2p.IGetStatusRequest=} [properties] Properties to set
         */
        function GetStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetStatusRequest instance using the specified properties.
         * @function create
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {p2p.IGetStatusRequest=} [properties] Properties to set
         * @returns {p2p.GetStatusRequest} GetStatusRequest instance
         */
        GetStatusRequest.create = function create(properties) {
            return new GetStatusRequest(properties);
        };

        /**
         * Encodes the specified GetStatusRequest message. Does not implicitly {@link p2p.GetStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {p2p.IGetStatusRequest} message GetStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetStatusRequest message, length delimited. Does not implicitly {@link p2p.GetStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {p2p.IGetStatusRequest} message GetStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.GetStatusRequest} GetStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetStatusRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.GetStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.GetStatusRequest} GetStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetStatusRequest message.
         * @function verify
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.GetStatusRequest} GetStatusRequest
         */
        GetStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.GetStatusRequest)
                return object;
            return new $root.p2p.GetStatusRequest();
        };

        /**
         * Creates a plain object from a GetStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {p2p.GetStatusRequest} message GetStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetStatusRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetStatusRequest to JSON.
         * @function toJSON
         * @memberof p2p.GetStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetStatusRequest
         * @function getTypeUrl
         * @memberof p2p.GetStatusRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetStatusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.GetStatusRequest";
        };

        return GetStatusRequest;
    })();

    p2p.GetSupplyRequest = (function() {

        /**
         * Properties of a GetSupplyRequest.
         * @memberof p2p
         * @interface IGetSupplyRequest
         */

        /**
         * Constructs a new GetSupplyRequest.
         * @memberof p2p
         * @classdesc Represents a GetSupplyRequest.
         * @implements IGetSupplyRequest
         * @constructor
         * @param {p2p.IGetSupplyRequest=} [properties] Properties to set
         */
        function GetSupplyRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetSupplyRequest instance using the specified properties.
         * @function create
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {p2p.IGetSupplyRequest=} [properties] Properties to set
         * @returns {p2p.GetSupplyRequest} GetSupplyRequest instance
         */
        GetSupplyRequest.create = function create(properties) {
            return new GetSupplyRequest(properties);
        };

        /**
         * Encodes the specified GetSupplyRequest message. Does not implicitly {@link p2p.GetSupplyRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {p2p.IGetSupplyRequest} message GetSupplyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSupplyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetSupplyRequest message, length delimited. Does not implicitly {@link p2p.GetSupplyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {p2p.IGetSupplyRequest} message GetSupplyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSupplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSupplyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.GetSupplyRequest} GetSupplyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSupplyRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.GetSupplyRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSupplyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.GetSupplyRequest} GetSupplyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSupplyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSupplyRequest message.
         * @function verify
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSupplyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetSupplyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.GetSupplyRequest} GetSupplyRequest
         */
        GetSupplyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.GetSupplyRequest)
                return object;
            return new $root.p2p.GetSupplyRequest();
        };

        /**
         * Creates a plain object from a GetSupplyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {p2p.GetSupplyRequest} message GetSupplyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSupplyRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetSupplyRequest to JSON.
         * @function toJSON
         * @memberof p2p.GetSupplyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSupplyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSupplyRequest
         * @function getTypeUrl
         * @memberof p2p.GetSupplyRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSupplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.GetSupplyRequest";
        };

        return GetSupplyRequest;
    })();

    p2p.GetPeersRequest = (function() {

        /**
         * Properties of a GetPeersRequest.
         * @memberof p2p
         * @interface IGetPeersRequest
         */

        /**
         * Constructs a new GetPeersRequest.
         * @memberof p2p
         * @classdesc Represents a GetPeersRequest.
         * @implements IGetPeersRequest
         * @constructor
         * @param {p2p.IGetPeersRequest=} [properties] Properties to set
         */
        function GetPeersRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetPeersRequest instance using the specified properties.
         * @function create
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {p2p.IGetPeersRequest=} [properties] Properties to set
         * @returns {p2p.GetPeersRequest} GetPeersRequest instance
         */
        GetPeersRequest.create = function create(properties) {
            return new GetPeersRequest(properties);
        };

        /**
         * Encodes the specified GetPeersRequest message. Does not implicitly {@link p2p.GetPeersRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {p2p.IGetPeersRequest} message GetPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPeersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetPeersRequest message, length delimited. Does not implicitly {@link p2p.GetPeersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {p2p.IGetPeersRequest} message GetPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPeersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.GetPeersRequest} GetPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPeersRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.GetPeersRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPeersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.GetPeersRequest} GetPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPeersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPeersRequest message.
         * @function verify
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPeersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetPeersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.GetPeersRequest} GetPeersRequest
         */
        GetPeersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.GetPeersRequest)
                return object;
            return new $root.p2p.GetPeersRequest();
        };

        /**
         * Creates a plain object from a GetPeersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {p2p.GetPeersRequest} message GetPeersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPeersRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetPeersRequest to JSON.
         * @function toJSON
         * @memberof p2p.GetPeersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPeersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetPeersRequest
         * @function getTypeUrl
         * @memberof p2p.GetPeersRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetPeersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.GetPeersRequest";
        };

        return GetPeersRequest;
    })();

    p2p.ConnectPeerRequest = (function() {

        /**
         * Properties of a ConnectPeerRequest.
         * @memberof p2p
         * @interface IConnectPeerRequest
         * @property {string|null} [multiaddr] ConnectPeerRequest multiaddr
         */

        /**
         * Constructs a new ConnectPeerRequest.
         * @memberof p2p
         * @classdesc Represents a ConnectPeerRequest.
         * @implements IConnectPeerRequest
         * @constructor
         * @param {p2p.IConnectPeerRequest=} [properties] Properties to set
         */
        function ConnectPeerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectPeerRequest multiaddr.
         * @member {string} multiaddr
         * @memberof p2p.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.multiaddr = "";

        /**
         * Creates a new ConnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {p2p.IConnectPeerRequest=} [properties] Properties to set
         * @returns {p2p.ConnectPeerRequest} ConnectPeerRequest instance
         */
        ConnectPeerRequest.create = function create(properties) {
            return new ConnectPeerRequest(properties);
        };

        /**
         * Encodes the specified ConnectPeerRequest message. Does not implicitly {@link p2p.ConnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {p2p.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.multiaddr != null && Object.hasOwnProperty.call(message, "multiaddr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.multiaddr);
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerRequest message, length delimited. Does not implicitly {@link p2p.ConnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {p2p.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ConnectPeerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.multiaddr = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerRequest message.
         * @function verify
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.multiaddr != null && message.hasOwnProperty("multiaddr"))
                if (!$util.isString(message.multiaddr))
                    return "multiaddr: string expected";
            return null;
        };

        /**
         * Creates a ConnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ConnectPeerRequest} ConnectPeerRequest
         */
        ConnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ConnectPeerRequest)
                return object;
            var message = new $root.p2p.ConnectPeerRequest();
            if (object.multiaddr != null)
                message.multiaddr = String(object.multiaddr);
            return message;
        };

        /**
         * Creates a plain object from a ConnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {p2p.ConnectPeerRequest} message ConnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.multiaddr = "";
            if (message.multiaddr != null && message.hasOwnProperty("multiaddr"))
                object.multiaddr = message.multiaddr;
            return object;
        };

        /**
         * Converts this ConnectPeerRequest to JSON.
         * @function toJSON
         * @memberof p2p.ConnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConnectPeerRequest
         * @function getTypeUrl
         * @memberof p2p.ConnectPeerRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConnectPeerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ConnectPeerRequest";
        };

        return ConnectPeerRequest;
    })();

    p2p.SyncTickRequest = (function() {

        /**
         * Properties of a SyncTickRequest.
         * @memberof p2p
         * @interface ISyncTickRequest
         */

        /**
         * Constructs a new SyncTickRequest.
         * @memberof p2p
         * @classdesc Represents a SyncTickRequest.
         * @implements ISyncTickRequest
         * @constructor
         * @param {p2p.ISyncTickRequest=} [properties] Properties to set
         */
        function SyncTickRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SyncTickRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {p2p.ISyncTickRequest=} [properties] Properties to set
         * @returns {p2p.SyncTickRequest} SyncTickRequest instance
         */
        SyncTickRequest.create = function create(properties) {
            return new SyncTickRequest(properties);
        };

        /**
         * Encodes the specified SyncTickRequest message. Does not implicitly {@link p2p.SyncTickRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {p2p.ISyncTickRequest} message SyncTickRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncTickRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SyncTickRequest message, length delimited. Does not implicitly {@link p2p.SyncTickRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {p2p.ISyncTickRequest} message SyncTickRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncTickRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncTickRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SyncTickRequest} SyncTickRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncTickRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SyncTickRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncTickRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SyncTickRequest} SyncTickRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncTickRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncTickRequest message.
         * @function verify
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncTickRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SyncTickRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SyncTickRequest} SyncTickRequest
         */
        SyncTickRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SyncTickRequest)
                return object;
            return new $root.p2p.SyncTickRequest();
        };

        /**
         * Creates a plain object from a SyncTickRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {p2p.SyncTickRequest} message SyncTickRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncTickRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SyncTickRequest to JSON.
         * @function toJSON
         * @memberof p2p.SyncTickRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncTickRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncTickRequest
         * @function getTypeUrl
         * @memberof p2p.SyncTickRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SyncTickRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SyncTickRequest";
        };

        return SyncTickRequest;
    })();

    p2p.SwapInitiateRequest = (function() {

        /**
         * Properties of a SwapInitiateRequest.
         * @memberof p2p
         * @interface ISwapInitiateRequest
         * @property {string|null} [walletId] SwapInitiateRequest walletId
         * @property {string|null} [counterpartyPubkey] SwapInitiateRequest counterpartyPubkey
         * @property {number|Long|null} [plbAmount] SwapInitiateRequest plbAmount
         * @property {number|Long|null} [btcAmount] SwapInitiateRequest btcAmount
         * @property {number|Long|null} [timeoutBlocks] SwapInitiateRequest timeoutBlocks
         */

        /**
         * Constructs a new SwapInitiateRequest.
         * @memberof p2p
         * @classdesc Represents a SwapInitiateRequest.
         * @implements ISwapInitiateRequest
         * @constructor
         * @param {p2p.ISwapInitiateRequest=} [properties] Properties to set
         */
        function SwapInitiateRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwapInitiateRequest walletId.
         * @member {string} walletId
         * @memberof p2p.SwapInitiateRequest
         * @instance
         */
        SwapInitiateRequest.prototype.walletId = "";

        /**
         * SwapInitiateRequest counterpartyPubkey.
         * @member {string} counterpartyPubkey
         * @memberof p2p.SwapInitiateRequest
         * @instance
         */
        SwapInitiateRequest.prototype.counterpartyPubkey = "";

        /**
         * SwapInitiateRequest plbAmount.
         * @member {number|Long} plbAmount
         * @memberof p2p.SwapInitiateRequest
         * @instance
         */
        SwapInitiateRequest.prototype.plbAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SwapInitiateRequest btcAmount.
         * @member {number|Long} btcAmount
         * @memberof p2p.SwapInitiateRequest
         * @instance
         */
        SwapInitiateRequest.prototype.btcAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SwapInitiateRequest timeoutBlocks.
         * @member {number|Long} timeoutBlocks
         * @memberof p2p.SwapInitiateRequest
         * @instance
         */
        SwapInitiateRequest.prototype.timeoutBlocks = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SwapInitiateRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {p2p.ISwapInitiateRequest=} [properties] Properties to set
         * @returns {p2p.SwapInitiateRequest} SwapInitiateRequest instance
         */
        SwapInitiateRequest.create = function create(properties) {
            return new SwapInitiateRequest(properties);
        };

        /**
         * Encodes the specified SwapInitiateRequest message. Does not implicitly {@link p2p.SwapInitiateRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {p2p.ISwapInitiateRequest} message SwapInitiateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapInitiateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.counterpartyPubkey != null && Object.hasOwnProperty.call(message, "counterpartyPubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.counterpartyPubkey);
            if (message.plbAmount != null && Object.hasOwnProperty.call(message, "plbAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.plbAmount);
            if (message.btcAmount != null && Object.hasOwnProperty.call(message, "btcAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.btcAmount);
            if (message.timeoutBlocks != null && Object.hasOwnProperty.call(message, "timeoutBlocks"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timeoutBlocks);
            return writer;
        };

        /**
         * Encodes the specified SwapInitiateRequest message, length delimited. Does not implicitly {@link p2p.SwapInitiateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {p2p.ISwapInitiateRequest} message SwapInitiateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapInitiateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapInitiateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapInitiateRequest} SwapInitiateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapInitiateRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapInitiateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.counterpartyPubkey = reader.string();
                        break;
                    }
                case 3: {
                        message.plbAmount = reader.uint64();
                        break;
                    }
                case 4: {
                        message.btcAmount = reader.uint64();
                        break;
                    }
                case 5: {
                        message.timeoutBlocks = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapInitiateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapInitiateRequest} SwapInitiateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapInitiateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapInitiateRequest message.
         * @function verify
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapInitiateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.counterpartyPubkey != null && message.hasOwnProperty("counterpartyPubkey"))
                if (!$util.isString(message.counterpartyPubkey))
                    return "counterpartyPubkey: string expected";
            if (message.plbAmount != null && message.hasOwnProperty("plbAmount"))
                if (!$util.isInteger(message.plbAmount) && !(message.plbAmount && $util.isInteger(message.plbAmount.low) && $util.isInteger(message.plbAmount.high)))
                    return "plbAmount: integer|Long expected";
            if (message.btcAmount != null && message.hasOwnProperty("btcAmount"))
                if (!$util.isInteger(message.btcAmount) && !(message.btcAmount && $util.isInteger(message.btcAmount.low) && $util.isInteger(message.btcAmount.high)))
                    return "btcAmount: integer|Long expected";
            if (message.timeoutBlocks != null && message.hasOwnProperty("timeoutBlocks"))
                if (!$util.isInteger(message.timeoutBlocks) && !(message.timeoutBlocks && $util.isInteger(message.timeoutBlocks.low) && $util.isInteger(message.timeoutBlocks.high)))
                    return "timeoutBlocks: integer|Long expected";
            return null;
        };

        /**
         * Creates a SwapInitiateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapInitiateRequest} SwapInitiateRequest
         */
        SwapInitiateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapInitiateRequest)
                return object;
            var message = new $root.p2p.SwapInitiateRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.counterpartyPubkey != null)
                message.counterpartyPubkey = String(object.counterpartyPubkey);
            if (object.plbAmount != null)
                if ($util.Long)
                    (message.plbAmount = $util.Long.fromValue(object.plbAmount)).unsigned = true;
                else if (typeof object.plbAmount === "string")
                    message.plbAmount = parseInt(object.plbAmount, 10);
                else if (typeof object.plbAmount === "number")
                    message.plbAmount = object.plbAmount;
                else if (typeof object.plbAmount === "object")
                    message.plbAmount = new $util.LongBits(object.plbAmount.low >>> 0, object.plbAmount.high >>> 0).toNumber(true);
            if (object.btcAmount != null)
                if ($util.Long)
                    (message.btcAmount = $util.Long.fromValue(object.btcAmount)).unsigned = true;
                else if (typeof object.btcAmount === "string")
                    message.btcAmount = parseInt(object.btcAmount, 10);
                else if (typeof object.btcAmount === "number")
                    message.btcAmount = object.btcAmount;
                else if (typeof object.btcAmount === "object")
                    message.btcAmount = new $util.LongBits(object.btcAmount.low >>> 0, object.btcAmount.high >>> 0).toNumber(true);
            if (object.timeoutBlocks != null)
                if ($util.Long)
                    (message.timeoutBlocks = $util.Long.fromValue(object.timeoutBlocks)).unsigned = true;
                else if (typeof object.timeoutBlocks === "string")
                    message.timeoutBlocks = parseInt(object.timeoutBlocks, 10);
                else if (typeof object.timeoutBlocks === "number")
                    message.timeoutBlocks = object.timeoutBlocks;
                else if (typeof object.timeoutBlocks === "object")
                    message.timeoutBlocks = new $util.LongBits(object.timeoutBlocks.low >>> 0, object.timeoutBlocks.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SwapInitiateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {p2p.SwapInitiateRequest} message SwapInitiateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapInitiateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.counterpartyPubkey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.plbAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.plbAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.btcAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.btcAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timeoutBlocks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeoutBlocks = options.longs === String ? "0" : 0;
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.counterpartyPubkey != null && message.hasOwnProperty("counterpartyPubkey"))
                object.counterpartyPubkey = message.counterpartyPubkey;
            if (message.plbAmount != null && message.hasOwnProperty("plbAmount"))
                if (typeof message.plbAmount === "number")
                    object.plbAmount = options.longs === String ? String(message.plbAmount) : message.plbAmount;
                else
                    object.plbAmount = options.longs === String ? $util.Long.prototype.toString.call(message.plbAmount) : options.longs === Number ? new $util.LongBits(message.plbAmount.low >>> 0, message.plbAmount.high >>> 0).toNumber(true) : message.plbAmount;
            if (message.btcAmount != null && message.hasOwnProperty("btcAmount"))
                if (typeof message.btcAmount === "number")
                    object.btcAmount = options.longs === String ? String(message.btcAmount) : message.btcAmount;
                else
                    object.btcAmount = options.longs === String ? $util.Long.prototype.toString.call(message.btcAmount) : options.longs === Number ? new $util.LongBits(message.btcAmount.low >>> 0, message.btcAmount.high >>> 0).toNumber(true) : message.btcAmount;
            if (message.timeoutBlocks != null && message.hasOwnProperty("timeoutBlocks"))
                if (typeof message.timeoutBlocks === "number")
                    object.timeoutBlocks = options.longs === String ? String(message.timeoutBlocks) : message.timeoutBlocks;
                else
                    object.timeoutBlocks = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutBlocks) : options.longs === Number ? new $util.LongBits(message.timeoutBlocks.low >>> 0, message.timeoutBlocks.high >>> 0).toNumber(true) : message.timeoutBlocks;
            return object;
        };

        /**
         * Converts this SwapInitiateRequest to JSON.
         * @function toJSON
         * @memberof p2p.SwapInitiateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapInitiateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapInitiateRequest
         * @function getTypeUrl
         * @memberof p2p.SwapInitiateRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapInitiateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapInitiateRequest";
        };

        return SwapInitiateRequest;
    })();

    p2p.SwapListRequest = (function() {

        /**
         * Properties of a SwapListRequest.
         * @memberof p2p
         * @interface ISwapListRequest
         */

        /**
         * Constructs a new SwapListRequest.
         * @memberof p2p
         * @classdesc Represents a SwapListRequest.
         * @implements ISwapListRequest
         * @constructor
         * @param {p2p.ISwapListRequest=} [properties] Properties to set
         */
        function SwapListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SwapListRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SwapListRequest
         * @static
         * @param {p2p.ISwapListRequest=} [properties] Properties to set
         * @returns {p2p.SwapListRequest} SwapListRequest instance
         */
        SwapListRequest.create = function create(properties) {
            return new SwapListRequest(properties);
        };

        /**
         * Encodes the specified SwapListRequest message. Does not implicitly {@link p2p.SwapListRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapListRequest
         * @static
         * @param {p2p.ISwapListRequest} message SwapListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SwapListRequest message, length delimited. Does not implicitly {@link p2p.SwapListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapListRequest
         * @static
         * @param {p2p.ISwapListRequest} message SwapListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapListRequest} SwapListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapListRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapListRequest} SwapListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapListRequest message.
         * @function verify
         * @memberof p2p.SwapListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SwapListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapListRequest} SwapListRequest
         */
        SwapListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapListRequest)
                return object;
            return new $root.p2p.SwapListRequest();
        };

        /**
         * Creates a plain object from a SwapListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapListRequest
         * @static
         * @param {p2p.SwapListRequest} message SwapListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapListRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SwapListRequest to JSON.
         * @function toJSON
         * @memberof p2p.SwapListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapListRequest
         * @function getTypeUrl
         * @memberof p2p.SwapListRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapListRequest";
        };

        return SwapListRequest;
    })();

    p2p.SwapRespondRequest = (function() {

        /**
         * Properties of a SwapRespondRequest.
         * @memberof p2p
         * @interface ISwapRespondRequest
         * @property {string|null} [walletId] SwapRespondRequest walletId
         * @property {string|null} [swapId] SwapRespondRequest swapId
         * @property {string|null} [btcAddress] SwapRespondRequest btcAddress
         * @property {string|null} [btcTxid] SwapRespondRequest btcTxid
         * @property {number|null} [btcVout] SwapRespondRequest btcVout
         */

        /**
         * Constructs a new SwapRespondRequest.
         * @memberof p2p
         * @classdesc Represents a SwapRespondRequest.
         * @implements ISwapRespondRequest
         * @constructor
         * @param {p2p.ISwapRespondRequest=} [properties] Properties to set
         */
        function SwapRespondRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwapRespondRequest walletId.
         * @member {string} walletId
         * @memberof p2p.SwapRespondRequest
         * @instance
         */
        SwapRespondRequest.prototype.walletId = "";

        /**
         * SwapRespondRequest swapId.
         * @member {string} swapId
         * @memberof p2p.SwapRespondRequest
         * @instance
         */
        SwapRespondRequest.prototype.swapId = "";

        /**
         * SwapRespondRequest btcAddress.
         * @member {string} btcAddress
         * @memberof p2p.SwapRespondRequest
         * @instance
         */
        SwapRespondRequest.prototype.btcAddress = "";

        /**
         * SwapRespondRequest btcTxid.
         * @member {string} btcTxid
         * @memberof p2p.SwapRespondRequest
         * @instance
         */
        SwapRespondRequest.prototype.btcTxid = "";

        /**
         * SwapRespondRequest btcVout.
         * @member {number} btcVout
         * @memberof p2p.SwapRespondRequest
         * @instance
         */
        SwapRespondRequest.prototype.btcVout = 0;

        /**
         * Creates a new SwapRespondRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {p2p.ISwapRespondRequest=} [properties] Properties to set
         * @returns {p2p.SwapRespondRequest} SwapRespondRequest instance
         */
        SwapRespondRequest.create = function create(properties) {
            return new SwapRespondRequest(properties);
        };

        /**
         * Encodes the specified SwapRespondRequest message. Does not implicitly {@link p2p.SwapRespondRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {p2p.ISwapRespondRequest} message SwapRespondRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapRespondRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.swapId);
            if (message.btcAddress != null && Object.hasOwnProperty.call(message, "btcAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.btcAddress);
            if (message.btcTxid != null && Object.hasOwnProperty.call(message, "btcTxid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.btcTxid);
            if (message.btcVout != null && Object.hasOwnProperty.call(message, "btcVout"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.btcVout);
            return writer;
        };

        /**
         * Encodes the specified SwapRespondRequest message, length delimited. Does not implicitly {@link p2p.SwapRespondRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {p2p.ISwapRespondRequest} message SwapRespondRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapRespondRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapRespondRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapRespondRequest} SwapRespondRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapRespondRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapRespondRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.swapId = reader.string();
                        break;
                    }
                case 3: {
                        message.btcAddress = reader.string();
                        break;
                    }
                case 4: {
                        message.btcTxid = reader.string();
                        break;
                    }
                case 5: {
                        message.btcVout = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapRespondRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapRespondRequest} SwapRespondRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapRespondRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapRespondRequest message.
         * @function verify
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapRespondRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!$util.isString(message.swapId))
                    return "swapId: string expected";
            if (message.btcAddress != null && message.hasOwnProperty("btcAddress"))
                if (!$util.isString(message.btcAddress))
                    return "btcAddress: string expected";
            if (message.btcTxid != null && message.hasOwnProperty("btcTxid"))
                if (!$util.isString(message.btcTxid))
                    return "btcTxid: string expected";
            if (message.btcVout != null && message.hasOwnProperty("btcVout"))
                if (!$util.isInteger(message.btcVout))
                    return "btcVout: integer expected";
            return null;
        };

        /**
         * Creates a SwapRespondRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapRespondRequest} SwapRespondRequest
         */
        SwapRespondRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapRespondRequest)
                return object;
            var message = new $root.p2p.SwapRespondRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.swapId != null)
                message.swapId = String(object.swapId);
            if (object.btcAddress != null)
                message.btcAddress = String(object.btcAddress);
            if (object.btcTxid != null)
                message.btcTxid = String(object.btcTxid);
            if (object.btcVout != null)
                message.btcVout = object.btcVout >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SwapRespondRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {p2p.SwapRespondRequest} message SwapRespondRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapRespondRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.swapId = "";
                object.btcAddress = "";
                object.btcTxid = "";
                object.btcVout = 0;
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = message.swapId;
            if (message.btcAddress != null && message.hasOwnProperty("btcAddress"))
                object.btcAddress = message.btcAddress;
            if (message.btcTxid != null && message.hasOwnProperty("btcTxid"))
                object.btcTxid = message.btcTxid;
            if (message.btcVout != null && message.hasOwnProperty("btcVout"))
                object.btcVout = message.btcVout;
            return object;
        };

        /**
         * Converts this SwapRespondRequest to JSON.
         * @function toJSON
         * @memberof p2p.SwapRespondRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapRespondRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapRespondRequest
         * @function getTypeUrl
         * @memberof p2p.SwapRespondRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapRespondRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapRespondRequest";
        };

        return SwapRespondRequest;
    })();

    p2p.SwapClaimRequest = (function() {

        /**
         * Properties of a SwapClaimRequest.
         * @memberof p2p
         * @interface ISwapClaimRequest
         * @property {string|null} [walletId] SwapClaimRequest walletId
         * @property {string|null} [swapId] SwapClaimRequest swapId
         * @property {string|null} [adaptorSecretHex] SwapClaimRequest adaptorSecretHex
         */

        /**
         * Constructs a new SwapClaimRequest.
         * @memberof p2p
         * @classdesc Represents a SwapClaimRequest.
         * @implements ISwapClaimRequest
         * @constructor
         * @param {p2p.ISwapClaimRequest=} [properties] Properties to set
         */
        function SwapClaimRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwapClaimRequest walletId.
         * @member {string} walletId
         * @memberof p2p.SwapClaimRequest
         * @instance
         */
        SwapClaimRequest.prototype.walletId = "";

        /**
         * SwapClaimRequest swapId.
         * @member {string} swapId
         * @memberof p2p.SwapClaimRequest
         * @instance
         */
        SwapClaimRequest.prototype.swapId = "";

        /**
         * SwapClaimRequest adaptorSecretHex.
         * @member {string} adaptorSecretHex
         * @memberof p2p.SwapClaimRequest
         * @instance
         */
        SwapClaimRequest.prototype.adaptorSecretHex = "";

        /**
         * Creates a new SwapClaimRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {p2p.ISwapClaimRequest=} [properties] Properties to set
         * @returns {p2p.SwapClaimRequest} SwapClaimRequest instance
         */
        SwapClaimRequest.create = function create(properties) {
            return new SwapClaimRequest(properties);
        };

        /**
         * Encodes the specified SwapClaimRequest message. Does not implicitly {@link p2p.SwapClaimRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {p2p.ISwapClaimRequest} message SwapClaimRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapClaimRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.swapId);
            if (message.adaptorSecretHex != null && Object.hasOwnProperty.call(message, "adaptorSecretHex"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.adaptorSecretHex);
            return writer;
        };

        /**
         * Encodes the specified SwapClaimRequest message, length delimited. Does not implicitly {@link p2p.SwapClaimRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {p2p.ISwapClaimRequest} message SwapClaimRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapClaimRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapClaimRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapClaimRequest} SwapClaimRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapClaimRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapClaimRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.swapId = reader.string();
                        break;
                    }
                case 3: {
                        message.adaptorSecretHex = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapClaimRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapClaimRequest} SwapClaimRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapClaimRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapClaimRequest message.
         * @function verify
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapClaimRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!$util.isString(message.swapId))
                    return "swapId: string expected";
            if (message.adaptorSecretHex != null && message.hasOwnProperty("adaptorSecretHex"))
                if (!$util.isString(message.adaptorSecretHex))
                    return "adaptorSecretHex: string expected";
            return null;
        };

        /**
         * Creates a SwapClaimRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapClaimRequest} SwapClaimRequest
         */
        SwapClaimRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapClaimRequest)
                return object;
            var message = new $root.p2p.SwapClaimRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.swapId != null)
                message.swapId = String(object.swapId);
            if (object.adaptorSecretHex != null)
                message.adaptorSecretHex = String(object.adaptorSecretHex);
            return message;
        };

        /**
         * Creates a plain object from a SwapClaimRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {p2p.SwapClaimRequest} message SwapClaimRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapClaimRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.swapId = "";
                object.adaptorSecretHex = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = message.swapId;
            if (message.adaptorSecretHex != null && message.hasOwnProperty("adaptorSecretHex"))
                object.adaptorSecretHex = message.adaptorSecretHex;
            return object;
        };

        /**
         * Converts this SwapClaimRequest to JSON.
         * @function toJSON
         * @memberof p2p.SwapClaimRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapClaimRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapClaimRequest
         * @function getTypeUrl
         * @memberof p2p.SwapClaimRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapClaimRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapClaimRequest";
        };

        return SwapClaimRequest;
    })();

    p2p.SwapRefundRequest = (function() {

        /**
         * Properties of a SwapRefundRequest.
         * @memberof p2p
         * @interface ISwapRefundRequest
         * @property {string|null} [walletId] SwapRefundRequest walletId
         * @property {string|null} [swapId] SwapRefundRequest swapId
         */

        /**
         * Constructs a new SwapRefundRequest.
         * @memberof p2p
         * @classdesc Represents a SwapRefundRequest.
         * @implements ISwapRefundRequest
         * @constructor
         * @param {p2p.ISwapRefundRequest=} [properties] Properties to set
         */
        function SwapRefundRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwapRefundRequest walletId.
         * @member {string} walletId
         * @memberof p2p.SwapRefundRequest
         * @instance
         */
        SwapRefundRequest.prototype.walletId = "";

        /**
         * SwapRefundRequest swapId.
         * @member {string} swapId
         * @memberof p2p.SwapRefundRequest
         * @instance
         */
        SwapRefundRequest.prototype.swapId = "";

        /**
         * Creates a new SwapRefundRequest instance using the specified properties.
         * @function create
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {p2p.ISwapRefundRequest=} [properties] Properties to set
         * @returns {p2p.SwapRefundRequest} SwapRefundRequest instance
         */
        SwapRefundRequest.create = function create(properties) {
            return new SwapRefundRequest(properties);
        };

        /**
         * Encodes the specified SwapRefundRequest message. Does not implicitly {@link p2p.SwapRefundRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {p2p.ISwapRefundRequest} message SwapRefundRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapRefundRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.swapId != null && Object.hasOwnProperty.call(message, "swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.swapId);
            return writer;
        };

        /**
         * Encodes the specified SwapRefundRequest message, length delimited. Does not implicitly {@link p2p.SwapRefundRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {p2p.ISwapRefundRequest} message SwapRefundRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwapRefundRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwapRefundRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SwapRefundRequest} SwapRefundRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapRefundRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SwapRefundRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.swapId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwapRefundRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SwapRefundRequest} SwapRefundRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwapRefundRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwapRefundRequest message.
         * @function verify
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwapRefundRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!$util.isString(message.swapId))
                    return "swapId: string expected";
            return null;
        };

        /**
         * Creates a SwapRefundRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SwapRefundRequest} SwapRefundRequest
         */
        SwapRefundRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SwapRefundRequest)
                return object;
            var message = new $root.p2p.SwapRefundRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.swapId != null)
                message.swapId = String(object.swapId);
            return message;
        };

        /**
         * Creates a plain object from a SwapRefundRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {p2p.SwapRefundRequest} message SwapRefundRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SwapRefundRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.swapId = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = message.swapId;
            return object;
        };

        /**
         * Converts this SwapRefundRequest to JSON.
         * @function toJSON
         * @memberof p2p.SwapRefundRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SwapRefundRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SwapRefundRequest
         * @function getTypeUrl
         * @memberof p2p.SwapRefundRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SwapRefundRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SwapRefundRequest";
        };

        return SwapRefundRequest;
    })();

    p2p.ChannelOpenRequest = (function() {

        /**
         * Properties of a ChannelOpenRequest.
         * @memberof p2p
         * @interface IChannelOpenRequest
         * @property {string|null} [walletId] ChannelOpenRequest walletId
         * @property {string|null} [counterpartyPubkey] ChannelOpenRequest counterpartyPubkey
         * @property {number|Long|null} [myAmount] ChannelOpenRequest myAmount
         * @property {number|Long|null} [theirAmount] ChannelOpenRequest theirAmount
         */

        /**
         * Constructs a new ChannelOpenRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelOpenRequest.
         * @implements IChannelOpenRequest
         * @constructor
         * @param {p2p.IChannelOpenRequest=} [properties] Properties to set
         */
        function ChannelOpenRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelOpenRequest walletId.
         * @member {string} walletId
         * @memberof p2p.ChannelOpenRequest
         * @instance
         */
        ChannelOpenRequest.prototype.walletId = "";

        /**
         * ChannelOpenRequest counterpartyPubkey.
         * @member {string} counterpartyPubkey
         * @memberof p2p.ChannelOpenRequest
         * @instance
         */
        ChannelOpenRequest.prototype.counterpartyPubkey = "";

        /**
         * ChannelOpenRequest myAmount.
         * @member {number|Long} myAmount
         * @memberof p2p.ChannelOpenRequest
         * @instance
         */
        ChannelOpenRequest.prototype.myAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelOpenRequest theirAmount.
         * @member {number|Long} theirAmount
         * @memberof p2p.ChannelOpenRequest
         * @instance
         */
        ChannelOpenRequest.prototype.theirAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelOpenRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {p2p.IChannelOpenRequest=} [properties] Properties to set
         * @returns {p2p.ChannelOpenRequest} ChannelOpenRequest instance
         */
        ChannelOpenRequest.create = function create(properties) {
            return new ChannelOpenRequest(properties);
        };

        /**
         * Encodes the specified ChannelOpenRequest message. Does not implicitly {@link p2p.ChannelOpenRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {p2p.IChannelOpenRequest} message ChannelOpenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.counterpartyPubkey != null && Object.hasOwnProperty.call(message, "counterpartyPubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.counterpartyPubkey);
            if (message.myAmount != null && Object.hasOwnProperty.call(message, "myAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.myAmount);
            if (message.theirAmount != null && Object.hasOwnProperty.call(message, "theirAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.theirAmount);
            return writer;
        };

        /**
         * Encodes the specified ChannelOpenRequest message, length delimited. Does not implicitly {@link p2p.ChannelOpenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {p2p.IChannelOpenRequest} message ChannelOpenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelOpenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelOpenRequest} ChannelOpenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelOpenRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.counterpartyPubkey = reader.string();
                        break;
                    }
                case 3: {
                        message.myAmount = reader.uint64();
                        break;
                    }
                case 4: {
                        message.theirAmount = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelOpenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelOpenRequest} ChannelOpenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelOpenRequest message.
         * @function verify
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelOpenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.counterpartyPubkey != null && message.hasOwnProperty("counterpartyPubkey"))
                if (!$util.isString(message.counterpartyPubkey))
                    return "counterpartyPubkey: string expected";
            if (message.myAmount != null && message.hasOwnProperty("myAmount"))
                if (!$util.isInteger(message.myAmount) && !(message.myAmount && $util.isInteger(message.myAmount.low) && $util.isInteger(message.myAmount.high)))
                    return "myAmount: integer|Long expected";
            if (message.theirAmount != null && message.hasOwnProperty("theirAmount"))
                if (!$util.isInteger(message.theirAmount) && !(message.theirAmount && $util.isInteger(message.theirAmount.low) && $util.isInteger(message.theirAmount.high)))
                    return "theirAmount: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelOpenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelOpenRequest} ChannelOpenRequest
         */
        ChannelOpenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelOpenRequest)
                return object;
            var message = new $root.p2p.ChannelOpenRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.counterpartyPubkey != null)
                message.counterpartyPubkey = String(object.counterpartyPubkey);
            if (object.myAmount != null)
                if ($util.Long)
                    (message.myAmount = $util.Long.fromValue(object.myAmount)).unsigned = true;
                else if (typeof object.myAmount === "string")
                    message.myAmount = parseInt(object.myAmount, 10);
                else if (typeof object.myAmount === "number")
                    message.myAmount = object.myAmount;
                else if (typeof object.myAmount === "object")
                    message.myAmount = new $util.LongBits(object.myAmount.low >>> 0, object.myAmount.high >>> 0).toNumber(true);
            if (object.theirAmount != null)
                if ($util.Long)
                    (message.theirAmount = $util.Long.fromValue(object.theirAmount)).unsigned = true;
                else if (typeof object.theirAmount === "string")
                    message.theirAmount = parseInt(object.theirAmount, 10);
                else if (typeof object.theirAmount === "number")
                    message.theirAmount = object.theirAmount;
                else if (typeof object.theirAmount === "object")
                    message.theirAmount = new $util.LongBits(object.theirAmount.low >>> 0, object.theirAmount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelOpenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {p2p.ChannelOpenRequest} message ChannelOpenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelOpenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.counterpartyPubkey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.myAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.myAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.theirAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.theirAmount = options.longs === String ? "0" : 0;
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.counterpartyPubkey != null && message.hasOwnProperty("counterpartyPubkey"))
                object.counterpartyPubkey = message.counterpartyPubkey;
            if (message.myAmount != null && message.hasOwnProperty("myAmount"))
                if (typeof message.myAmount === "number")
                    object.myAmount = options.longs === String ? String(message.myAmount) : message.myAmount;
                else
                    object.myAmount = options.longs === String ? $util.Long.prototype.toString.call(message.myAmount) : options.longs === Number ? new $util.LongBits(message.myAmount.low >>> 0, message.myAmount.high >>> 0).toNumber(true) : message.myAmount;
            if (message.theirAmount != null && message.hasOwnProperty("theirAmount"))
                if (typeof message.theirAmount === "number")
                    object.theirAmount = options.longs === String ? String(message.theirAmount) : message.theirAmount;
                else
                    object.theirAmount = options.longs === String ? $util.Long.prototype.toString.call(message.theirAmount) : options.longs === Number ? new $util.LongBits(message.theirAmount.low >>> 0, message.theirAmount.high >>> 0).toNumber(true) : message.theirAmount;
            return object;
        };

        /**
         * Converts this ChannelOpenRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelOpenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelOpenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelOpenRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelOpenRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelOpenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelOpenRequest";
        };

        return ChannelOpenRequest;
    })();

    p2p.ChannelListRequest = (function() {

        /**
         * Properties of a ChannelListRequest.
         * @memberof p2p
         * @interface IChannelListRequest
         */

        /**
         * Constructs a new ChannelListRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelListRequest.
         * @implements IChannelListRequest
         * @constructor
         * @param {p2p.IChannelListRequest=} [properties] Properties to set
         */
        function ChannelListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelListRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {p2p.IChannelListRequest=} [properties] Properties to set
         * @returns {p2p.ChannelListRequest} ChannelListRequest instance
         */
        ChannelListRequest.create = function create(properties) {
            return new ChannelListRequest(properties);
        };

        /**
         * Encodes the specified ChannelListRequest message. Does not implicitly {@link p2p.ChannelListRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {p2p.IChannelListRequest} message ChannelListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelListRequest message, length delimited. Does not implicitly {@link p2p.ChannelListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {p2p.IChannelListRequest} message ChannelListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelListRequest} ChannelListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelListRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelListRequest} ChannelListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelListRequest message.
         * @function verify
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelListRequest} ChannelListRequest
         */
        ChannelListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelListRequest)
                return object;
            return new $root.p2p.ChannelListRequest();
        };

        /**
         * Creates a plain object from a ChannelListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {p2p.ChannelListRequest} message ChannelListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelListRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelListRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelListRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelListRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelListRequest";
        };

        return ChannelListRequest;
    })();

    p2p.ChannelAcceptRequest = (function() {

        /**
         * Properties of a ChannelAcceptRequest.
         * @memberof p2p
         * @interface IChannelAcceptRequest
         * @property {string|null} [walletId] ChannelAcceptRequest walletId
         * @property {string|null} [proposalId] ChannelAcceptRequest proposalId
         */

        /**
         * Constructs a new ChannelAcceptRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelAcceptRequest.
         * @implements IChannelAcceptRequest
         * @constructor
         * @param {p2p.IChannelAcceptRequest=} [properties] Properties to set
         */
        function ChannelAcceptRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelAcceptRequest walletId.
         * @member {string} walletId
         * @memberof p2p.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.walletId = "";

        /**
         * ChannelAcceptRequest proposalId.
         * @member {string} proposalId
         * @memberof p2p.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.proposalId = "";

        /**
         * Creates a new ChannelAcceptRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {p2p.IChannelAcceptRequest=} [properties] Properties to set
         * @returns {p2p.ChannelAcceptRequest} ChannelAcceptRequest instance
         */
        ChannelAcceptRequest.create = function create(properties) {
            return new ChannelAcceptRequest(properties);
        };

        /**
         * Encodes the specified ChannelAcceptRequest message. Does not implicitly {@link p2p.ChannelAcceptRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {p2p.IChannelAcceptRequest} message ChannelAcceptRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.proposalId);
            return writer;
        };

        /**
         * Encodes the specified ChannelAcceptRequest message, length delimited. Does not implicitly {@link p2p.ChannelAcceptRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {p2p.IChannelAcceptRequest} message ChannelAcceptRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelAcceptRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelAcceptRequest} ChannelAcceptRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelAcceptRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.proposalId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelAcceptRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelAcceptRequest} ChannelAcceptRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelAcceptRequest message.
         * @function verify
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelAcceptRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isString(message.proposalId))
                    return "proposalId: string expected";
            return null;
        };

        /**
         * Creates a ChannelAcceptRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelAcceptRequest} ChannelAcceptRequest
         */
        ChannelAcceptRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelAcceptRequest)
                return object;
            var message = new $root.p2p.ChannelAcceptRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.proposalId != null)
                message.proposalId = String(object.proposalId);
            return message;
        };

        /**
         * Creates a plain object from a ChannelAcceptRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {p2p.ChannelAcceptRequest} message ChannelAcceptRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelAcceptRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.proposalId = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = message.proposalId;
            return object;
        };

        /**
         * Converts this ChannelAcceptRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelAcceptRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelAcceptRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelAcceptRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelAcceptRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelAcceptRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelAcceptRequest";
        };

        return ChannelAcceptRequest;
    })();

    p2p.ChannelFundRequest = (function() {

        /**
         * Properties of a ChannelFundRequest.
         * @memberof p2p
         * @interface IChannelFundRequest
         * @property {string|null} [walletId] ChannelFundRequest walletId
         * @property {string|null} [channelId] ChannelFundRequest channelId
         */

        /**
         * Constructs a new ChannelFundRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelFundRequest.
         * @implements IChannelFundRequest
         * @constructor
         * @param {p2p.IChannelFundRequest=} [properties] Properties to set
         */
        function ChannelFundRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelFundRequest walletId.
         * @member {string} walletId
         * @memberof p2p.ChannelFundRequest
         * @instance
         */
        ChannelFundRequest.prototype.walletId = "";

        /**
         * ChannelFundRequest channelId.
         * @member {string} channelId
         * @memberof p2p.ChannelFundRequest
         * @instance
         */
        ChannelFundRequest.prototype.channelId = "";

        /**
         * Creates a new ChannelFundRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {p2p.IChannelFundRequest=} [properties] Properties to set
         * @returns {p2p.ChannelFundRequest} ChannelFundRequest instance
         */
        ChannelFundRequest.create = function create(properties) {
            return new ChannelFundRequest(properties);
        };

        /**
         * Encodes the specified ChannelFundRequest message. Does not implicitly {@link p2p.ChannelFundRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {p2p.IChannelFundRequest} message ChannelFundRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFundRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelId);
            return writer;
        };

        /**
         * Encodes the specified ChannelFundRequest message, length delimited. Does not implicitly {@link p2p.ChannelFundRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {p2p.IChannelFundRequest} message ChannelFundRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFundRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelFundRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelFundRequest} ChannelFundRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFundRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelFundRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelFundRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelFundRequest} ChannelFundRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFundRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelFundRequest message.
         * @function verify
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelFundRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            return null;
        };

        /**
         * Creates a ChannelFundRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelFundRequest} ChannelFundRequest
         */
        ChannelFundRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelFundRequest)
                return object;
            var message = new $root.p2p.ChannelFundRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.channelId != null)
                message.channelId = String(object.channelId);
            return message;
        };

        /**
         * Creates a plain object from a ChannelFundRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {p2p.ChannelFundRequest} message ChannelFundRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelFundRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.channelId = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            return object;
        };

        /**
         * Converts this ChannelFundRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelFundRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelFundRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelFundRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelFundRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelFundRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelFundRequest";
        };

        return ChannelFundRequest;
    })();

    p2p.ChannelPayRequest = (function() {

        /**
         * Properties of a ChannelPayRequest.
         * @memberof p2p
         * @interface IChannelPayRequest
         * @property {string|null} [walletId] ChannelPayRequest walletId
         * @property {string|null} [channelId] ChannelPayRequest channelId
         * @property {number|Long|null} [amount] ChannelPayRequest amount
         */

        /**
         * Constructs a new ChannelPayRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelPayRequest.
         * @implements IChannelPayRequest
         * @constructor
         * @param {p2p.IChannelPayRequest=} [properties] Properties to set
         */
        function ChannelPayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPayRequest walletId.
         * @member {string} walletId
         * @memberof p2p.ChannelPayRequest
         * @instance
         */
        ChannelPayRequest.prototype.walletId = "";

        /**
         * ChannelPayRequest channelId.
         * @member {string} channelId
         * @memberof p2p.ChannelPayRequest
         * @instance
         */
        ChannelPayRequest.prototype.channelId = "";

        /**
         * ChannelPayRequest amount.
         * @member {number|Long} amount
         * @memberof p2p.ChannelPayRequest
         * @instance
         */
        ChannelPayRequest.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChannelPayRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {p2p.IChannelPayRequest=} [properties] Properties to set
         * @returns {p2p.ChannelPayRequest} ChannelPayRequest instance
         */
        ChannelPayRequest.create = function create(properties) {
            return new ChannelPayRequest(properties);
        };

        /**
         * Encodes the specified ChannelPayRequest message. Does not implicitly {@link p2p.ChannelPayRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {p2p.IChannelPayRequest} message ChannelPayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ChannelPayRequest message, length delimited. Does not implicitly {@link p2p.ChannelPayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {p2p.IChannelPayRequest} message ChannelPayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelPayRequest} ChannelPayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPayRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelPayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelId = reader.string();
                        break;
                    }
                case 3: {
                        message.amount = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelPayRequest} ChannelPayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPayRequest message.
         * @function verify
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelPayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelPayRequest} ChannelPayRequest
         */
        ChannelPayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelPayRequest)
                return object;
            var message = new $root.p2p.ChannelPayRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.channelId != null)
                message.channelId = String(object.channelId);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChannelPayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {p2p.ChannelPayRequest} message ChannelPayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.channelId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            return object;
        };

        /**
         * Converts this ChannelPayRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelPayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelPayRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelPayRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelPayRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelPayRequest";
        };

        return ChannelPayRequest;
    })();

    p2p.ChannelCloseRequest = (function() {

        /**
         * Properties of a ChannelCloseRequest.
         * @memberof p2p
         * @interface IChannelCloseRequest
         * @property {string|null} [walletId] ChannelCloseRequest walletId
         * @property {string|null} [channelId] ChannelCloseRequest channelId
         */

        /**
         * Constructs a new ChannelCloseRequest.
         * @memberof p2p
         * @classdesc Represents a ChannelCloseRequest.
         * @implements IChannelCloseRequest
         * @constructor
         * @param {p2p.IChannelCloseRequest=} [properties] Properties to set
         */
        function ChannelCloseRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelCloseRequest walletId.
         * @member {string} walletId
         * @memberof p2p.ChannelCloseRequest
         * @instance
         */
        ChannelCloseRequest.prototype.walletId = "";

        /**
         * ChannelCloseRequest channelId.
         * @member {string} channelId
         * @memberof p2p.ChannelCloseRequest
         * @instance
         */
        ChannelCloseRequest.prototype.channelId = "";

        /**
         * Creates a new ChannelCloseRequest instance using the specified properties.
         * @function create
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {p2p.IChannelCloseRequest=} [properties] Properties to set
         * @returns {p2p.ChannelCloseRequest} ChannelCloseRequest instance
         */
        ChannelCloseRequest.create = function create(properties) {
            return new ChannelCloseRequest(properties);
        };

        /**
         * Encodes the specified ChannelCloseRequest message. Does not implicitly {@link p2p.ChannelCloseRequest.verify|verify} messages.
         * @function encode
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {p2p.IChannelCloseRequest} message ChannelCloseRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelId);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseRequest message, length delimited. Does not implicitly {@link p2p.ChannelCloseRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {p2p.IChannelCloseRequest} message ChannelCloseRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseRequest message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.ChannelCloseRequest} ChannelCloseRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.ChannelCloseRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.ChannelCloseRequest} ChannelCloseRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseRequest message.
         * @function verify
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            return null;
        };

        /**
         * Creates a ChannelCloseRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.ChannelCloseRequest} ChannelCloseRequest
         */
        ChannelCloseRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.ChannelCloseRequest)
                return object;
            var message = new $root.p2p.ChannelCloseRequest();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.channelId != null)
                message.channelId = String(object.channelId);
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {p2p.ChannelCloseRequest} message ChannelCloseRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.channelId = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            return object;
        };

        /**
         * Converts this ChannelCloseRequest to JSON.
         * @function toJSON
         * @memberof p2p.ChannelCloseRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelCloseRequest
         * @function getTypeUrl
         * @memberof p2p.ChannelCloseRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelCloseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.ChannelCloseRequest";
        };

        return ChannelCloseRequest;
    })();

    p2p.P2pMessageReceived = (function() {

        /**
         * Properties of a P2pMessageReceived.
         * @memberof p2p
         * @interface IP2pMessageReceived
         * @property {string|null} [topic] P2pMessageReceived topic
         * @property {Uint8Array|null} [data] P2pMessageReceived data
         * @property {string|null} [fromPeerId] P2pMessageReceived fromPeerId
         */

        /**
         * Constructs a new P2pMessageReceived.
         * @memberof p2p
         * @classdesc Represents a P2pMessageReceived.
         * @implements IP2pMessageReceived
         * @constructor
         * @param {p2p.IP2pMessageReceived=} [properties] Properties to set
         */
        function P2pMessageReceived(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * P2pMessageReceived topic.
         * @member {string} topic
         * @memberof p2p.P2pMessageReceived
         * @instance
         */
        P2pMessageReceived.prototype.topic = "";

        /**
         * P2pMessageReceived data.
         * @member {Uint8Array} data
         * @memberof p2p.P2pMessageReceived
         * @instance
         */
        P2pMessageReceived.prototype.data = $util.newBuffer([]);

        /**
         * P2pMessageReceived fromPeerId.
         * @member {string} fromPeerId
         * @memberof p2p.P2pMessageReceived
         * @instance
         */
        P2pMessageReceived.prototype.fromPeerId = "";

        /**
         * Creates a new P2pMessageReceived instance using the specified properties.
         * @function create
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {p2p.IP2pMessageReceived=} [properties] Properties to set
         * @returns {p2p.P2pMessageReceived} P2pMessageReceived instance
         */
        P2pMessageReceived.create = function create(properties) {
            return new P2pMessageReceived(properties);
        };

        /**
         * Encodes the specified P2pMessageReceived message. Does not implicitly {@link p2p.P2pMessageReceived.verify|verify} messages.
         * @function encode
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {p2p.IP2pMessageReceived} message P2pMessageReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        P2pMessageReceived.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.fromPeerId != null && Object.hasOwnProperty.call(message, "fromPeerId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fromPeerId);
            return writer;
        };

        /**
         * Encodes the specified P2pMessageReceived message, length delimited. Does not implicitly {@link p2p.P2pMessageReceived.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {p2p.IP2pMessageReceived} message P2pMessageReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        P2pMessageReceived.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a P2pMessageReceived message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.P2pMessageReceived} P2pMessageReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        P2pMessageReceived.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.P2pMessageReceived();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.topic = reader.string();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                case 3: {
                        message.fromPeerId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a P2pMessageReceived message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.P2pMessageReceived} P2pMessageReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        P2pMessageReceived.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a P2pMessageReceived message.
         * @function verify
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        P2pMessageReceived.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.topic != null && message.hasOwnProperty("topic"))
                if (!$util.isString(message.topic))
                    return "topic: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fromPeerId != null && message.hasOwnProperty("fromPeerId"))
                if (!$util.isString(message.fromPeerId))
                    return "fromPeerId: string expected";
            return null;
        };

        /**
         * Creates a P2pMessageReceived message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.P2pMessageReceived} P2pMessageReceived
         */
        P2pMessageReceived.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.P2pMessageReceived)
                return object;
            var message = new $root.p2p.P2pMessageReceived();
            if (object.topic != null)
                message.topic = String(object.topic);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.fromPeerId != null)
                message.fromPeerId = String(object.fromPeerId);
            return message;
        };

        /**
         * Creates a plain object from a P2pMessageReceived message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {p2p.P2pMessageReceived} message P2pMessageReceived
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        P2pMessageReceived.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.topic = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.fromPeerId = "";
            }
            if (message.topic != null && message.hasOwnProperty("topic"))
                object.topic = message.topic;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fromPeerId != null && message.hasOwnProperty("fromPeerId"))
                object.fromPeerId = message.fromPeerId;
            return object;
        };

        /**
         * Converts this P2pMessageReceived to JSON.
         * @function toJSON
         * @memberof p2p.P2pMessageReceived
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        P2pMessageReceived.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for P2pMessageReceived
         * @function getTypeUrl
         * @memberof p2p.P2pMessageReceived
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        P2pMessageReceived.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.P2pMessageReceived";
        };

        return P2pMessageReceived;
    })();

    p2p.PeerConnected = (function() {

        /**
         * Properties of a PeerConnected.
         * @memberof p2p
         * @interface IPeerConnected
         * @property {string|null} [peerId] PeerConnected peerId
         */

        /**
         * Constructs a new PeerConnected.
         * @memberof p2p
         * @classdesc Represents a PeerConnected.
         * @implements IPeerConnected
         * @constructor
         * @param {p2p.IPeerConnected=} [properties] Properties to set
         */
        function PeerConnected(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeerConnected peerId.
         * @member {string} peerId
         * @memberof p2p.PeerConnected
         * @instance
         */
        PeerConnected.prototype.peerId = "";

        /**
         * Creates a new PeerConnected instance using the specified properties.
         * @function create
         * @memberof p2p.PeerConnected
         * @static
         * @param {p2p.IPeerConnected=} [properties] Properties to set
         * @returns {p2p.PeerConnected} PeerConnected instance
         */
        PeerConnected.create = function create(properties) {
            return new PeerConnected(properties);
        };

        /**
         * Encodes the specified PeerConnected message. Does not implicitly {@link p2p.PeerConnected.verify|verify} messages.
         * @function encode
         * @memberof p2p.PeerConnected
         * @static
         * @param {p2p.IPeerConnected} message PeerConnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerConnected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
            return writer;
        };

        /**
         * Encodes the specified PeerConnected message, length delimited. Does not implicitly {@link p2p.PeerConnected.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PeerConnected
         * @static
         * @param {p2p.IPeerConnected} message PeerConnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerConnected.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeerConnected message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PeerConnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PeerConnected} PeerConnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerConnected.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PeerConnected();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.peerId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeerConnected message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PeerConnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PeerConnected} PeerConnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerConnected.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeerConnected message.
         * @function verify
         * @memberof p2p.PeerConnected
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeerConnected.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isString(message.peerId))
                    return "peerId: string expected";
            return null;
        };

        /**
         * Creates a PeerConnected message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PeerConnected
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PeerConnected} PeerConnected
         */
        PeerConnected.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PeerConnected)
                return object;
            var message = new $root.p2p.PeerConnected();
            if (object.peerId != null)
                message.peerId = String(object.peerId);
            return message;
        };

        /**
         * Creates a plain object from a PeerConnected message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PeerConnected
         * @static
         * @param {p2p.PeerConnected} message PeerConnected
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeerConnected.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.peerId = "";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                object.peerId = message.peerId;
            return object;
        };

        /**
         * Converts this PeerConnected to JSON.
         * @function toJSON
         * @memberof p2p.PeerConnected
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeerConnected.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PeerConnected
         * @function getTypeUrl
         * @memberof p2p.PeerConnected
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PeerConnected.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PeerConnected";
        };

        return PeerConnected;
    })();

    p2p.PeerDisconnected = (function() {

        /**
         * Properties of a PeerDisconnected.
         * @memberof p2p
         * @interface IPeerDisconnected
         * @property {string|null} [peerId] PeerDisconnected peerId
         */

        /**
         * Constructs a new PeerDisconnected.
         * @memberof p2p
         * @classdesc Represents a PeerDisconnected.
         * @implements IPeerDisconnected
         * @constructor
         * @param {p2p.IPeerDisconnected=} [properties] Properties to set
         */
        function PeerDisconnected(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeerDisconnected peerId.
         * @member {string} peerId
         * @memberof p2p.PeerDisconnected
         * @instance
         */
        PeerDisconnected.prototype.peerId = "";

        /**
         * Creates a new PeerDisconnected instance using the specified properties.
         * @function create
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {p2p.IPeerDisconnected=} [properties] Properties to set
         * @returns {p2p.PeerDisconnected} PeerDisconnected instance
         */
        PeerDisconnected.create = function create(properties) {
            return new PeerDisconnected(properties);
        };

        /**
         * Encodes the specified PeerDisconnected message. Does not implicitly {@link p2p.PeerDisconnected.verify|verify} messages.
         * @function encode
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {p2p.IPeerDisconnected} message PeerDisconnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerDisconnected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
            return writer;
        };

        /**
         * Encodes the specified PeerDisconnected message, length delimited. Does not implicitly {@link p2p.PeerDisconnected.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {p2p.IPeerDisconnected} message PeerDisconnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerDisconnected.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeerDisconnected message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PeerDisconnected} PeerDisconnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerDisconnected.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PeerDisconnected();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.peerId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeerDisconnected message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PeerDisconnected} PeerDisconnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerDisconnected.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeerDisconnected message.
         * @function verify
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeerDisconnected.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isString(message.peerId))
                    return "peerId: string expected";
            return null;
        };

        /**
         * Creates a PeerDisconnected message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PeerDisconnected} PeerDisconnected
         */
        PeerDisconnected.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PeerDisconnected)
                return object;
            var message = new $root.p2p.PeerDisconnected();
            if (object.peerId != null)
                message.peerId = String(object.peerId);
            return message;
        };

        /**
         * Creates a plain object from a PeerDisconnected message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {p2p.PeerDisconnected} message PeerDisconnected
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeerDisconnected.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.peerId = "";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                object.peerId = message.peerId;
            return object;
        };

        /**
         * Converts this PeerDisconnected to JSON.
         * @function toJSON
         * @memberof p2p.PeerDisconnected
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeerDisconnected.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PeerDisconnected
         * @function getTypeUrl
         * @memberof p2p.PeerDisconnected
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PeerDisconnected.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PeerDisconnected";
        };

        return PeerDisconnected;
    })();

    p2p.PeerVerified = (function() {

        /**
         * Properties of a PeerVerified.
         * @memberof p2p
         * @interface IPeerVerified
         * @property {string|null} [peerId] PeerVerified peerId
         */

        /**
         * Constructs a new PeerVerified.
         * @memberof p2p
         * @classdesc Represents a PeerVerified.
         * @implements IPeerVerified
         * @constructor
         * @param {p2p.IPeerVerified=} [properties] Properties to set
         */
        function PeerVerified(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeerVerified peerId.
         * @member {string} peerId
         * @memberof p2p.PeerVerified
         * @instance
         */
        PeerVerified.prototype.peerId = "";

        /**
         * Creates a new PeerVerified instance using the specified properties.
         * @function create
         * @memberof p2p.PeerVerified
         * @static
         * @param {p2p.IPeerVerified=} [properties] Properties to set
         * @returns {p2p.PeerVerified} PeerVerified instance
         */
        PeerVerified.create = function create(properties) {
            return new PeerVerified(properties);
        };

        /**
         * Encodes the specified PeerVerified message. Does not implicitly {@link p2p.PeerVerified.verify|verify} messages.
         * @function encode
         * @memberof p2p.PeerVerified
         * @static
         * @param {p2p.IPeerVerified} message PeerVerified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerVerified.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
            return writer;
        };

        /**
         * Encodes the specified PeerVerified message, length delimited. Does not implicitly {@link p2p.PeerVerified.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PeerVerified
         * @static
         * @param {p2p.IPeerVerified} message PeerVerified message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerVerified.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeerVerified message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PeerVerified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PeerVerified} PeerVerified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerVerified.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PeerVerified();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.peerId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeerVerified message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PeerVerified
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PeerVerified} PeerVerified
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerVerified.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeerVerified message.
         * @function verify
         * @memberof p2p.PeerVerified
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeerVerified.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isString(message.peerId))
                    return "peerId: string expected";
            return null;
        };

        /**
         * Creates a PeerVerified message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PeerVerified
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PeerVerified} PeerVerified
         */
        PeerVerified.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PeerVerified)
                return object;
            var message = new $root.p2p.PeerVerified();
            if (object.peerId != null)
                message.peerId = String(object.peerId);
            return message;
        };

        /**
         * Creates a plain object from a PeerVerified message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PeerVerified
         * @static
         * @param {p2p.PeerVerified} message PeerVerified
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeerVerified.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.peerId = "";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                object.peerId = message.peerId;
            return object;
        };

        /**
         * Converts this PeerVerified to JSON.
         * @function toJSON
         * @memberof p2p.PeerVerified
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeerVerified.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PeerVerified
         * @function getTypeUrl
         * @memberof p2p.PeerVerified
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PeerVerified.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PeerVerified";
        };

        return PeerVerified;
    })();

    p2p.LogMessage = (function() {

        /**
         * Properties of a LogMessage.
         * @memberof p2p
         * @interface ILogMessage
         * @property {string|null} [level] LogMessage level
         * @property {string|null} [message] LogMessage message
         */

        /**
         * Constructs a new LogMessage.
         * @memberof p2p
         * @classdesc Represents a LogMessage.
         * @implements ILogMessage
         * @constructor
         * @param {p2p.ILogMessage=} [properties] Properties to set
         */
        function LogMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogMessage level.
         * @member {string} level
         * @memberof p2p.LogMessage
         * @instance
         */
        LogMessage.prototype.level = "";

        /**
         * LogMessage message.
         * @member {string} message
         * @memberof p2p.LogMessage
         * @instance
         */
        LogMessage.prototype.message = "";

        /**
         * Creates a new LogMessage instance using the specified properties.
         * @function create
         * @memberof p2p.LogMessage
         * @static
         * @param {p2p.ILogMessage=} [properties] Properties to set
         * @returns {p2p.LogMessage} LogMessage instance
         */
        LogMessage.create = function create(properties) {
            return new LogMessage(properties);
        };

        /**
         * Encodes the specified LogMessage message. Does not implicitly {@link p2p.LogMessage.verify|verify} messages.
         * @function encode
         * @memberof p2p.LogMessage
         * @static
         * @param {p2p.ILogMessage} message LogMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.level);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified LogMessage message, length delimited. Does not implicitly {@link p2p.LogMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.LogMessage
         * @static
         * @param {p2p.ILogMessage} message LogMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogMessage message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.LogMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.LogMessage} LogMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.LogMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.level = reader.string();
                        break;
                    }
                case 2: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.LogMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.LogMessage} LogMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogMessage message.
         * @function verify
         * @memberof p2p.LogMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isString(message.level))
                    return "level: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a LogMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.LogMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.LogMessage} LogMessage
         */
        LogMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.LogMessage)
                return object;
            var message = new $root.p2p.LogMessage();
            if (object.level != null)
                message.level = String(object.level);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a LogMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.LogMessage
         * @static
         * @param {p2p.LogMessage} message LogMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.level = "";
                object.message = "";
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this LogMessage to JSON.
         * @function toJSON
         * @memberof p2p.LogMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogMessage
         * @function getTypeUrl
         * @memberof p2p.LogMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.LogMessage";
        };

        return LogMessage;
    })();

    p2p.PublishP2pMessage = (function() {

        /**
         * Properties of a PublishP2pMessage.
         * @memberof p2p
         * @interface IPublishP2pMessage
         * @property {string|null} [topic] PublishP2pMessage topic
         * @property {Uint8Array|null} [data] PublishP2pMessage data
         */

        /**
         * Constructs a new PublishP2pMessage.
         * @memberof p2p
         * @classdesc Represents a PublishP2pMessage.
         * @implements IPublishP2pMessage
         * @constructor
         * @param {p2p.IPublishP2pMessage=} [properties] Properties to set
         */
        function PublishP2pMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishP2pMessage topic.
         * @member {string} topic
         * @memberof p2p.PublishP2pMessage
         * @instance
         */
        PublishP2pMessage.prototype.topic = "";

        /**
         * PublishP2pMessage data.
         * @member {Uint8Array} data
         * @memberof p2p.PublishP2pMessage
         * @instance
         */
        PublishP2pMessage.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new PublishP2pMessage instance using the specified properties.
         * @function create
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {p2p.IPublishP2pMessage=} [properties] Properties to set
         * @returns {p2p.PublishP2pMessage} PublishP2pMessage instance
         */
        PublishP2pMessage.create = function create(properties) {
            return new PublishP2pMessage(properties);
        };

        /**
         * Encodes the specified PublishP2pMessage message. Does not implicitly {@link p2p.PublishP2pMessage.verify|verify} messages.
         * @function encode
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {p2p.IPublishP2pMessage} message PublishP2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishP2pMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified PublishP2pMessage message, length delimited. Does not implicitly {@link p2p.PublishP2pMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {p2p.IPublishP2pMessage} message PublishP2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishP2pMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishP2pMessage message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.PublishP2pMessage} PublishP2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishP2pMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.PublishP2pMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.topic = reader.string();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishP2pMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.PublishP2pMessage} PublishP2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishP2pMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishP2pMessage message.
         * @function verify
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishP2pMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.topic != null && message.hasOwnProperty("topic"))
                if (!$util.isString(message.topic))
                    return "topic: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a PublishP2pMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.PublishP2pMessage} PublishP2pMessage
         */
        PublishP2pMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.PublishP2pMessage)
                return object;
            var message = new $root.p2p.PublishP2pMessage();
            if (object.topic != null)
                message.topic = String(object.topic);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a PublishP2pMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {p2p.PublishP2pMessage} message PublishP2pMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishP2pMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.topic = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.topic != null && message.hasOwnProperty("topic"))
                object.topic = message.topic;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this PublishP2pMessage to JSON.
         * @function toJSON
         * @memberof p2p.PublishP2pMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishP2pMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PublishP2pMessage
         * @function getTypeUrl
         * @memberof p2p.PublishP2pMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PublishP2pMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.PublishP2pMessage";
        };

        return PublishP2pMessage;
    })();

    p2p.SendDirectP2pMessage = (function() {

        /**
         * Properties of a SendDirectP2pMessage.
         * @memberof p2p
         * @interface ISendDirectP2pMessage
         * @property {string|null} [peerId] SendDirectP2pMessage peerId
         * @property {string|null} [protocol] SendDirectP2pMessage protocol
         * @property {Uint8Array|null} [data] SendDirectP2pMessage data
         */

        /**
         * Constructs a new SendDirectP2pMessage.
         * @memberof p2p
         * @classdesc Represents a SendDirectP2pMessage.
         * @implements ISendDirectP2pMessage
         * @constructor
         * @param {p2p.ISendDirectP2pMessage=} [properties] Properties to set
         */
        function SendDirectP2pMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendDirectP2pMessage peerId.
         * @member {string} peerId
         * @memberof p2p.SendDirectP2pMessage
         * @instance
         */
        SendDirectP2pMessage.prototype.peerId = "";

        /**
         * SendDirectP2pMessage protocol.
         * @member {string} protocol
         * @memberof p2p.SendDirectP2pMessage
         * @instance
         */
        SendDirectP2pMessage.prototype.protocol = "";

        /**
         * SendDirectP2pMessage data.
         * @member {Uint8Array} data
         * @memberof p2p.SendDirectP2pMessage
         * @instance
         */
        SendDirectP2pMessage.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new SendDirectP2pMessage instance using the specified properties.
         * @function create
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {p2p.ISendDirectP2pMessage=} [properties] Properties to set
         * @returns {p2p.SendDirectP2pMessage} SendDirectP2pMessage instance
         */
        SendDirectP2pMessage.create = function create(properties) {
            return new SendDirectP2pMessage(properties);
        };

        /**
         * Encodes the specified SendDirectP2pMessage message. Does not implicitly {@link p2p.SendDirectP2pMessage.verify|verify} messages.
         * @function encode
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {p2p.ISendDirectP2pMessage} message SendDirectP2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendDirectP2pMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.protocol);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified SendDirectP2pMessage message, length delimited. Does not implicitly {@link p2p.SendDirectP2pMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {p2p.ISendDirectP2pMessage} message SendDirectP2pMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendDirectP2pMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendDirectP2pMessage message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.SendDirectP2pMessage} SendDirectP2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendDirectP2pMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.SendDirectP2pMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.peerId = reader.string();
                        break;
                    }
                case 2: {
                        message.protocol = reader.string();
                        break;
                    }
                case 3: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendDirectP2pMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.SendDirectP2pMessage} SendDirectP2pMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendDirectP2pMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendDirectP2pMessage message.
         * @function verify
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendDirectP2pMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isString(message.peerId))
                    return "peerId: string expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isString(message.protocol))
                    return "protocol: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a SendDirectP2pMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.SendDirectP2pMessage} SendDirectP2pMessage
         */
        SendDirectP2pMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.SendDirectP2pMessage)
                return object;
            var message = new $root.p2p.SendDirectP2pMessage();
            if (object.peerId != null)
                message.peerId = String(object.peerId);
            if (object.protocol != null)
                message.protocol = String(object.protocol);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a SendDirectP2pMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {p2p.SendDirectP2pMessage} message SendDirectP2pMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendDirectP2pMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.peerId = "";
                object.protocol = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                object.peerId = message.peerId;
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this SendDirectP2pMessage to JSON.
         * @function toJSON
         * @memberof p2p.SendDirectP2pMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendDirectP2pMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SendDirectP2pMessage
         * @function getTypeUrl
         * @memberof p2p.SendDirectP2pMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SendDirectP2pMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.SendDirectP2pMessage";
        };

        return SendDirectP2pMessage;
    })();

    p2p.HangUpPeer = (function() {

        /**
         * Properties of a HangUpPeer.
         * @memberof p2p
         * @interface IHangUpPeer
         * @property {string|null} [peerId] HangUpPeer peerId
         * @property {string|null} [reason] HangUpPeer reason
         */

        /**
         * Constructs a new HangUpPeer.
         * @memberof p2p
         * @classdesc Represents a HangUpPeer.
         * @implements IHangUpPeer
         * @constructor
         * @param {p2p.IHangUpPeer=} [properties] Properties to set
         */
        function HangUpPeer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HangUpPeer peerId.
         * @member {string} peerId
         * @memberof p2p.HangUpPeer
         * @instance
         */
        HangUpPeer.prototype.peerId = "";

        /**
         * HangUpPeer reason.
         * @member {string} reason
         * @memberof p2p.HangUpPeer
         * @instance
         */
        HangUpPeer.prototype.reason = "";

        /**
         * Creates a new HangUpPeer instance using the specified properties.
         * @function create
         * @memberof p2p.HangUpPeer
         * @static
         * @param {p2p.IHangUpPeer=} [properties] Properties to set
         * @returns {p2p.HangUpPeer} HangUpPeer instance
         */
        HangUpPeer.create = function create(properties) {
            return new HangUpPeer(properties);
        };

        /**
         * Encodes the specified HangUpPeer message. Does not implicitly {@link p2p.HangUpPeer.verify|verify} messages.
         * @function encode
         * @memberof p2p.HangUpPeer
         * @static
         * @param {p2p.IHangUpPeer} message HangUpPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HangUpPeer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified HangUpPeer message, length delimited. Does not implicitly {@link p2p.HangUpPeer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.HangUpPeer
         * @static
         * @param {p2p.IHangUpPeer} message HangUpPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HangUpPeer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HangUpPeer message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.HangUpPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.HangUpPeer} HangUpPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HangUpPeer.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.HangUpPeer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.peerId = reader.string();
                        break;
                    }
                case 2: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HangUpPeer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.HangUpPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.HangUpPeer} HangUpPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HangUpPeer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HangUpPeer message.
         * @function verify
         * @memberof p2p.HangUpPeer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HangUpPeer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isString(message.peerId))
                    return "peerId: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a HangUpPeer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.HangUpPeer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.HangUpPeer} HangUpPeer
         */
        HangUpPeer.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.HangUpPeer)
                return object;
            var message = new $root.p2p.HangUpPeer();
            if (object.peerId != null)
                message.peerId = String(object.peerId);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a HangUpPeer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.HangUpPeer
         * @static
         * @param {p2p.HangUpPeer} message HangUpPeer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HangUpPeer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.peerId = "";
                object.reason = "";
            }
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                object.peerId = message.peerId;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this HangUpPeer to JSON.
         * @function toJSON
         * @memberof p2p.HangUpPeer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HangUpPeer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HangUpPeer
         * @function getTypeUrl
         * @memberof p2p.HangUpPeer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HangUpPeer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.HangUpPeer";
        };

        return HangUpPeer;
    })();

    p2p.UpdateUiBalance = (function() {

        /**
         * Properties of an UpdateUiBalance.
         * @memberof p2p
         * @interface IUpdateUiBalance
         * @property {string|null} [walletId] UpdateUiBalance walletId
         * @property {string|null} [balanceString] UpdateUiBalance balanceString
         */

        /**
         * Constructs a new UpdateUiBalance.
         * @memberof p2p
         * @classdesc Represents an UpdateUiBalance.
         * @implements IUpdateUiBalance
         * @constructor
         * @param {p2p.IUpdateUiBalance=} [properties] Properties to set
         */
        function UpdateUiBalance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateUiBalance walletId.
         * @member {string} walletId
         * @memberof p2p.UpdateUiBalance
         * @instance
         */
        UpdateUiBalance.prototype.walletId = "";

        /**
         * UpdateUiBalance balanceString.
         * @member {string} balanceString
         * @memberof p2p.UpdateUiBalance
         * @instance
         */
        UpdateUiBalance.prototype.balanceString = "";

        /**
         * Creates a new UpdateUiBalance instance using the specified properties.
         * @function create
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {p2p.IUpdateUiBalance=} [properties] Properties to set
         * @returns {p2p.UpdateUiBalance} UpdateUiBalance instance
         */
        UpdateUiBalance.create = function create(properties) {
            return new UpdateUiBalance(properties);
        };

        /**
         * Encodes the specified UpdateUiBalance message. Does not implicitly {@link p2p.UpdateUiBalance.verify|verify} messages.
         * @function encode
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {p2p.IUpdateUiBalance} message UpdateUiBalance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiBalance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.balanceString != null && Object.hasOwnProperty.call(message, "balanceString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.balanceString);
            return writer;
        };

        /**
         * Encodes the specified UpdateUiBalance message, length delimited. Does not implicitly {@link p2p.UpdateUiBalance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {p2p.IUpdateUiBalance} message UpdateUiBalance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiBalance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateUiBalance message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UpdateUiBalance} UpdateUiBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiBalance.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UpdateUiBalance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.balanceString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateUiBalance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UpdateUiBalance} UpdateUiBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiBalance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateUiBalance message.
         * @function verify
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateUiBalance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.balanceString != null && message.hasOwnProperty("balanceString"))
                if (!$util.isString(message.balanceString))
                    return "balanceString: string expected";
            return null;
        };

        /**
         * Creates an UpdateUiBalance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UpdateUiBalance} UpdateUiBalance
         */
        UpdateUiBalance.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UpdateUiBalance)
                return object;
            var message = new $root.p2p.UpdateUiBalance();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.balanceString != null)
                message.balanceString = String(object.balanceString);
            return message;
        };

        /**
         * Creates a plain object from an UpdateUiBalance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {p2p.UpdateUiBalance} message UpdateUiBalance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateUiBalance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.balanceString = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.balanceString != null && message.hasOwnProperty("balanceString"))
                object.balanceString = message.balanceString;
            return object;
        };

        /**
         * Converts this UpdateUiBalance to JSON.
         * @function toJSON
         * @memberof p2p.UpdateUiBalance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateUiBalance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdateUiBalance
         * @function getTypeUrl
         * @memberof p2p.UpdateUiBalance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateUiBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UpdateUiBalance";
        };

        return UpdateUiBalance;
    })();

    p2p.UpdateUiMinerStatus = (function() {

        /**
         * Properties of an UpdateUiMinerStatus.
         * @memberof p2p
         * @interface IUpdateUiMinerStatus
         * @property {boolean|null} [isMining] UpdateUiMinerStatus isMining
         */

        /**
         * Constructs a new UpdateUiMinerStatus.
         * @memberof p2p
         * @classdesc Represents an UpdateUiMinerStatus.
         * @implements IUpdateUiMinerStatus
         * @constructor
         * @param {p2p.IUpdateUiMinerStatus=} [properties] Properties to set
         */
        function UpdateUiMinerStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateUiMinerStatus isMining.
         * @member {boolean} isMining
         * @memberof p2p.UpdateUiMinerStatus
         * @instance
         */
        UpdateUiMinerStatus.prototype.isMining = false;

        /**
         * Creates a new UpdateUiMinerStatus instance using the specified properties.
         * @function create
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {p2p.IUpdateUiMinerStatus=} [properties] Properties to set
         * @returns {p2p.UpdateUiMinerStatus} UpdateUiMinerStatus instance
         */
        UpdateUiMinerStatus.create = function create(properties) {
            return new UpdateUiMinerStatus(properties);
        };

        /**
         * Encodes the specified UpdateUiMinerStatus message. Does not implicitly {@link p2p.UpdateUiMinerStatus.verify|verify} messages.
         * @function encode
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {p2p.IUpdateUiMinerStatus} message UpdateUiMinerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiMinerStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isMining != null && Object.hasOwnProperty.call(message, "isMining"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isMining);
            return writer;
        };

        /**
         * Encodes the specified UpdateUiMinerStatus message, length delimited. Does not implicitly {@link p2p.UpdateUiMinerStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {p2p.IUpdateUiMinerStatus} message UpdateUiMinerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiMinerStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateUiMinerStatus message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UpdateUiMinerStatus} UpdateUiMinerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiMinerStatus.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UpdateUiMinerStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isMining = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateUiMinerStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UpdateUiMinerStatus} UpdateUiMinerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiMinerStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateUiMinerStatus message.
         * @function verify
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateUiMinerStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isMining != null && message.hasOwnProperty("isMining"))
                if (typeof message.isMining !== "boolean")
                    return "isMining: boolean expected";
            return null;
        };

        /**
         * Creates an UpdateUiMinerStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UpdateUiMinerStatus} UpdateUiMinerStatus
         */
        UpdateUiMinerStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UpdateUiMinerStatus)
                return object;
            var message = new $root.p2p.UpdateUiMinerStatus();
            if (object.isMining != null)
                message.isMining = Boolean(object.isMining);
            return message;
        };

        /**
         * Creates a plain object from an UpdateUiMinerStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {p2p.UpdateUiMinerStatus} message UpdateUiMinerStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateUiMinerStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isMining = false;
            if (message.isMining != null && message.hasOwnProperty("isMining"))
                object.isMining = message.isMining;
            return object;
        };

        /**
         * Converts this UpdateUiMinerStatus to JSON.
         * @function toJSON
         * @memberof p2p.UpdateUiMinerStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateUiMinerStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdateUiMinerStatus
         * @function getTypeUrl
         * @memberof p2p.UpdateUiMinerStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateUiMinerStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UpdateUiMinerStatus";
        };

        return UpdateUiMinerStatus;
    })();

    p2p.UpdateUiSyncProgress = (function() {

        /**
         * Properties of an UpdateUiSyncProgress.
         * @memberof p2p
         * @interface IUpdateUiSyncProgress
         * @property {number|Long|null} [current] UpdateUiSyncProgress current
         * @property {number|Long|null} [target] UpdateUiSyncProgress target
         * @property {number|Long|null} [startTime] UpdateUiSyncProgress startTime
         */

        /**
         * Constructs a new UpdateUiSyncProgress.
         * @memberof p2p
         * @classdesc Represents an UpdateUiSyncProgress.
         * @implements IUpdateUiSyncProgress
         * @constructor
         * @param {p2p.IUpdateUiSyncProgress=} [properties] Properties to set
         */
        function UpdateUiSyncProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateUiSyncProgress current.
         * @member {number|Long} current
         * @memberof p2p.UpdateUiSyncProgress
         * @instance
         */
        UpdateUiSyncProgress.prototype.current = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UpdateUiSyncProgress target.
         * @member {number|Long} target
         * @memberof p2p.UpdateUiSyncProgress
         * @instance
         */
        UpdateUiSyncProgress.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UpdateUiSyncProgress startTime.
         * @member {number|Long} startTime
         * @memberof p2p.UpdateUiSyncProgress
         * @instance
         */
        UpdateUiSyncProgress.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new UpdateUiSyncProgress instance using the specified properties.
         * @function create
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {p2p.IUpdateUiSyncProgress=} [properties] Properties to set
         * @returns {p2p.UpdateUiSyncProgress} UpdateUiSyncProgress instance
         */
        UpdateUiSyncProgress.create = function create(properties) {
            return new UpdateUiSyncProgress(properties);
        };

        /**
         * Encodes the specified UpdateUiSyncProgress message. Does not implicitly {@link p2p.UpdateUiSyncProgress.verify|verify} messages.
         * @function encode
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {p2p.IUpdateUiSyncProgress} message UpdateUiSyncProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiSyncProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.current);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.target);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.startTime);
            return writer;
        };

        /**
         * Encodes the specified UpdateUiSyncProgress message, length delimited. Does not implicitly {@link p2p.UpdateUiSyncProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {p2p.IUpdateUiSyncProgress} message UpdateUiSyncProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateUiSyncProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateUiSyncProgress message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UpdateUiSyncProgress} UpdateUiSyncProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiSyncProgress.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UpdateUiSyncProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.current = reader.uint64();
                        break;
                    }
                case 2: {
                        message.target = reader.uint64();
                        break;
                    }
                case 3: {
                        message.startTime = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateUiSyncProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UpdateUiSyncProgress} UpdateUiSyncProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateUiSyncProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateUiSyncProgress message.
         * @function verify
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateUiSyncProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.current != null && message.hasOwnProperty("current"))
                if (!$util.isInteger(message.current) && !(message.current && $util.isInteger(message.current.low) && $util.isInteger(message.current.high)))
                    return "current: integer|Long expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                    return "target: integer|Long expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateUiSyncProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UpdateUiSyncProgress} UpdateUiSyncProgress
         */
        UpdateUiSyncProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UpdateUiSyncProgress)
                return object;
            var message = new $root.p2p.UpdateUiSyncProgress();
            if (object.current != null)
                if ($util.Long)
                    (message.current = $util.Long.fromValue(object.current)).unsigned = true;
                else if (typeof object.current === "string")
                    message.current = parseInt(object.current, 10);
                else if (typeof object.current === "number")
                    message.current = object.current;
                else if (typeof object.current === "object")
                    message.current = new $util.LongBits(object.current.low >>> 0, object.current.high >>> 0).toNumber(true);
            if (object.target != null)
                if ($util.Long)
                    (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                else if (typeof object.target === "string")
                    message.target = parseInt(object.target, 10);
                else if (typeof object.target === "number")
                    message.target = object.target;
                else if (typeof object.target === "object")
                    message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an UpdateUiSyncProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {p2p.UpdateUiSyncProgress} message UpdateUiSyncProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateUiSyncProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.current = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.current = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.target = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
            }
            if (message.current != null && message.hasOwnProperty("current"))
                if (typeof message.current === "number")
                    object.current = options.longs === String ? String(message.current) : message.current;
                else
                    object.current = options.longs === String ? $util.Long.prototype.toString.call(message.current) : options.longs === Number ? new $util.LongBits(message.current.low >>> 0, message.current.high >>> 0).toNumber(true) : message.current;
            if (message.target != null && message.hasOwnProperty("target"))
                if (typeof message.target === "number")
                    object.target = options.longs === String ? String(message.target) : message.target;
                else
                    object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
            return object;
        };

        /**
         * Converts this UpdateUiSyncProgress to JSON.
         * @function toJSON
         * @memberof p2p.UpdateUiSyncProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateUiSyncProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdateUiSyncProgress
         * @function getTypeUrl
         * @memberof p2p.UpdateUiSyncProgress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateUiSyncProgress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UpdateUiSyncProgress";
        };

        return UpdateUiSyncProgress;
    })();

    p2p.UiNetworkInitialized = (function() {

        /**
         * Properties of an UiNetworkInitialized.
         * @memberof p2p
         * @interface IUiNetworkInitialized
         */

        /**
         * Constructs a new UiNetworkInitialized.
         * @memberof p2p
         * @classdesc Represents an UiNetworkInitialized.
         * @implements IUiNetworkInitialized
         * @constructor
         * @param {p2p.IUiNetworkInitialized=} [properties] Properties to set
         */
        function UiNetworkInitialized(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UiNetworkInitialized instance using the specified properties.
         * @function create
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {p2p.IUiNetworkInitialized=} [properties] Properties to set
         * @returns {p2p.UiNetworkInitialized} UiNetworkInitialized instance
         */
        UiNetworkInitialized.create = function create(properties) {
            return new UiNetworkInitialized(properties);
        };

        /**
         * Encodes the specified UiNetworkInitialized message. Does not implicitly {@link p2p.UiNetworkInitialized.verify|verify} messages.
         * @function encode
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {p2p.IUiNetworkInitialized} message UiNetworkInitialized message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiNetworkInitialized.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UiNetworkInitialized message, length delimited. Does not implicitly {@link p2p.UiNetworkInitialized.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {p2p.IUiNetworkInitialized} message UiNetworkInitialized message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiNetworkInitialized.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiNetworkInitialized message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UiNetworkInitialized} UiNetworkInitialized
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiNetworkInitialized.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UiNetworkInitialized();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiNetworkInitialized message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UiNetworkInitialized} UiNetworkInitialized
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiNetworkInitialized.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiNetworkInitialized message.
         * @function verify
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiNetworkInitialized.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UiNetworkInitialized message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UiNetworkInitialized} UiNetworkInitialized
         */
        UiNetworkInitialized.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UiNetworkInitialized)
                return object;
            return new $root.p2p.UiNetworkInitialized();
        };

        /**
         * Creates a plain object from an UiNetworkInitialized message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {p2p.UiNetworkInitialized} message UiNetworkInitialized
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiNetworkInitialized.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UiNetworkInitialized to JSON.
         * @function toJSON
         * @memberof p2p.UiNetworkInitialized
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiNetworkInitialized.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiNetworkInitialized
         * @function getTypeUrl
         * @memberof p2p.UiNetworkInitialized
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiNetworkInitialized.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UiNetworkInitialized";
        };

        return UiNetworkInitialized;
    })();

    p2p.UiWalletLoaded = (function() {

        /**
         * Properties of an UiWalletLoaded.
         * @memberof p2p
         * @interface IUiWalletLoaded
         * @property {string|null} [walletId] UiWalletLoaded walletId
         * @property {string|null} [balance] UiWalletLoaded balance
         * @property {string|null} [address] UiWalletLoaded address
         */

        /**
         * Constructs a new UiWalletLoaded.
         * @memberof p2p
         * @classdesc Represents an UiWalletLoaded.
         * @implements IUiWalletLoaded
         * @constructor
         * @param {p2p.IUiWalletLoaded=} [properties] Properties to set
         */
        function UiWalletLoaded(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiWalletLoaded walletId.
         * @member {string} walletId
         * @memberof p2p.UiWalletLoaded
         * @instance
         */
        UiWalletLoaded.prototype.walletId = "";

        /**
         * UiWalletLoaded balance.
         * @member {string} balance
         * @memberof p2p.UiWalletLoaded
         * @instance
         */
        UiWalletLoaded.prototype.balance = "";

        /**
         * UiWalletLoaded address.
         * @member {string} address
         * @memberof p2p.UiWalletLoaded
         * @instance
         */
        UiWalletLoaded.prototype.address = "";

        /**
         * Creates a new UiWalletLoaded instance using the specified properties.
         * @function create
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {p2p.IUiWalletLoaded=} [properties] Properties to set
         * @returns {p2p.UiWalletLoaded} UiWalletLoaded instance
         */
        UiWalletLoaded.create = function create(properties) {
            return new UiWalletLoaded(properties);
        };

        /**
         * Encodes the specified UiWalletLoaded message. Does not implicitly {@link p2p.UiWalletLoaded.verify|verify} messages.
         * @function encode
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {p2p.IUiWalletLoaded} message UiWalletLoaded message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiWalletLoaded.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletId != null && Object.hasOwnProperty.call(message, "walletId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.walletId);
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.balance);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified UiWalletLoaded message, length delimited. Does not implicitly {@link p2p.UiWalletLoaded.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {p2p.IUiWalletLoaded} message UiWalletLoaded message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiWalletLoaded.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiWalletLoaded message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UiWalletLoaded} UiWalletLoaded
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiWalletLoaded.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UiWalletLoaded();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.walletId = reader.string();
                        break;
                    }
                case 2: {
                        message.balance = reader.string();
                        break;
                    }
                case 3: {
                        message.address = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiWalletLoaded message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UiWalletLoaded} UiWalletLoaded
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiWalletLoaded.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiWalletLoaded message.
         * @function verify
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiWalletLoaded.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                if (!$util.isString(message.walletId))
                    return "walletId: string expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isString(message.balance))
                    return "balance: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates an UiWalletLoaded message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UiWalletLoaded} UiWalletLoaded
         */
        UiWalletLoaded.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UiWalletLoaded)
                return object;
            var message = new $root.p2p.UiWalletLoaded();
            if (object.walletId != null)
                message.walletId = String(object.walletId);
            if (object.balance != null)
                message.balance = String(object.balance);
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from an UiWalletLoaded message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {p2p.UiWalletLoaded} message UiWalletLoaded
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiWalletLoaded.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.walletId = "";
                object.balance = "";
                object.address = "";
            }
            if (message.walletId != null && message.hasOwnProperty("walletId"))
                object.walletId = message.walletId;
            if (message.balance != null && message.hasOwnProperty("balance"))
                object.balance = message.balance;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this UiWalletLoaded to JSON.
         * @function toJSON
         * @memberof p2p.UiWalletLoaded
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiWalletLoaded.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiWalletLoaded
         * @function getTypeUrl
         * @memberof p2p.UiWalletLoaded
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiWalletLoaded.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UiWalletLoaded";
        };

        return UiWalletLoaded;
    })();

    p2p.UiPeerList = (function() {

        /**
         * Properties of an UiPeerList.
         * @memberof p2p
         * @interface IUiPeerList
         * @property {Array.<string>|null} [peerIds] UiPeerList peerIds
         */

        /**
         * Constructs a new UiPeerList.
         * @memberof p2p
         * @classdesc Represents an UiPeerList.
         * @implements IUiPeerList
         * @constructor
         * @param {p2p.IUiPeerList=} [properties] Properties to set
         */
        function UiPeerList(properties) {
            this.peerIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiPeerList peerIds.
         * @member {Array.<string>} peerIds
         * @memberof p2p.UiPeerList
         * @instance
         */
        UiPeerList.prototype.peerIds = $util.emptyArray;

        /**
         * Creates a new UiPeerList instance using the specified properties.
         * @function create
         * @memberof p2p.UiPeerList
         * @static
         * @param {p2p.IUiPeerList=} [properties] Properties to set
         * @returns {p2p.UiPeerList} UiPeerList instance
         */
        UiPeerList.create = function create(properties) {
            return new UiPeerList(properties);
        };

        /**
         * Encodes the specified UiPeerList message. Does not implicitly {@link p2p.UiPeerList.verify|verify} messages.
         * @function encode
         * @memberof p2p.UiPeerList
         * @static
         * @param {p2p.IUiPeerList} message UiPeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiPeerList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerIds != null && message.peerIds.length)
                for (var i = 0; i < message.peerIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerIds[i]);
            return writer;
        };

        /**
         * Encodes the specified UiPeerList message, length delimited. Does not implicitly {@link p2p.UiPeerList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UiPeerList
         * @static
         * @param {p2p.IUiPeerList} message UiPeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiPeerList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiPeerList message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UiPeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UiPeerList} UiPeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiPeerList.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UiPeerList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.peerIds && message.peerIds.length))
                            message.peerIds = [];
                        message.peerIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiPeerList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UiPeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UiPeerList} UiPeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiPeerList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiPeerList message.
         * @function verify
         * @memberof p2p.UiPeerList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiPeerList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerIds != null && message.hasOwnProperty("peerIds")) {
                if (!Array.isArray(message.peerIds))
                    return "peerIds: array expected";
                for (var i = 0; i < message.peerIds.length; ++i)
                    if (!$util.isString(message.peerIds[i]))
                        return "peerIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates an UiPeerList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UiPeerList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UiPeerList} UiPeerList
         */
        UiPeerList.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UiPeerList)
                return object;
            var message = new $root.p2p.UiPeerList();
            if (object.peerIds) {
                if (!Array.isArray(object.peerIds))
                    throw TypeError(".p2p.UiPeerList.peerIds: array expected");
                message.peerIds = [];
                for (var i = 0; i < object.peerIds.length; ++i)
                    message.peerIds[i] = String(object.peerIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an UiPeerList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UiPeerList
         * @static
         * @param {p2p.UiPeerList} message UiPeerList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiPeerList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peerIds = [];
            if (message.peerIds && message.peerIds.length) {
                object.peerIds = [];
                for (var j = 0; j < message.peerIds.length; ++j)
                    object.peerIds[j] = message.peerIds[j];
            }
            return object;
        };

        /**
         * Converts this UiPeerList to JSON.
         * @function toJSON
         * @memberof p2p.UiPeerList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiPeerList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiPeerList
         * @function getTypeUrl
         * @memberof p2p.UiPeerList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiPeerList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UiPeerList";
        };

        return UiPeerList;
    })();

    p2p.UiTotalSupply = (function() {

        /**
         * Properties of an UiTotalSupply.
         * @memberof p2p
         * @interface IUiTotalSupply
         * @property {string|null} [supplyString] UiTotalSupply supplyString
         */

        /**
         * Constructs a new UiTotalSupply.
         * @memberof p2p
         * @classdesc Represents an UiTotalSupply.
         * @implements IUiTotalSupply
         * @constructor
         * @param {p2p.IUiTotalSupply=} [properties] Properties to set
         */
        function UiTotalSupply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiTotalSupply supplyString.
         * @member {string} supplyString
         * @memberof p2p.UiTotalSupply
         * @instance
         */
        UiTotalSupply.prototype.supplyString = "";

        /**
         * Creates a new UiTotalSupply instance using the specified properties.
         * @function create
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {p2p.IUiTotalSupply=} [properties] Properties to set
         * @returns {p2p.UiTotalSupply} UiTotalSupply instance
         */
        UiTotalSupply.create = function create(properties) {
            return new UiTotalSupply(properties);
        };

        /**
         * Encodes the specified UiTotalSupply message. Does not implicitly {@link p2p.UiTotalSupply.verify|verify} messages.
         * @function encode
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {p2p.IUiTotalSupply} message UiTotalSupply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiTotalSupply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.supplyString != null && Object.hasOwnProperty.call(message, "supplyString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.supplyString);
            return writer;
        };

        /**
         * Encodes the specified UiTotalSupply message, length delimited. Does not implicitly {@link p2p.UiTotalSupply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {p2p.IUiTotalSupply} message UiTotalSupply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiTotalSupply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiTotalSupply message from the specified reader or buffer.
         * @function decode
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {p2p.UiTotalSupply} UiTotalSupply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiTotalSupply.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.p2p.UiTotalSupply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.supplyString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiTotalSupply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {p2p.UiTotalSupply} UiTotalSupply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiTotalSupply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiTotalSupply message.
         * @function verify
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiTotalSupply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.supplyString != null && message.hasOwnProperty("supplyString"))
                if (!$util.isString(message.supplyString))
                    return "supplyString: string expected";
            return null;
        };

        /**
         * Creates an UiTotalSupply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {p2p.UiTotalSupply} UiTotalSupply
         */
        UiTotalSupply.fromObject = function fromObject(object) {
            if (object instanceof $root.p2p.UiTotalSupply)
                return object;
            var message = new $root.p2p.UiTotalSupply();
            if (object.supplyString != null)
                message.supplyString = String(object.supplyString);
            return message;
        };

        /**
         * Creates a plain object from an UiTotalSupply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {p2p.UiTotalSupply} message UiTotalSupply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiTotalSupply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.supplyString = "";
            if (message.supplyString != null && message.hasOwnProperty("supplyString"))
                object.supplyString = message.supplyString;
            return object;
        };

        /**
         * Converts this UiTotalSupply to JSON.
         * @function toJSON
         * @memberof p2p.UiTotalSupply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiTotalSupply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiTotalSupply
         * @function getTypeUrl
         * @memberof p2p.UiTotalSupply
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiTotalSupply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/p2p.UiTotalSupply";
        };

        return UiTotalSupply;
    })();

    return p2p;
})();

module.exports = $root;
