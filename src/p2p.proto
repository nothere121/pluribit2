syntax = "proto3";

package p2p;

// Rationale: This file defines the strict, language-agnostic contract for all
// peer-to-peer messages. Using a binary format like Protobuf instead of JSON
// completely eliminates text-based parsing vulnerabilities such as Prototype
// Pollution and Regular Expression DoS (ReDoS).

message VrfProof {
  bytes gamma = 1;
  bytes c = 2;
  bytes s = 3;
  bytes output = 4;
}

message VdfProof {
  bytes y = 1;
  bytes pi = 2;
  bytes l = 3;
  bytes r = 4;
  uint64 iterations = 5;
}

message Challenge {
    string challenge = 1;
    string from = 2;
    string difficulty = 3; 
}

message ChallengeResponse {
    string solution = 1;
    string nonce = 2;
    string from = 3;
}

message DirectBlockRequest {
    string hash = 1;
}

// This wrapper allows the response to be either a block or an error message.
message BlockTransferResponse {
    oneof payload {
        Block block_data = 1;
        string error_reason = 2;
    }
}
message TransactionInput {
  bytes commitment = 1;
  // Merkle proof is omitted for network transmission to save space.
  uint64 source_height = 2;
}

message TransactionOutput {
  bytes commitment = 1;
  optional bytes ephemeral_key = 3;
  optional bytes stealth_payload = 4;
  optional bytes viewTag = 5;
}

message TransactionKernel {
  bytes excess = 1;
  bytes signature = 2;
  uint64 fee = 3;
  uint64 min_height = 4;
  uint64 timestamp = 5;
}

message Transaction {
  repeated TransactionInput inputs = 1;
  repeated TransactionOutput outputs = 2;
  repeated TransactionKernel kernels = 3;
  uint64 timestamp = 4;
  bytes aggregated_range_proof = 5; 
}

message Block {
  uint64 height = 1;
  string prev_hash = 2;
  uint64 timestamp = 3;
  repeated Transaction transactions = 4;
  uint64 lottery_nonce = 5;
  VrfProof vrf_proof = 6;
  VdfProof vdf_proof = 7;
  bytes miner_pubkey = 8;
  bytes vrf_threshold = 9;
  uint64 vdf_iterations = 10;
  bytes tx_merkle_root = 11;
  uint64 total_work = 12;
  string hash = 13;
}

// Announce new blocks by hash to save bandwidth.
message BlockAnnouncement {
  string hash = 1;
  uint64 height = 2;
}

// Request a block by its hash.
message BlockRequest {
  string hash = 1;
}

// Request block hashes for syncing.
message GetHashesRequest {
  uint64 start_height = 1;
  string request_id = 2;
}

// Response containing a chunk of block hashes.
message HashesResponse {
  repeated string hashes = 1;
  string request_id = 2;
  bool final_chunk = 3;
}

// NEW: An empty message for tip requests. The presence of the message is the request.
message TipRequest {}

// RENAMED from TipBroadcast to be more explicit.
message TipResponse {
  string tip_hash = 1;
  uint64 height = 2;
  string total_work = 3; // Rationale: Use string for u64/BigInt safety.
}

// NEW: A wrapper message for all messages sent on the SYNC topic.
message SyncMessage {
  oneof payload {
    TipRequest tip_request = 1;
    TipResponse tip_response = 2;
  }
}

// Dandelion stem-phase transaction wrapper
message DandelionStem {
  Transaction transaction = 1;
  uint32 hop_count = 2;
  uint64 timestamp = 3; // When stem phase started
}

// Marker for DB recovery (NOT a P2P message)
message ReorgMarker {
  uint64 original_tip_height = 1;
  uint64 new_tip_height = 2;
  string new_tip_hash = 3;
  repeated string blocks_to_attach = 4;
  repeated uint64 blocks_to_detach_heights = 5;
  uint64 timestamp = 6;
}

// --- ATOMIC SWAP MESSAGES ---

// Based on the AdaptorSignature struct in src/adaptor.rs
message AdaptorSignature {
    bytes public_nonce = 1;
    bytes adaptor_point = 2;
    bytes pre_signature = 3;
    bytes challenge = 4;
}

// Based on the AtomicSwap struct in src/atomic_swap.rs
message AtomicSwap {
  bytes swap_id = 1;
  uint64 state_enum = 2; // Using an int for the enum
  uint64 alice_amount = 3;
  bytes alice_pubkey = 4;
  bytes alice_commitment = 5;
  // alice_blinding is secret, not sent
  optional AdaptorSignature alice_adaptor_sig = 6;
  uint64 alice_timeout_height = 7;
  uint64 bob_amount = 8;
  bytes bob_pubkey = 9;
  string bob_btc_address = 10;
  string bob_btc_txid = 11;
  uint32 bob_btc_vout = 12;
  bytes bob_adaptor_sig = 13;
  uint64 bob_timeout_height = 14;
  bytes shared_adaptor_point = 15;
  // adaptor_secret is secret, not sent
  bytes secret_hash = 16;
  uint64 created_at = 17;
  uint64 expires_at = 18;
  uint64 last_updated = 19;
}

message SwapAliceAdaptorSig {
    bytes swap_id = 1;
    AdaptorSignature adaptor_sig = 2;
}

// --- PAYMENT CHANNEL MESSAGES ---

message ChannelProposal {
  bytes channel_id = 1;
  uint32 version = 2;
  bytes party_a_pubkey = 3;
  uint64 party_a_funding = 4;
  bytes party_b_pubkey = 5;
  uint64 party_b_funding = 6;
  uint64 dispute_period = 7;
  uint64 min_confirmations = 8;
  uint64 created_at = 9;
}

message CommitmentState {
  uint64 sequence_number = 1;
  uint32 owner_party_enum = 2; // 0=A, 1=B
  uint64 owner_balance = 3;
  uint64 counterparty_balance = 4;
  Transaction commitment_tx = 5;
  bytes owner_blinding = 6;
  bytes counterparty_blinding = 7;
  AdaptorSignature adaptor_signature = 8;
  bytes revocation_point = 9;
}

message ChannelAcceptance {
  bytes channel_id = 1;
  CommitmentState party_b_commitment = 2;
  bytes party_b_revocation_point = 3;
  uint64 accepted_at = 4;
}

message ChannelNonce {
    bytes channel_id = 1;
    bytes public_nonce_point = 2; // R_i
}

message ChannelPartialSig {
    bytes channel_id = 1;
    bytes partial_signature = 2; // s_i
    // We also need to send the final funding tx
    // so the counterparty can verify the signature.
    Transaction funding_tx = 3; 
}

message RevocationData {
    uint32 party_enum = 1;
    uint64 sequence_number = 2;
    bytes revocation_secret = 3;
    bytes revocation_point = 4;
    uint64 revoked_at = 5;
}

message PaymentProposal {
    bytes channel_id = 1;
    uint64 new_sequence = 2;
    uint64 amount = 3;
    uint32 sender_party_enum = 4;
    uint64 new_balance_a = 5;
    uint64 new_balance_b = 6;
    CommitmentState new_commitment = 7;
    optional RevocationData old_revocation = 8;
    uint64 timestamp = 9;
}

message PaymentAcceptance {
    bytes channel_id = 1;
    uint64 sequence = 2;
    CommitmentState new_commitment = 3;
    optional RevocationData old_revocation = 4;
    uint64 accepted_at = 5;
}

// Top-level message wrapper.
message P2pMessage {
  oneof payload {
    Block block = 1;
    Transaction transaction = 2;
    BlockAnnouncement block_announcement = 3;
    BlockRequest block_request = 4;
    GetHashesRequest get_hashes_request = 5;
    HashesResponse hashes_response = 6;
    SyncMessage sync_message = 7;
    DandelionStem dandelion_stem = 8;
    
    // Atomic Swaps
    AtomicSwap swap_propose = 9;
    AtomicSwap swap_respond = 10;
    SwapAliceAdaptorSig swap_alice_adaptor_sig = 11;
    
    // Payment Channels
    ChannelProposal channel_propose = 12;
    ChannelAcceptance channel_accept = 13;
    ChannelNonce channel_fund_nonce = 14;
    ChannelPartialSig channel_fund_sig = 15;
    PaymentProposal channel_pay_propose = 16;
    PaymentAcceptance channel_pay_accept = 17;
    ChannelNonce channel_close_nonce = 18;
    ChannelPartialSig channel_close_sig = 19;
  }
}
