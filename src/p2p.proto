syntax = "proto3";

package p2p;

// Rationale: This file defines the strict, language-agnostic contract for all
// peer-to-peer messages. Using a binary format like Protobuf instead of JSON
// completely eliminates text-based parsing vulnerabilities such as Prototype
// Pollution and Regular Expression DoS (ReDoS).

message VrfProof {
  bytes gamma = 1;
  bytes c = 2;
  bytes s = 3;
  bytes output = 4;
}

message VdfProof {
  bytes y = 1;
  bytes pi = 2;
  bytes l = 3;
  bytes r = 4;
  uint64 iterations = 5;
}

message Challenge {
    string challenge = 1;
    string from = 2;
    string difficulty = 3; 
}

message ChallengeResponse {
    string solution = 1;
    string nonce = 2;
    string from = 3;
}

message DirectBlockRequest {
    string hash = 1;
}

// This wrapper allows the response to be either a block or an error message.
message BlockTransferResponse {
    oneof payload {
        Block block_data = 1;
        string error_reason = 2;
    }
}
message TransactionInput {
  bytes commitment = 1;
  // Merkle proof is omitted for network transmission to save space.
  uint64 source_height = 2;
}

message TransactionOutput {
  bytes commitment = 1;
  optional bytes ephemeral_key = 3;
  optional bytes stealth_payload = 4;
  optional bytes viewTag = 5;
}

message TransactionKernel {
  bytes excess = 1;
  bytes signature = 2;
  uint64 fee = 3;
  uint64 min_height = 4;
  uint64 timestamp = 5;
}

message Transaction {
  repeated TransactionInput inputs = 1;
  repeated TransactionOutput outputs = 2;
  repeated TransactionKernel kernels = 3;
  uint64 timestamp = 4;
  bytes aggregated_range_proof = 5; 
}

message Block {
  uint64 height = 1;
  string prev_hash = 2;
  uint64 timestamp = 3;
  repeated Transaction transactions = 4;
  uint64 lottery_nonce = 5;
  VrfProof vrf_proof = 6;
  VdfProof vdf_proof = 7;
  bytes miner_pubkey = 8;
  bytes vrf_threshold = 9;
  uint64 vdf_iterations = 10;
  bytes tx_merkle_root = 11;
  uint64 total_work = 12;
  string hash = 13;
}

// Announce new blocks by hash to save bandwidth.
message BlockAnnouncement {
  string hash = 1;
  uint64 height = 2;
}

// Request a block by its hash.
message BlockRequest {
  string hash = 1;
}

// Request block hashes for syncing.
message GetHashesRequest {
  uint64 start_height = 1;
  string request_id = 2;
}

// Response containing a chunk of block hashes.
message HashesResponse {
  repeated string hashes = 1;
  string request_id = 2;
  bool final_chunk = 3;
}

// NEW: An empty message for tip requests. The presence of the message is the request.
message TipRequest {}

// RENAMED from TipBroadcast to be more explicit.
message TipResponse {
  string tip_hash = 1;
  uint64 height = 2;
  string total_work = 3; // Rationale: Use string for u64/BigInt safety.
}

// NEW: A wrapper message for all messages sent on the SYNC topic.
message SyncMessage {
  oneof payload {
    TipRequest tip_request = 1;
    TipResponse tip_response = 2;
  }
}

// Dandelion stem-phase transaction wrapper
message DandelionStem {
  Transaction transaction = 1;
  uint32 hop_count = 2;
  uint64 timestamp = 3; // When stem phase started
}

// Marker for DB recovery (NOT a P2P message)
message ReorgMarker {
  uint64 original_tip_height = 1;
  uint64 new_tip_height = 2;
  string new_tip_hash = 3;
  repeated string blocks_to_attach = 4;
  repeated uint64 blocks_to_detach_heights = 5;
  uint64 timestamp = 6;
}

// --- ATOMIC SWAP MESSAGES ---

// Based on the AdaptorSignature struct in src/adaptor.rs
message AdaptorSignature {
    bytes public_nonce = 1;
    bytes adaptor_point = 2;
    bytes pre_signature = 3;
    bytes challenge = 4;
}

// Based on the AtomicSwap struct in src/atomic_swap.rs
message AtomicSwap {
  bytes swap_id = 1;
  uint64 state_enum = 2; // Using an int for the enum
  uint64 alice_amount = 3;
  bytes alice_pubkey = 4;
  bytes alice_commitment = 5;
  // alice_blinding is secret, not sent
  optional AdaptorSignature alice_adaptor_sig = 6;
  uint64 alice_timeout_height = 7;
  uint64 bob_amount = 8;
  bytes bob_pubkey = 9;
  string bob_btc_address = 10;
  string bob_btc_txid = 11;
  uint32 bob_btc_vout = 12;
  bytes bob_adaptor_sig = 13;
  uint64 bob_timeout_height = 14;
  bytes shared_adaptor_point = 15;
  // adaptor_secret is secret, not sent
  bytes secret_hash = 16;
  uint64 created_at = 17;
  uint64 expires_at = 18;
  uint64 last_updated = 19;
}

message SwapAliceAdaptorSig {
    bytes swap_id = 1;
    AdaptorSignature adaptor_sig = 2;
}

// --- PAYMENT CHANNEL MESSAGES ---

message ChannelProposal {
  bytes channel_id = 1;
  uint32 version = 2;
  bytes party_a_pubkey = 3;
  uint64 party_a_funding = 4;
  bytes party_b_pubkey = 5;
  uint64 party_b_funding = 6;
  uint64 dispute_period = 7;
  uint64 min_confirmations = 8;
  uint64 created_at = 9;
}

message CommitmentState {
  uint64 sequence_number = 1;
  uint32 owner_party_enum = 2; // 0=A, 1=B
  uint64 owner_balance = 3;
  uint64 counterparty_balance = 4;
  Transaction commitment_tx = 5;
  bytes owner_blinding = 6;
  bytes counterparty_blinding = 7;
  AdaptorSignature adaptor_signature = 8;
  bytes revocation_point = 9;
}

message ChannelAcceptance {
  bytes channel_id = 1;
  CommitmentState party_b_commitment = 2;
  bytes party_b_revocation_point = 3;
  uint64 accepted_at = 4;
}

message ChannelNonce {
    bytes channel_id = 1;
    bytes public_nonce_point = 2; // R_i
}

message ChannelPartialSig {
    bytes channel_id = 1;
    bytes partial_signature = 2; // s_i
    // We also need to send the final funding tx
    // so the counterparty can verify the signature.
    Transaction funding_tx = 3; 
}

message RevocationData {
    uint32 party_enum = 1;
    uint64 sequence_number = 2;
    bytes revocation_secret = 3;
    bytes revocation_point = 4;
    uint64 revoked_at = 5;
}

message PaymentProposal {
    bytes channel_id = 1;
    uint64 new_sequence = 2;
    uint64 amount = 3;
    uint32 sender_party_enum = 4;
    uint64 new_balance_a = 5;
    uint64 new_balance_b = 6;
    CommitmentState new_commitment = 7;
    optional RevocationData old_revocation = 8;
    uint64 timestamp = 9;
}

message PaymentAcceptance {
    bytes channel_id = 1;
    uint64 sequence = 2;
    CommitmentState new_commitment = 3;
    optional RevocationData old_revocation = 4;
    uint64 accepted_at = 5;
}

// 1. The Request
message GetBlockFiltersRequest {
  uint64 start_height = 1;
  uint64 end_height = 2;
  string request_id = 3;
}

// 2. The Data (Wraps the JSON/bytes you already store)
message BlockFilterData {
  uint64 height = 1;
  bytes filter_entries = 2; // The raw bytes from load_block_filter_range
}

// 3. The Response
message BlockFiltersResponse {
  repeated BlockFilterData filters = 1;
  string request_id = 2;
}

// Top-level message wrapper.
message P2pMessage {
  oneof payload {
    Block block = 1;
    Transaction transaction = 2;
    BlockAnnouncement block_announcement = 3;
    BlockRequest block_request = 4;
    GetHashesRequest get_hashes_request = 5;
    HashesResponse hashes_response = 6;
    SyncMessage sync_message = 7;
    DandelionStem dandelion_stem = 8;
    
    // Atomic Swaps
    AtomicSwap swap_propose = 9;
    AtomicSwap swap_respond = 10;
    SwapAliceAdaptorSig swap_alice_adaptor_sig = 11;
    
    // Payment Channels
    ChannelProposal channel_propose = 12;
    ChannelAcceptance channel_accept = 13;
    ChannelNonce channel_fund_nonce = 14;
    ChannelPartialSig channel_fund_sig = 15;
    PaymentProposal channel_pay_propose = 16;
    PaymentAcceptance channel_pay_accept = 17;
    ChannelNonce channel_close_nonce = 18;
    ChannelPartialSig channel_close_sig = 19;
    
    //compact block filters
    GetBlockFiltersRequest get_block_filters = 20;        
    BlockFiltersResponse block_filters_response = 21;         
  }
}
// ===================================================================
//
// RUST-LED ARCHITECTURE ADDITIONS
//
// These messages define the new, unified API bridge between the
// JavaScript I/O layer (Node.js) and the Rust Wasm core (the "brain").
//
// ===================================================================


// -------------------------------------------------------------------
// 1. JavaScript-to-Rust: Command Wrapper
//    (Used for CLI commands and system events)
// -------------------------------------------------------------------

// This is the single wrapper for ALL commands JS sends to Rust.
// Rust's `handle_command` function will receive this.
message JSToRust_Command {
  oneof command {
    // System Initialization
    InitializeRequest initialize = 1;

    // Wallet Management
    CreateWalletRequest create_wallet = 2;
    RestoreWalletRequest restore_wallet = 3;
    LoadWalletRequest load_wallet = 4;
    GetBalanceRequest get_balance = 5;
    CreateTransactionRequest create_transaction = 6;

    // Node & Chain
    ToggleMinerRequest toggle_miner = 7;
    GetStatusRequest get_status = 8;
    GetSupplyRequest get_supply = 9;
    GetPeersRequest get_peers = 10;
    ConnectPeerRequest connect_peer = 11;

    // System Ticks
    SyncTickRequest sync_tick = 12;

    // Atomic Swaps
    SwapInitiateRequest swap_initiate = 13;
    SwapListRequest swap_list = 14;
    SwapRespondRequest swap_respond = 15;
    SwapClaimRequest swap_claim = 16;
    SwapRefundRequest swap_refund = 17;

    // Payment Channels
    ChannelOpenRequest channel_open = 18;
    ChannelListRequest channel_list = 19;
    ChannelAcceptRequest channel_accept = 20;
    ChannelFundRequest channel_fund = 21;
    ChannelPayRequest channel_pay = 22;
    ChannelCloseRequest channel_close = 23;
  }
}

// -------------------------------------------------------------------
// 2. JavaScript-to-Rust: Network Event Wrapper
//    (Used for all network events from libp2p)
// -------------------------------------------------------------------

// This is the single wrapper for ALL network events JS sends to Rust.
// Rust's `handle_network_message` function will receive this.
message JSToRust_NetworkEvent {
  oneof event {
    // Note: We pass the *raw bytes* from libp2p.
    // Rust will decode the `P2pMessage` internally.
    P2pMessageReceived p2p_message = 1;
    PeerConnected peer_connected = 2;
    PeerDisconnected peer_disconnected = 3;
    PeerVerified peer_verified = 4;
  }
}

// -------------------------------------------------------------------
// 3. Rust-to-JavaScript: Command Wrapper
//    (Used for all commands Rust sends back to JS)
// -------------------------------------------------------------------

// This is the single wrapper for ALL command batches Rust sends to JS.
// This is the return value of both `handle_command` and `handle_network_message`.
message RustToJs_CommandBatch {
  repeated RustCommand commands = 1;
}

// A single command for the "dumb" JS layer to execute.
message RustCommand {
  oneof command {
    // Core I/O
    LogMessage log_message = 1;
    PublishP2pMessage p2p_publish = 2;
    SendDirectP2pMessage p2p_send_direct = 3;
    HangUpPeer p2p_hang_up = 4;

    // UI Updates
    UpdateUiBalance update_ui_balance = 5;
    UpdateUiMinerStatus update_ui_miner_status = 6;
    UpdateUiSyncProgress update_ui_sync_progress = 7;
    UiNetworkInitialized ui_network_initialized = 8;
    UiWalletLoaded ui_wallet_loaded = 9;
    UiPeerList ui_peer_list = 10;
    UiTotalSupply ui_total_supply = 11;
  }
}

// ===================================================================
//
// INNER MESSAGE DEFINITIONS
//
// ===================================================================

// --- Definitions for JSToRust_Command ---

message InitializeRequest {
  // Empty - just signals the command
}

message CreateWalletRequest {
  string wallet_id = 1;
}

message RestoreWalletRequest {
  string wallet_id = 1;
  string phrase = 2;
}

message LoadWalletRequest {
  string wallet_id = 1;
}

message GetBalanceRequest {
  string wallet_id = 1;
}

message CreateTransactionRequest {
  string from_wallet_id = 1;
  string to_address = 2;
  uint64 amount = 3; // Protobuf handles u64 -> BigInt
  uint64 fee = 4;
}

message ToggleMinerRequest {
  string miner_id = 1;
}

message GetStatusRequest {
  // Empty
}

message GetSupplyRequest {
  // Empty
}

message GetPeersRequest {
  // Empty
}

message ConnectPeerRequest {
  string multiaddr = 1;
}

message SyncTickRequest {
  // Empty - just signals the tick
}

message SwapInitiateRequest {
  string wallet_id = 1;
  string counterparty_pubkey = 2;
  uint64 plb_amount = 3;
  uint64 btc_amount = 4;
  uint64 timeout_blocks = 5;
}

message SwapListRequest {
  // Empty
}

message SwapRespondRequest {
  string wallet_id = 1;
  string swap_id = 2;
  string btc_address = 3;
  string btc_txid = 4;
  uint32 btc_vout = 5;
}

message SwapClaimRequest {
  string wallet_id = 1;
  string swap_id = 2;
  string adaptor_secret_hex = 3;
}

message SwapRefundRequest {
  string wallet_id = 1;
  string swap_id = 2;
}

message ChannelOpenRequest {
  string wallet_id = 1;
  string counterparty_pubkey = 2;
  uint64 my_amount = 3;
  uint64 their_amount = 4;
}

message ChannelListRequest {
  // Empty
}

message ChannelAcceptRequest {
  string wallet_id = 1;
  string proposal_id = 2;
}

message ChannelFundRequest {
  string wallet_id = 1;
  string channel_id = 2;
}

message ChannelPayRequest {
  string wallet_id = 1;
  string channel_id = 2;
  uint64 amount = 3;
}

message ChannelCloseRequest {
  string wallet_id = 1;
  string channel_id = 2;
}

// --- Definitions for JSToRust_NetworkEvent ---

message P2pMessageReceived {
  string topic = 1;
  bytes data = 2; // Raw bytes from libp2p
  string from_peer_id = 3;
}

message PeerConnected {
  string peer_id = 1;
}

message PeerDisconnected {
  string peer_id = 1;
}

message PeerVerified {
  string peer_id = 1;
}

// --- Definitions for RustToJs_CommandBatch ---

message LogMessage {
  string level = 1; // "info", "warn", "error", "debug"
  string message = 2;
}

message PublishP2pMessage {
  string topic = 1;
  bytes data = 2; // Raw, *already encoded* P2pMessage bytes
}

message SendDirectP2pMessage {
  string peer_id = 1;
  string protocol = 2;
  bytes data = 3; // Raw bytes of the message
}

message HangUpPeer {
  string peer_id = 1;
  string reason = 2;
}

message UpdateUiBalance {
  string wallet_id = 1;
  string balance_string = 2; // Use string for u64 safety
}

message UpdateUiMinerStatus {
  bool is_mining = 1;
}

message UpdateUiSyncProgress {
  uint64 current = 1;
  uint64 target = 2;
  uint64 start_time = 3; // JS timestamp (ms)
}

message UiNetworkInitialized {
  // Empty
}

message UiWalletLoaded {
  string wallet_id = 1;
  string balance = 2;
  string address = 3;
}

message UiPeerList {
  repeated string peer_ids = 1;
}

message UiTotalSupply {
  string supply_string = 1;
}
