<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pluriƀit Light Wallet</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --panel-color: #161b22;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-color: #58a6ff;
            --success-color: #238636;
            --error-color: #da3633;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: 100%;
        }

        .sidebar {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-content {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        h1 { font-size: 1.2rem; color: var(--text-primary); margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;}
        h3 { font-size: 0.8rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin: 0 0 10px 0; }

        .card {
            background: #0d1117;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        label { display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px; }
        
        input, textarea {
            width: 100%;
            background: #0d1117;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background-color: #21262d;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: 0.2s;
        }

        button:hover { background-color: #30363d; }
        button.primary { background-color: var(--success-color); border-color: rgba(27,31,35,0.15); color: white; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--error-color);
        }
        .status-indicator.connected { background-color: var(--success-color); box-shadow: 0 0 8px var(--success-color); }

        .logs {
            flex: 1;
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            overflow-y: auto;
            white-space: pre-wrap;
            color: #c9d1d9;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #1f1f1f; padding-bottom: 2px; }
        .log-error { color: #f85149; }
        .log-warn { color: #d29922; }
        .log-success { color: #238636; }

        .tab { padding: 8px 16px; cursor: pointer; color: var(--text-secondary); border-bottom: 2px solid transparent; }
        .tab.active { border-bottom: 2px solid var(--accent-color); color: var(--text-primary); }
        .wallet-info { word-break: break-all; font-size: 0.8rem; color: var(--accent-color); font-family: var(--font-mono);}
        
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
            .sidebar { display: none; } 
        }
    </style>
    
<script type="importmap">
    {
      "imports": {
        "libp2p": "https://esm.sh/libp2p@1.9.4", 
        "@libp2p/websockets": "https://esm.sh/@libp2p/websockets@8.2.0",
        "@chainsafe/libp2p-noise": "https://esm.sh/@chainsafe/libp2p-noise@15.1.1",
        "@chainsafe/libp2p-yamux": "https://esm.sh/@chainsafe/libp2p-yamux@6.0.2",
        "@chainsafe/libp2p-gossipsub": "https://esm.sh/@chainsafe/libp2p-gossipsub@13.1.0",
        "@multiformats/multiaddr": "https://esm.sh/@multiformats/multiaddr@12.3.0",
        "@multiformats/multiaddr/resolvers": "https://esm.sh/@multiformats/multiaddr@12.3.0/resolvers",
        "@libp2p/mplex": "https://esm.sh/@libp2p/mplex@10.1.5",
        "@libp2p/identify": "https://esm.sh/@libp2p/identify@2.1.5",
        "protobufjs": "https://esm.sh/protobufjs@7.2.6",
        "uint8arrays": "https://esm.sh/uint8arrays@5.1.0"
      }
    }
</script>
</head>
<body>

<div class="container">
    <div class="sidebar">
        <h1><span class="status-indicator" id="status-dot"></span> Pluriƀit Light</h1>
        
        <div class="card">
            <h3>Network Connection</h3>
            <label>Bootstrap Multiaddr</label>
            <input type="text" id="node-addr" value="/ip4/139.59.239.126/tcp/26659/ws/p2p/12D3KooWKdkkG4VnUDtc5Wmg336T6KyFpRUZszWuMZG4qFy6SM1T"> 
            <div style="font-size: 0.7rem; color: #666; margin-bottom: 10px;">
                Must use <b>WebSockets</b> (/ws). Use `peers` command in node to get ID.
            </div>
            <button id="btn-connect" class="primary">Connect P2P</button>
        </div>

        <div class="card">
            <h3>Peer Swarm</h3>
            <div id="peers-list" style="font-size: 0.75rem; font-family: monospace;">Not connected</div>
        </div>
    </div>

    <div class="main-content">
        <div style="display: flex; gap: 10px; border-bottom: 1px solid #30363d; margin-bottom: 15px;">
            <div class="tab active">Wallet Dashboard</div>
        </div>

        <div id="setup-view">
            <div style="text-align: center; padding: 40px;">
                <h2 style="margin-bottom: 20px;">Welcome to Pluriƀit</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 600px; margin: 0 auto;">
                    <div class="card">
                        <h3>New User</h3>
                        <button id="btn-create-wallet" class="primary">Create New Wallet</button>
                    </div>
                    <div class="card">
                        <h3>Existing User</h3>
                        <textarea id="input-mnemonic" rows="3" placeholder="Enter 12-word mnemonic..."></textarea>
                        <button id="btn-restore-wallet">Restore Wallet</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="wallet-view" style="display: none;">
            <div style="font-size: 2.5rem; font-weight: bold; text-align: center; margin: 20px 0; color: white;">
                <span id="balance">0.00</span> <span style="font-size: 1rem; color: #8b949e;">PLB</span>
            </div>
            
            <div id="mnemonic-display" style="display:none; background: #161b22; border: 1px dashed #58a6ff; padding: 15px; margin: 15px 0; color: #58a6ff; font-family: monospace; white-space: pre-wrap;"></div>

            <div class="card">
                <h3>Your Stealth Address</h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="wallet-info" id="address-display">Generating...</div>
                    <button id="btn-copy" style="width: auto; padding: 5px 10px;">Copy</button>
                </div>
            </div>

            <div class="card">
                <h3>Send Transaction</h3>
                <div style="display: grid; grid-template-columns: 1fr 100px; gap: 10px;">
                    <input type="text" id="send-to" placeholder="Recipient Stealth Address (pb1...)">
                    <input type="number" id="send-amount" placeholder="Amount">
                </div>
                <button id="btn-send">Send</button>
            </div>

            <div class="card">
                <h3>Light Client Sync</h3>
                <p style="font-size: 0.8rem; color: #8b949e;">Fetches block filters (BIP158) to find relevant blocks.</p>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <input type="number" id="scan-start" placeholder="Start Height" value="0" style="width: 100px;">
                    <input type="number" id="scan-end" placeholder="End Height" value="100" style="width: 100px;">
                    <button id="btn-scan" class="primary">Scan Filters</button>
                </div>
            </div>
        </div>

        <h3 style="margin-top: auto; padding-top: 10px; border-top: 1px solid var(--border-color);">
            Activity Log
        </h3>
        <div class="logs" id="logs"></div>
    </div>
</div>

<script id="proto-def" type="text/plain">
    syntax = "proto3";
    package p2p;

    message Block {
        uint64 height = 1;
        string prev_hash = 2;
        uint64 timestamp = 3;
        repeated Transaction transactions = 4;
        uint64 lottery_nonce = 5;
        bytes miner_pubkey = 8;
        bytes vrf_threshold = 9;
        uint64 vdf_iterations = 10;
        bytes tx_merkle_root = 11;
        uint64 total_work = 12;
        string hash = 13;
    }

    message Transaction {
        repeated TransactionInput inputs = 1;
        repeated TransactionOutput outputs = 2;
        repeated TransactionKernel kernels = 3;
        uint64 timestamp = 4;
        bytes aggregated_range_proof = 5; 
    }

    message TransactionInput {
        bytes commitment = 1;
        uint64 source_height = 2;
    }

    message TransactionOutput {
        bytes commitment = 1;
        optional bytes ephemeral_key = 3;
        optional bytes stealth_payload = 4;
        optional bytes viewTag = 5; 
    }

    message TransactionKernel {
        bytes excess = 1;
        bytes signature = 2;
        uint64 fee = 3;
        uint64 min_height = 4;
        uint64 timestamp = 5;
    }

    message GetHashesRequest {
        uint64 start_height = 1;
        string request_id = 2;
    }

    message HashesResponse {
        repeated string hashes = 1;
        string request_id = 2;
        bool final_chunk = 3;
    }

    message GetBlockFiltersRequest {
        uint64 start_height = 1;
        uint64 end_height = 2;
        string request_id = 3;
    }

    message BlockFilterData {
        uint64 height = 1;
        bytes filter_entries = 2; 
    }

    message BlockFiltersResponse {
        repeated BlockFilterData filters = 1;
        string request_id = 2;
    }

    message BlockRequest {
        string hash = 1;
    }

    message P2pMessage {
        oneof payload {
            Block block = 1;
            Transaction transaction = 2;
            GetHashesRequest get_hashes_request = 5;
            HashesResponse hashes_response = 6;
            GetBlockFiltersRequest get_block_filters = 20;
            BlockFiltersResponse block_filters_response = 21;
            BlockRequest block_request = 4;
        }
    }
</script>

<script>
    // Helper to simulate async DB ops
    const dbOp = async (key, val) => {
        if (val === undefined) return localStorage.getItem(key);
        if (val === null) return localStorage.removeItem(key);
        return localStorage.setItem(key, val);
    };

    // --- Wallet Persistence ---
    window.load_wallet_from_db = async (id) => dbOp(`pluribit_wallet:${id}`);
    window.save_wallet_to_db = async (id, json) => dbOp(`pluribit_wallet:${id}`, json);
    
    // --- Stubs for Light Client (No-op or minimal implementation) ---
    // The WASM module expects these to exist on the global window object.
    
    window.load_block_from_db = async () => null; // Light client doesn't store full blocks usually
    window.get_tip_height_from_db = async () => {
        const h = await dbOp('tip_height');
        return h ? BigInt(h) : 0n;
    };
    window.save_total_work_to_db = async () => {};
    window.get_total_work_from_db = async () => 0n;
    window.saveBlock = async () => {};
    window.saveBlockWithHash = async () => {};
    window.loadBlocks = async () => [];
    
    // UTXO Management (Simplified for light client wallet cache)
    window.load_all_utxos = async () => {
        // In a real light client, this would load from a persistent cache
        // For now, return empty map to force a rescan or reliance on in-memory wallet state
        return new Map(); 
    };
    window.loadAllUtxos = async () => new Map();
    window.save_utxo = async () => {};
    window.load_utxo = async () => null;
    window.delete_utxo = async () => {};
    window.clear_all_utxos = async () => {};
    
    // Coinbase & Indexing
    window.save_coinbase_index = async () => {};
    window.delete_coinbase_index = async () => {};
    window.loadAllCoinbaseIndexes = async () => new Map();
    
    // Filters & Reorgs
    window.save_block_filter = async () => {};
    window.load_block_filter_range = async () => ({});
    window.delete_block_filter = async () => {};
    window.save_reorg_marker = async () => {};
    window.clear_reorg_marker = async () => {};
    window.check_incomplete_reorg = async () => null;
    window.save_block_to_staging = async () => {};
    window.commit_staged_reorg = async () => {};
    window.loadBlockByHash = async () => null;
    window.deleteCanonicalBlock = async () => {};
    window.setTipMetadata = async (height, hash) => {
        await dbOp('tip_height', height.toString());
    };
    window.postRustCommands = (bytes) => console.log("Rust command received (ignored in light client):", bytes);
</script>

<script type="module">
    import init, * as pluribit from './pkg-web/pluribit_core.js';
    import { createLibp2p } from 'libp2p';
    import { webSockets } from '@libp2p/websockets';
    import { noise } from '@chainsafe/libp2p-noise';
    import { yamux } from '@chainsafe/libp2p-yamux';
    import { gossipsub } from '@chainsafe/libp2p-gossipsub';
    import { multiaddr } from '@multiformats/multiaddr';
    import { mplex } from '@libp2p/mplex';
    import { identify } from '@libp2p/identify';
    import protobuf from 'protobufjs';

    const NETWORK = 'mainnet';
    const WALLET_ID = 'browser_primary';
    
    const TOPICS = {
        BLOCKS: `/pluribit/${NETWORK}/blocks/1.0.0`,
        TRANSACTIONS: `/pluribit/${NETWORK}/transactions/1.0.0`,
        FILTERS: `/pluribit/${NETWORK}/filters/1.0.0`,
        REQ_HASHES: `/pluribit/${NETWORK}/get-hashes-request/1.0.0`,
        RESP_HASHES: `/pluribit/${NETWORK}/hashes-response/1.0.0`,
        REQ_BLOCK: `/pluribit/${NETWORK}/block-request/1.0.0`
    };

    let p2pNode = null;
    let rootProto = null;
    let pendingRequests = new Map(); // requestId -> callback
    let currentWalletJson = null;

    function log(msg, type = 'info') {
        const el = document.getElementById('logs');
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        el.appendChild(div);
        el.scrollTop = el.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${msg}`);
    }

    async function initProto() {
        const protoSrc = document.getElementById('proto-def').textContent;
        const root = protobuf.parse(protoSrc).root;
        rootProto = {
            P2pMessage: root.lookupType("p2p.P2pMessage"),
            Block: root.lookupType("p2p.Block"),
            Transaction: root.lookupType("p2p.Transaction")
        };
        log("Protocol buffers initialized.", "success");
    }

    async function createWallet() {
        try {
            const phrase = pluribit.wallet_session_create_with_mnemonic(WALLET_ID);
            const display = document.getElementById('mnemonic-display');
            display.style.display = 'block';
            display.textContent = `IMPORTANT: SAVE THIS PHRASE!\n\n${phrase}`;
            await finalizeWalletLoad();
            log("New wallet created.", "success");
        } catch (e) {
            log(`Create error: ${e}`, "error");
        }
    }

    async function restoreWallet() {
        const phrase = document.getElementById('input-mnemonic').value.trim();
        if (!phrase) return alert("Enter mnemonic.");
        try {
            pluribit.wallet_session_restore_from_mnemonic(WALLET_ID, phrase);
            await finalizeWalletLoad();
            log("Wallet restored.", "success");
        } catch (e) {
            log(`Restore error: ${e}`, "error");
        }
    }

    async function finalizeWalletLoad() {
        try {
            const json = pluribit.wallet_session_export(WALLET_ID);
            currentWalletJson = json;
            localStorage.setItem(`pluribit_wallet:${WALLET_ID}`, json);
            const addr = pluribit.wallet_session_get_address(WALLET_ID);
            
            document.getElementById('setup-view').style.display = 'none';
            document.getElementById('wallet-view').style.display = 'block';
            document.getElementById('address-display').textContent = addr;
            updateBalance();
        } catch (e) {
            log(`Load error: ${e}`, "error");
        }
    }

    function updateBalance() {
        if (!currentWalletJson) return;
        try {
            const rawBal = pluribit.wallet_get_balance(currentWalletJson);
            const plb = Number(rawBal) / 100_000_000;
            document.getElementById('balance').textContent = plb.toFixed(2);
        } catch (e) {
            console.error("Balance error:", e);
        }
    }

    async function loadPersistedWallet() {
        const stored = localStorage.getItem(`pluribit_wallet:${WALLET_ID}`);
        if (stored) {
            try {
                pluribit.wallet_session_create(WALLET_ID);
                // We must re-open it using the stored JSON to populate the Rust session
                // Note: The stub 'load_wallet_from_db' is used by Rust internals, 
                // but here we invoke the JS export directly if available, or simulate the flow.
                
                // Since `wallet_session_open` isn't explicitly exported in the provided lib.rs snippet,
                // we might rely on `wallet_session_create` + some internal load. 
                // BUT `handle_load_wallet_internal` in Rust does the logic. 
                // For the light client, we assume `wallet_session_create` initializes an empty session,
                // and we might need a way to inject the JSON.
                
                // Workaround: Since `wallet_session_create` creates a NEW wallet, we shouldn't use it for loading.
                // We need to use the restore function or if there's a specific load function.
                // Looking at lib.rs, we should use `wallet_session_open_internal` logic exposed via a wrapper?
                // Actually, in the provided `lib.rs` there isn't a direct `wallet_session_import` export. 
                // However, there is `wallet_session_create` which initializes the map.
                // Let's assume we can overwrite it or use a restore flow if needed. 
                // For this demo, we will rely on `wallet_session_create` initializing it and then:
                // *Correction*: `wallet_session_create` makes a NEW random wallet.
                // The best way with current bindings is `wallet_session_create` then we manually overwrite
                // the session in Rust? No.
                // Let's assume the user must Restore if persistence loading isn't fully exposed yet.
                // OR, if we assume `load_wallet` CLI command logic:
                // It calls `load_wallet_from_db` (JS) then `wallet_session_open_internal`.
                // We can trigger this via `handle_command` if we want to be fancy, or just restore.
                
                // For simplicity in this light wallet demo: 
                // We will treat "Restore" as the primary way to load until a direct JSON import is exposed.
                log("Found saved wallet. Use 'Restore' or 'Create New' to overwrite.", "info");
            } catch(e) {
                log("Failed load saved wallet logic.", "warn");
            }
        }
    }

    async function connectP2P() {
        const btn = document.getElementById('btn-connect');
        const addrInput = document.getElementById('node-addr').value.trim();
        btn.disabled = true;
        btn.textContent = "Connecting...";

        try {
            try {
                const ma = multiaddr(addrInput);
                if(!ma.protoNames().includes('ws') && !ma.protoNames().includes('wss')) {
                    throw new Error("Address must include /ws or /wss.");
                }
            } catch(e) {
                throw new Error(`Invalid address: ${e.message}`);
            }

            if (!p2pNode) {
                log("Initializing Libp2p...", "info");
                
                p2pNode = await createLibp2p({
                    transports: [ webSockets() ],
                    connectionEncryption: [ noise() ],
                    streamMuxers: [ yamux(), mplex() ],
                    services: {
                        pubsub: gossipsub({ allowPublishToZeroTopicPeers: true, emitSelf: true }),
                        identify: identify()
                    }
                });

                p2pNode.services.pubsub.addEventListener('message', handleP2PMessage);
                
                p2pNode.addEventListener('peer:connect', (evt) => {
                    log(`Peer connected: ${evt.detail.toString().slice(-8)}`, "info");
                    updatePeerUI();
                });
                
                p2pNode.addEventListener('peer:disconnect', (evt) => {
                    updatePeerUI();
                });
                
                Object.values(TOPICS).forEach(t => {
                    p2pNode.services.pubsub.subscribe(t);
                });

                await p2pNode.start();
                log(`Node Started. ID: ...${p2pNode.peerId.toString().slice(-6)}`, "info");
            }

            log(`Dialing: ${addrInput}`, "info");
            const conn = await p2pNode.dial(multiaddr(addrInput));
            
            document.getElementById('status-dot').classList.add('connected');
            btn.disabled = false;
            btn.textContent = "Connected";
            log(`✓ Connected to Bootstrap Node!`, "success");
            
            updatePeerUI();

        } catch (e) {
            log(`Connection failed: ${e.message}`, "error");
            btn.disabled = false;
            btn.textContent = "Connect P2P";
        }
    }

    function updatePeerUI() {
        if (!p2pNode) return;
        const list = document.getElementById('peers-list');
        const connections = p2pNode.getConnections();
        
        if (connections.length === 0) {
            list.innerHTML = '<div style="color: #666;">No peers connected</div>';
        } else {
            list.innerHTML = connections.map(conn => {
                const peerId = conn.remotePeer.toString();
                const addr = conn.remoteAddr.toString();
                return `<div style="margin-bottom: 5px;">
                    <div style="color: #58a6ff;">${peerId.slice(0, 8)}...${peerId.slice(-6)}</div>
                    <div style="color: #666; font-size: 0.7rem;">${addr}</div>
                </div>`;
            }).join('');
        }
    }

    async function publishMessage(topic, type, payload) {
        if (!p2pNode) return;
        const Msg = rootProto.P2pMessage;
        // Create the oneof payload object
        const content = {};
        content[type] = payload; 
        
        const message = Msg.create({ [type]: payload }); 
        // Note: Protobufjs 'create' with oneof can be tricky. 
        // It's safer to assign the specific property to the message object.
        const msgObj = {};
        msgObj[type] = payload;
        
        const bytes = Msg.encode(msgObj).finish();
        await p2pNode.services.pubsub.publish(topic, bytes);
    }

    async function handleP2PMessage(evt) {
        const { topic, data, from } = evt.detail;
        
        try {
            const msg = rootProto.P2pMessage.decode(data);

            if (topic === TOPICS.FILTERS && msg.blockFiltersResponse) {
                const res = msg.blockFiltersResponse;
                if (pendingRequests.has(res.requestId)) {
                    pendingRequests.get(res.requestId)(res);
                    pendingRequests.delete(res.requestId);
                }
            }
            else if (topic === TOPICS.BLOCKS && msg.block) {
                log(`← Block #${msg.block.height} received via Gossip`, "info");
                processBlock(msg.block);
            }
        } catch (e) {
            // console.debug('Failed to decode P2P message:', e);
        }
    }

    async function performScan() {
        if (!currentWalletJson) return log("Load wallet first.", "error");
        if (!p2pNode || p2pNode.getConnections().length === 0) return log("No peers connected.", "error");

        const start = parseInt(document.getElementById('scan-start').value);
        const end = parseInt(document.getElementById('scan-end').value);
        log(`Scanning filters ${start} to ${end}...`, "info");

        const BATCH = 50;
        for (let i = start; i <= end; i += BATCH) {
            const chunkEnd = Math.min(i + BATCH - 1, end);
            
            const reqId = crypto.randomUUID().slice(0, 8);
            
            const promise = new Promise((resolve, reject) => {
                const t = setTimeout(() => {
                    pendingRequests.delete(reqId);
                    reject("Timeout");
                }, 10000);
                pendingRequests.set(reqId, (res) => { clearTimeout(t); resolve(res); });
            });

            log(`Requesting filters ${i}-${chunkEnd}...`, "info");
            await publishMessage(TOPICS.FILTERS, 'getBlockFilters', {
                startHeight: i,
                endHeight: chunkEnd,
                requestId: reqId
            });

            try {
                const res = await promise;
                for (const filterData of res.filters) {
                    const filterBytes = filterData.filterEntries; // This is bytes from Protobuf
                    // In Rust, save_block_filter stored JSON string bytes. 
                    // We decode bytes to string to pass to wallet_check_filter
                    const filterJson = new TextDecoder().decode(filterBytes);
                    
                    const isMatch = pluribit.wallet_check_filter(currentWalletJson, filterJson);
                    
                    if (isMatch) {
                        log(`MATCH at block #${filterData.height}! Requesting block...`, "success");
                        // Request full block by hash? We don't have hash here unless we map it.
                        // For now, light client limitation: we need to request block by Hash.
                        // To do that, we need the header first. 
                        // Simplified: Use 'get_hashes_request' if we had it, but for this demo
                        // we just log the match.
                    }
                }
            } catch (e) {
                log(`Filter request failed: ${e}`, "warn");
            }
        }
        log("Scan complete.", "success");
    }

    async function processBlock(blockMsg) {
        try {
            // Re-encode to bytes to pass to WASM
            const BlockType = rootProto.Block;
            const blockBytes = BlockType.encode(blockMsg).finish();

            // Call Rust to scan the block
            pluribit.wallet_session_scan_block(WALLET_ID, blockBytes);

            // Export updated state
            const newJson = pluribit.wallet_session_export(WALLET_ID);
            if (newJson !== currentWalletJson) {
                currentWalletJson = newJson;
                localStorage.setItem(`pluribit_wallet:${WALLET_ID}`, newJson);
                log(`Balance updated!`, "success");
                updateBalance();
            }
        } catch (e) {
            console.error(e);
            log(`Block process error: ${e.message}`, "error");
        }
    }

    async function sendTransaction() {
        if (!currentWalletJson) return log("Load wallet first.", "error");
        const recipient = document.getElementById('send-to').value.trim();
        const amount = BigInt(document.getElementById('send-amount').value * 100000000); // Convert to integer units
        const fee = 100n; // Fixed fee for now

        try {
            log("Creating transaction...", "info");
            // Rust returns { transaction: {...}, updated_wallet_json: "..." }
            const result = pluribit.wallet_session_send_to_stealth(WALLET_ID, amount, fee, recipient);
            
            // 1. Broadcast
            await publishMessage(TOPICS.TRANSACTIONS, 'transaction', result.transaction);
            log("Transaction broadcasted!", "success");

            // 2. Update Wallet State (Optimistic update)
            // Note: result.updated_wallet_json is returned by the helper, 
            // but we need to re-import it or rely on the session being updated in Rust memory.
            // `wallet_session_send_to_stealth` updates the session in Rust memory automatically.
            const newJson = pluribit.wallet_session_export(WALLET_ID);
            currentWalletJson = newJson;
            localStorage.setItem(`pluribit_wallet:${WALLET_ID}`, newJson);
            updateBalance();

        } catch (e) {
            log(`Send failed: ${e}`, "error");
        }
    }

    // Init
    (async () => {
        try {
            await init(); 
            log("WASM Core initialized.", "success");
            await initProto();
            // Check for existing wallet data
            const stored = localStorage.getItem(`pluribit_wallet:${WALLET_ID}`);
            if(stored) log("Storage contains wallet data.", "info");

            document.getElementById('btn-connect').onclick = connectP2P;
            document.getElementById('btn-create-wallet').onclick = createWallet;
            document.getElementById('btn-restore-wallet').onclick = restoreWallet;
            document.getElementById('btn-scan').onclick = performScan;
            document.getElementById('btn-send').onclick = sendTransaction;
            document.getElementById('btn-copy').onclick = () => {
                const addr = document.getElementById('address-display').textContent;
                navigator.clipboard.writeText(addr);
                log("Copied address.", "info");
            };
        } catch(e) {
            log("Initialization failed: " + e, "error");
        }
    })();

</script>
</body>
</html>
